(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[11],{

/***/ "./node_modules/blueimp-load-image/js/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global module, require */\n\nmodule.exports = __webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")\n\n__webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\")\n__webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")\n__webpack_require__(/*! ./load-image-fetch */ \"./node_modules/blueimp-load-image/js/load-image-fetch.js\")\n__webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")\n__webpack_require__(/*! ./load-image-exif-map */ \"./node_modules/blueimp-load-image/js/load-image-exif-map.js\")\n__webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")\n__webpack_require__(/*! ./load-image-iptc-map */ \"./node_modules/blueimp-load-image/js/load-image-iptc-map.js\")\n__webpack_require__(/*! ./load-image-orientation */ \"./node_modules/blueimp-load-image/js/load-image-orientation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2luZGV4LmpzP2ZiZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXZDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsZ0dBQTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKVxuXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2Utc2NhbGUnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLWZldGNoJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmLW1hcCcpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0YycpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0Yy1tYXAnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW9yaWVudGF0aW9uJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/index.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  loadImage.ExifMap.prototype.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x8769: 'ExifIFDPointer',\n    0x8825: 'GPSInfoIFDPointer',\n    0xa005: 'InteroperabilityIFDPointer',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    // ==================\n    // Exif Sub IFD tags:\n    // ==================\n    0x9000: 'ExifVersion', // EXIF version\n    0xa000: 'FlashpixVersion', // Flashpix format version\n    0xa001: 'ColorSpace', // Color space information tag\n    0xa002: 'PixelXDimension', // Valid width of meaningful image\n    0xa003: 'PixelYDimension', // Valid height of meaningful image\n    0xa500: 'Gamma',\n    0x9101: 'ComponentsConfiguration', // Information about channels\n    0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel\n    0x927c: 'MakerNote', // Any desired information written by the manufacturer\n    0x9286: 'UserComment', // Comments by user\n    0xa004: 'RelatedSoundFile', // Name of related sound file\n    0x9003: 'DateTimeOriginal', // Date and time when the original image was generated\n    0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally\n    0x9290: 'SubSecTime', // Fractions of seconds for DateTime\n    0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal\n    0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized\n    0x829a: 'ExposureTime', // Exposure time (in seconds)\n    0x829d: 'FNumber',\n    0x8822: 'ExposureProgram', // Exposure program\n    0x8824: 'SpectralSensitivity', // Spectral sensitivity\n    0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n    0x8828: 'OECF', // Optoelectric conversion factor\n    0x8830: 'SensitivityType',\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9201: 'ShutterSpeedValue', // Shutter speed\n    0x9202: 'ApertureValue', // Lens aperture\n    0x9203: 'BrightnessValue', // Value of brightness\n    0x9204: 'ExposureBias', // Exposure bias\n    0x9205: 'MaxApertureValue', // Smallest F number of lens\n    0x9206: 'SubjectDistance', // Distance to subject in meters\n    0x9207: 'MeteringMode', // Metering mode\n    0x9208: 'LightSource', // Kind of light source\n    0x9209: 'Flash', // Flash status\n    0x9214: 'SubjectArea', // Location and area of main subject\n    0x920a: 'FocalLength', // Focal length of the lens in mm\n    0xa20b: 'FlashEnergy', // Strobe energy in BCPS\n    0xa20c: 'SpatialFrequencyResponse',\n    0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit\n    0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit\n    0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution\n    0xa214: 'SubjectLocation', // Location of subject in image\n    0xa215: 'ExposureIndex', // Exposure index selected on camera\n    0xa217: 'SensingMethod', // Image sensor type\n    0xa300: 'FileSource', // Image source (3 == DSC)\n    0xa301: 'SceneType', // Scene type (1 == directly photographed)\n    0xa302: 'CFAPattern', // Color filter array geometric pattern\n    0xa401: 'CustomRendered', // Special processing\n    0xa402: 'ExposureMode', // Exposure mode\n    0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual\n    0xa404: 'DigitalZoomRatio', // Digital zoom ratio\n    0xa405: 'FocalLengthIn35mmFilm',\n    0xa406: 'SceneCaptureType', // Type of scene\n    0xa407: 'GainControl', // Degree of overall image gain adjustment\n    0xa408: 'Contrast', // Direction of contrast processing applied by camera\n    0xa409: 'Saturation', // Direction of saturation processing applied by camera\n    0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera\n    0xa40b: 'DeviceSettingDescription',\n    0xa40c: 'SubjectDistanceRange', // Distance to subject\n    0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: 'LensSpecification',\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    // ==============\n    // GPS Info tags:\n    // ==============\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000a: 'GPSMeasureMode',\n    0x000b: 'GPSDOP',\n    0x000c: 'GPSSpeedRef',\n    0x000d: 'GPSSpeed',\n    0x000e: 'GPSTrackRef',\n    0x000f: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001a: 'GPSDestDistance',\n    0x001b: 'GPSProcessingMethod',\n    0x001c: 'GPSAreaInformation',\n    0x001d: 'GPSDateStamp',\n    0x001e: 'GPSDifferential',\n    0x001f: 'GPSHPositioningError'\n  }\n\n  loadImage.ExifMap.prototype.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'top-left',\n      2: 'top-right',\n      3: 'bottom-right',\n      4: 'bottom-left',\n      5: 'left-top',\n      6: 'right-top',\n      7: 'right-bottom',\n      8: 'left-bottom'\n    }\n  }\n\n  loadImage.ExifMap.prototype.getText = function(id) {\n    var value = this.get(id)\n    switch (id) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[id][value]\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return\n        return String.fromCharCode(value[0], value[1], value[2], value[3])\n      case 'ComponentsConfiguration':\n        if (!value) return\n        return (\n          this.stringValues[id][value[0]] +\n          this.stringValues[id][value[1]] +\n          this.stringValues[id][value[2]] +\n          this.stringValues[id][value[3]]\n        )\n      case 'GPSVersionID':\n        if (!value) return\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]\n    }\n    return String(value)\n  }\n  ;(function(exifMapPrototype) {\n    var tags = exifMapPrototype.tags\n    var map = exifMapPrototype.map\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = prop\n      }\n    }\n  })(loadImage.ExifMap.prototype)\n\n  loadImage.ExifMap.prototype.getAll = function() {\n    var map = {}\n    var prop\n    var id\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        id = this.tags[prop]\n        if (id) {\n          map[id] = this.getText(id)\n        }\n      }\n    }\n    return map\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi1tYXAuanM/NzU2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRCxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWV4aWYtbWFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBFeGlmIE1hcFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBFeGlmIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZWlkZWxpbi9leGlmLWpzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJywgJy4vbG9hZC1pbWFnZS1leGlmJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpLCByZXF1aXJlKCcuL2xvYWQtaW1hZ2UtZXhpZicpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICBsb2FkSW1hZ2UuRXhpZk1hcC5wcm90b3R5cGUudGFncyA9IHtcbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIC8vIFRJRkYgdGFncyAoSUZEMCk6XG4gICAgLy8gPT09PT09PT09PT09PT09PT1cbiAgICAweDAxMDA6ICdJbWFnZVdpZHRoJyxcbiAgICAweDAxMDE6ICdJbWFnZUhlaWdodCcsXG4gICAgMHg4NzY5OiAnRXhpZklGRFBvaW50ZXInLFxuICAgIDB4ODgyNTogJ0dQU0luZm9JRkRQb2ludGVyJyxcbiAgICAweGEwMDU6ICdJbnRlcm9wZXJhYmlsaXR5SUZEUG9pbnRlcicsXG4gICAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gICAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLFxuICAgIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAgIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAgIDB4MDExYzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAgIDB4MDIxMjogJ1lDYkNyU3ViU2FtcGxpbmcnLFxuICAgIDB4MDIxMzogJ1lDYkNyUG9zaXRpb25pbmcnLFxuICAgIDB4MDExYTogJ1hSZXNvbHV0aW9uJyxcbiAgICAweDAxMWI6ICdZUmVzb2x1dGlvbicsXG4gICAgMHgwMTI4OiAnUmVzb2x1dGlvblVuaXQnLFxuICAgIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gICAgMHgwMTE2OiAnUm93c1BlclN0cmlwJyxcbiAgICAweDAxMTc6ICdTdHJpcEJ5dGVDb3VudHMnLFxuICAgIDB4MDIwMTogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdCcsXG4gICAgMHgwMjAyOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoJyxcbiAgICAweDAxMmQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgICAweDAxM2U6ICdXaGl0ZVBvaW50JyxcbiAgICAweDAxM2Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAgIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJyxcbiAgICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgICAweDAxMzI6ICdEYXRlVGltZScsXG4gICAgMHgwMTBlOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gICAgMHgwMTBmOiAnTWFrZScsXG4gICAgMHgwMTEwOiAnTW9kZWwnLFxuICAgIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgICAweDAxM2I6ICdBcnRpc3QnLFxuICAgIDB4ODI5ODogJ0NvcHlyaWdodCcsXG4gICAgLy8gPT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhpZiBTdWIgSUZEIHRhZ3M6XG4gICAgLy8gPT09PT09PT09PT09PT09PT09XG4gICAgMHg5MDAwOiAnRXhpZlZlcnNpb24nLCAvLyBFWElGIHZlcnNpb25cbiAgICAweGEwMDA6ICdGbGFzaHBpeFZlcnNpb24nLCAvLyBGbGFzaHBpeCBmb3JtYXQgdmVyc2lvblxuICAgIDB4YTAwMTogJ0NvbG9yU3BhY2UnLCAvLyBDb2xvciBzcGFjZSBpbmZvcm1hdGlvbiB0YWdcbiAgICAweGEwMDI6ICdQaXhlbFhEaW1lbnNpb24nLCAvLyBWYWxpZCB3aWR0aCBvZiBtZWFuaW5nZnVsIGltYWdlXG4gICAgMHhhMDAzOiAnUGl4ZWxZRGltZW5zaW9uJywgLy8gVmFsaWQgaGVpZ2h0IG9mIG1lYW5pbmdmdWwgaW1hZ2VcbiAgICAweGE1MDA6ICdHYW1tYScsXG4gICAgMHg5MTAxOiAnQ29tcG9uZW50c0NvbmZpZ3VyYXRpb24nLCAvLyBJbmZvcm1hdGlvbiBhYm91dCBjaGFubmVsc1xuICAgIDB4OTEwMjogJ0NvbXByZXNzZWRCaXRzUGVyUGl4ZWwnLCAvLyBDb21wcmVzc2VkIGJpdHMgcGVyIHBpeGVsXG4gICAgMHg5MjdjOiAnTWFrZXJOb3RlJywgLy8gQW55IGRlc2lyZWQgaW5mb3JtYXRpb24gd3JpdHRlbiBieSB0aGUgbWFudWZhY3R1cmVyXG4gICAgMHg5Mjg2OiAnVXNlckNvbW1lbnQnLCAvLyBDb21tZW50cyBieSB1c2VyXG4gICAgMHhhMDA0OiAnUmVsYXRlZFNvdW5kRmlsZScsIC8vIE5hbWUgb2YgcmVsYXRlZCBzb3VuZCBmaWxlXG4gICAgMHg5MDAzOiAnRGF0ZVRpbWVPcmlnaW5hbCcsIC8vIERhdGUgYW5kIHRpbWUgd2hlbiB0aGUgb3JpZ2luYWwgaW1hZ2Ugd2FzIGdlbmVyYXRlZFxuICAgIDB4OTAwNDogJ0RhdGVUaW1lRGlnaXRpemVkJywgLy8gRGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBpbWFnZSB3YXMgc3RvcmVkIGRpZ2l0YWxseVxuICAgIDB4OTI5MDogJ1N1YlNlY1RpbWUnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVcbiAgICAweDkyOTE6ICdTdWJTZWNUaW1lT3JpZ2luYWwnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVPcmlnaW5hbFxuICAgIDB4OTI5MjogJ1N1YlNlY1RpbWVEaWdpdGl6ZWQnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVEaWdpdGl6ZWRcbiAgICAweDgyOWE6ICdFeHBvc3VyZVRpbWUnLCAvLyBFeHBvc3VyZSB0aW1lIChpbiBzZWNvbmRzKVxuICAgIDB4ODI5ZDogJ0ZOdW1iZXInLFxuICAgIDB4ODgyMjogJ0V4cG9zdXJlUHJvZ3JhbScsIC8vIEV4cG9zdXJlIHByb2dyYW1cbiAgICAweDg4MjQ6ICdTcGVjdHJhbFNlbnNpdGl2aXR5JywgLy8gU3BlY3RyYWwgc2Vuc2l0aXZpdHlcbiAgICAweDg4Mjc6ICdQaG90b2dyYXBoaWNTZW5zaXRpdml0eScsIC8vIEVYSUYgMi4zLCBJU09TcGVlZFJhdGluZ3MgaW4gRVhJRiAyLjJcbiAgICAweDg4Mjg6ICdPRUNGJywgLy8gT3B0b2VsZWN0cmljIGNvbnZlcnNpb24gZmFjdG9yXG4gICAgMHg4ODMwOiAnU2Vuc2l0aXZpdHlUeXBlJyxcbiAgICAweDg4MzE6ICdTdGFuZGFyZE91dHB1dFNlbnNpdGl2aXR5JyxcbiAgICAweDg4MzI6ICdSZWNvbW1lbmRlZEV4cG9zdXJlSW5kZXgnLFxuICAgIDB4ODgzMzogJ0lTT1NwZWVkJyxcbiAgICAweDg4MzQ6ICdJU09TcGVlZExhdGl0dWRleXl5JyxcbiAgICAweDg4MzU6ICdJU09TcGVlZExhdGl0dWRlenp6JyxcbiAgICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsIC8vIFNodXR0ZXIgc3BlZWRcbiAgICAweDkyMDI6ICdBcGVydHVyZVZhbHVlJywgLy8gTGVucyBhcGVydHVyZVxuICAgIDB4OTIwMzogJ0JyaWdodG5lc3NWYWx1ZScsIC8vIFZhbHVlIG9mIGJyaWdodG5lc3NcbiAgICAweDkyMDQ6ICdFeHBvc3VyZUJpYXMnLCAvLyBFeHBvc3VyZSBiaWFzXG4gICAgMHg5MjA1OiAnTWF4QXBlcnR1cmVWYWx1ZScsIC8vIFNtYWxsZXN0IEYgbnVtYmVyIG9mIGxlbnNcbiAgICAweDkyMDY6ICdTdWJqZWN0RGlzdGFuY2UnLCAvLyBEaXN0YW5jZSB0byBzdWJqZWN0IGluIG1ldGVyc1xuICAgIDB4OTIwNzogJ01ldGVyaW5nTW9kZScsIC8vIE1ldGVyaW5nIG1vZGVcbiAgICAweDkyMDg6ICdMaWdodFNvdXJjZScsIC8vIEtpbmQgb2YgbGlnaHQgc291cmNlXG4gICAgMHg5MjA5OiAnRmxhc2gnLCAvLyBGbGFzaCBzdGF0dXNcbiAgICAweDkyMTQ6ICdTdWJqZWN0QXJlYScsIC8vIExvY2F0aW9uIGFuZCBhcmVhIG9mIG1haW4gc3ViamVjdFxuICAgIDB4OTIwYTogJ0ZvY2FsTGVuZ3RoJywgLy8gRm9jYWwgbGVuZ3RoIG9mIHRoZSBsZW5zIGluIG1tXG4gICAgMHhhMjBiOiAnRmxhc2hFbmVyZ3knLCAvLyBTdHJvYmUgZW5lcmd5IGluIEJDUFNcbiAgICAweGEyMGM6ICdTcGF0aWFsRnJlcXVlbmN5UmVzcG9uc2UnLFxuICAgIDB4YTIwZTogJ0ZvY2FsUGxhbmVYUmVzb2x1dGlvbicsIC8vIE51bWJlciBvZiBwaXhlbHMgaW4gd2lkdGggZGlyZWN0aW9uIHBlciBGUFJVbml0XG4gICAgMHhhMjBmOiAnRm9jYWxQbGFuZVlSZXNvbHV0aW9uJywgLy8gTnVtYmVyIG9mIHBpeGVscyBpbiBoZWlnaHQgZGlyZWN0aW9uIHBlciBGUFJVbml0XG4gICAgMHhhMjEwOiAnRm9jYWxQbGFuZVJlc29sdXRpb25Vbml0JywgLy8gVW5pdCBmb3IgbWVhc3VyaW5nIHRoZSBmb2NhbCBwbGFuZSByZXNvbHV0aW9uXG4gICAgMHhhMjE0OiAnU3ViamVjdExvY2F0aW9uJywgLy8gTG9jYXRpb24gb2Ygc3ViamVjdCBpbiBpbWFnZVxuICAgIDB4YTIxNTogJ0V4cG9zdXJlSW5kZXgnLCAvLyBFeHBvc3VyZSBpbmRleCBzZWxlY3RlZCBvbiBjYW1lcmFcbiAgICAweGEyMTc6ICdTZW5zaW5nTWV0aG9kJywgLy8gSW1hZ2Ugc2Vuc29yIHR5cGVcbiAgICAweGEzMDA6ICdGaWxlU291cmNlJywgLy8gSW1hZ2Ugc291cmNlICgzID09IERTQylcbiAgICAweGEzMDE6ICdTY2VuZVR5cGUnLCAvLyBTY2VuZSB0eXBlICgxID09IGRpcmVjdGx5IHBob3RvZ3JhcGhlZClcbiAgICAweGEzMDI6ICdDRkFQYXR0ZXJuJywgLy8gQ29sb3IgZmlsdGVyIGFycmF5IGdlb21ldHJpYyBwYXR0ZXJuXG4gICAgMHhhNDAxOiAnQ3VzdG9tUmVuZGVyZWQnLCAvLyBTcGVjaWFsIHByb2Nlc3NpbmdcbiAgICAweGE0MDI6ICdFeHBvc3VyZU1vZGUnLCAvLyBFeHBvc3VyZSBtb2RlXG4gICAgMHhhNDAzOiAnV2hpdGVCYWxhbmNlJywgLy8gMSA9IGF1dG8gd2hpdGUgYmFsYW5jZSwgMiA9IG1hbnVhbFxuICAgIDB4YTQwNDogJ0RpZ2l0YWxab29tUmF0aW8nLCAvLyBEaWdpdGFsIHpvb20gcmF0aW9cbiAgICAweGE0MDU6ICdGb2NhbExlbmd0aEluMzVtbUZpbG0nLFxuICAgIDB4YTQwNjogJ1NjZW5lQ2FwdHVyZVR5cGUnLCAvLyBUeXBlIG9mIHNjZW5lXG4gICAgMHhhNDA3OiAnR2FpbkNvbnRyb2wnLCAvLyBEZWdyZWUgb2Ygb3ZlcmFsbCBpbWFnZSBnYWluIGFkanVzdG1lbnRcbiAgICAweGE0MDg6ICdDb250cmFzdCcsIC8vIERpcmVjdGlvbiBvZiBjb250cmFzdCBwcm9jZXNzaW5nIGFwcGxpZWQgYnkgY2FtZXJhXG4gICAgMHhhNDA5OiAnU2F0dXJhdGlvbicsIC8vIERpcmVjdGlvbiBvZiBzYXR1cmF0aW9uIHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgICAweGE0MGE6ICdTaGFycG5lc3MnLCAvLyBEaXJlY3Rpb24gb2Ygc2hhcnBuZXNzIHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgICAweGE0MGI6ICdEZXZpY2VTZXR0aW5nRGVzY3JpcHRpb24nLFxuICAgIDB4YTQwYzogJ1N1YmplY3REaXN0YW5jZVJhbmdlJywgLy8gRGlzdGFuY2UgdG8gc3ViamVjdFxuICAgIDB4YTQyMDogJ0ltYWdlVW5pcXVlSUQnLCAvLyBJZGVudGlmaWVyIGFzc2lnbmVkIHVuaXF1ZWx5IHRvIGVhY2ggaW1hZ2VcbiAgICAweGE0MzA6ICdDYW1lcmFPd25lck5hbWUnLFxuICAgIDB4YTQzMTogJ0JvZHlTZXJpYWxOdW1iZXInLFxuICAgIDB4YTQzMjogJ0xlbnNTcGVjaWZpY2F0aW9uJyxcbiAgICAweGE0MzM6ICdMZW5zTWFrZScsXG4gICAgMHhhNDM0OiAnTGVuc01vZGVsJyxcbiAgICAweGE0MzU6ICdMZW5zU2VyaWFsTnVtYmVyJyxcbiAgICAvLyA9PT09PT09PT09PT09PVxuICAgIC8vIEdQUyBJbmZvIHRhZ3M6XG4gICAgLy8gPT09PT09PT09PT09PT1cbiAgICAweDAwMDA6ICdHUFNWZXJzaW9uSUQnLFxuICAgIDB4MDAwMTogJ0dQU0xhdGl0dWRlUmVmJyxcbiAgICAweDAwMDI6ICdHUFNMYXRpdHVkZScsXG4gICAgMHgwMDAzOiAnR1BTTG9uZ2l0dWRlUmVmJyxcbiAgICAweDAwMDQ6ICdHUFNMb25naXR1ZGUnLFxuICAgIDB4MDAwNTogJ0dQU0FsdGl0dWRlUmVmJyxcbiAgICAweDAwMDY6ICdHUFNBbHRpdHVkZScsXG4gICAgMHgwMDA3OiAnR1BTVGltZVN0YW1wJyxcbiAgICAweDAwMDg6ICdHUFNTYXRlbGxpdGVzJyxcbiAgICAweDAwMDk6ICdHUFNTdGF0dXMnLFxuICAgIDB4MDAwYTogJ0dQU01lYXN1cmVNb2RlJyxcbiAgICAweDAwMGI6ICdHUFNET1AnLFxuICAgIDB4MDAwYzogJ0dQU1NwZWVkUmVmJyxcbiAgICAweDAwMGQ6ICdHUFNTcGVlZCcsXG4gICAgMHgwMDBlOiAnR1BTVHJhY2tSZWYnLFxuICAgIDB4MDAwZjogJ0dQU1RyYWNrJyxcbiAgICAweDAwMTA6ICdHUFNJbWdEaXJlY3Rpb25SZWYnLFxuICAgIDB4MDAxMTogJ0dQU0ltZ0RpcmVjdGlvbicsXG4gICAgMHgwMDEyOiAnR1BTTWFwRGF0dW0nLFxuICAgIDB4MDAxMzogJ0dQU0Rlc3RMYXRpdHVkZVJlZicsXG4gICAgMHgwMDE0OiAnR1BTRGVzdExhdGl0dWRlJyxcbiAgICAweDAwMTU6ICdHUFNEZXN0TG9uZ2l0dWRlUmVmJyxcbiAgICAweDAwMTY6ICdHUFNEZXN0TG9uZ2l0dWRlJyxcbiAgICAweDAwMTc6ICdHUFNEZXN0QmVhcmluZ1JlZicsXG4gICAgMHgwMDE4OiAnR1BTRGVzdEJlYXJpbmcnLFxuICAgIDB4MDAxOTogJ0dQU0Rlc3REaXN0YW5jZVJlZicsXG4gICAgMHgwMDFhOiAnR1BTRGVzdERpc3RhbmNlJyxcbiAgICAweDAwMWI6ICdHUFNQcm9jZXNzaW5nTWV0aG9kJyxcbiAgICAweDAwMWM6ICdHUFNBcmVhSW5mb3JtYXRpb24nLFxuICAgIDB4MDAxZDogJ0dQU0RhdGVTdGFtcCcsXG4gICAgMHgwMDFlOiAnR1BTRGlmZmVyZW50aWFsJyxcbiAgICAweDAwMWY6ICdHUFNIUG9zaXRpb25pbmdFcnJvcidcbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS5zdHJpbmdWYWx1ZXMgPSB7XG4gICAgRXhwb3N1cmVQcm9ncmFtOiB7XG4gICAgICAwOiAnVW5kZWZpbmVkJyxcbiAgICAgIDE6ICdNYW51YWwnLFxuICAgICAgMjogJ05vcm1hbCBwcm9ncmFtJyxcbiAgICAgIDM6ICdBcGVydHVyZSBwcmlvcml0eScsXG4gICAgICA0OiAnU2h1dHRlciBwcmlvcml0eScsXG4gICAgICA1OiAnQ3JlYXRpdmUgcHJvZ3JhbScsXG4gICAgICA2OiAnQWN0aW9uIHByb2dyYW0nLFxuICAgICAgNzogJ1BvcnRyYWl0IG1vZGUnLFxuICAgICAgODogJ0xhbmRzY2FwZSBtb2RlJ1xuICAgIH0sXG4gICAgTWV0ZXJpbmdNb2RlOiB7XG4gICAgICAwOiAnVW5rbm93bicsXG4gICAgICAxOiAnQXZlcmFnZScsXG4gICAgICAyOiAnQ2VudGVyV2VpZ2h0ZWRBdmVyYWdlJyxcbiAgICAgIDM6ICdTcG90JyxcbiAgICAgIDQ6ICdNdWx0aVNwb3QnLFxuICAgICAgNTogJ1BhdHRlcm4nLFxuICAgICAgNjogJ1BhcnRpYWwnLFxuICAgICAgMjU1OiAnT3RoZXInXG4gICAgfSxcbiAgICBMaWdodFNvdXJjZToge1xuICAgICAgMDogJ1Vua25vd24nLFxuICAgICAgMTogJ0RheWxpZ2h0JyxcbiAgICAgIDI6ICdGbHVvcmVzY2VudCcsXG4gICAgICAzOiAnVHVuZ3N0ZW4gKGluY2FuZGVzY2VudCBsaWdodCknLFxuICAgICAgNDogJ0ZsYXNoJyxcbiAgICAgIDk6ICdGaW5lIHdlYXRoZXInLFxuICAgICAgMTA6ICdDbG91ZHkgd2VhdGhlcicsXG4gICAgICAxMTogJ1NoYWRlJyxcbiAgICAgIDEyOiAnRGF5bGlnaHQgZmx1b3Jlc2NlbnQgKEQgNTcwMCAtIDcxMDBLKScsXG4gICAgICAxMzogJ0RheSB3aGl0ZSBmbHVvcmVzY2VudCAoTiA0NjAwIC0gNTQwMEspJyxcbiAgICAgIDE0OiAnQ29vbCB3aGl0ZSBmbHVvcmVzY2VudCAoVyAzOTAwIC0gNDUwMEspJyxcbiAgICAgIDE1OiAnV2hpdGUgZmx1b3Jlc2NlbnQgKFdXIDMyMDAgLSAzNzAwSyknLFxuICAgICAgMTc6ICdTdGFuZGFyZCBsaWdodCBBJyxcbiAgICAgIDE4OiAnU3RhbmRhcmQgbGlnaHQgQicsXG4gICAgICAxOTogJ1N0YW5kYXJkIGxpZ2h0IEMnLFxuICAgICAgMjA6ICdENTUnLFxuICAgICAgMjE6ICdENjUnLFxuICAgICAgMjI6ICdENzUnLFxuICAgICAgMjM6ICdENTAnLFxuICAgICAgMjQ6ICdJU08gc3R1ZGlvIHR1bmdzdGVuJyxcbiAgICAgIDI1NTogJ090aGVyJ1xuICAgIH0sXG4gICAgRmxhc2g6IHtcbiAgICAgIDB4MDAwMDogJ0ZsYXNoIGRpZCBub3QgZmlyZScsXG4gICAgICAweDAwMDE6ICdGbGFzaCBmaXJlZCcsXG4gICAgICAweDAwMDU6ICdTdHJvYmUgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgICAweDAwMDc6ICdTdHJvYmUgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDAwOTogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUnLFxuICAgICAgMHgwMDBkOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgICAweDAwMGY6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDEwOiAnRmxhc2ggZGlkIG5vdCBmaXJlLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUnLFxuICAgICAgMHgwMDE4OiAnRmxhc2ggZGlkIG5vdCBmaXJlLCBhdXRvIG1vZGUnLFxuICAgICAgMHgwMDE5OiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZScsXG4gICAgICAweDAwMWQ6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDAxZjogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwMjA6ICdObyBmbGFzaCBmdW5jdGlvbicsXG4gICAgICAweDAwNDE6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgICAweDAwNDU6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgICAweDAwNDc6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDA0OTogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuICAgICAgMHgwMDRkOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgICAweDAwNGY6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDU5OiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgICAweDAwNWQ6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA1ZjogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSdcbiAgICB9LFxuICAgIFNlbnNpbmdNZXRob2Q6IHtcbiAgICAgIDE6ICdVbmRlZmluZWQnLFxuICAgICAgMjogJ09uZS1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICAgIDM6ICdUd28tY2hpcCBjb2xvciBhcmVhIHNlbnNvcicsXG4gICAgICA0OiAnVGhyZWUtY2hpcCBjb2xvciBhcmVhIHNlbnNvcicsXG4gICAgICA1OiAnQ29sb3Igc2VxdWVudGlhbCBhcmVhIHNlbnNvcicsXG4gICAgICA3OiAnVHJpbGluZWFyIHNlbnNvcicsXG4gICAgICA4OiAnQ29sb3Igc2VxdWVudGlhbCBsaW5lYXIgc2Vuc29yJ1xuICAgIH0sXG4gICAgU2NlbmVDYXB0dXJlVHlwZToge1xuICAgICAgMDogJ1N0YW5kYXJkJyxcbiAgICAgIDE6ICdMYW5kc2NhcGUnLFxuICAgICAgMjogJ1BvcnRyYWl0JyxcbiAgICAgIDM6ICdOaWdodCBzY2VuZSdcbiAgICB9LFxuICAgIFNjZW5lVHlwZToge1xuICAgICAgMTogJ0RpcmVjdGx5IHBob3RvZ3JhcGhlZCdcbiAgICB9LFxuICAgIEN1c3RvbVJlbmRlcmVkOiB7XG4gICAgICAwOiAnTm9ybWFsIHByb2Nlc3MnLFxuICAgICAgMTogJ0N1c3RvbSBwcm9jZXNzJ1xuICAgIH0sXG4gICAgV2hpdGVCYWxhbmNlOiB7XG4gICAgICAwOiAnQXV0byB3aGl0ZSBiYWxhbmNlJyxcbiAgICAgIDE6ICdNYW51YWwgd2hpdGUgYmFsYW5jZSdcbiAgICB9LFxuICAgIEdhaW5Db250cm9sOiB7XG4gICAgICAwOiAnTm9uZScsXG4gICAgICAxOiAnTG93IGdhaW4gdXAnLFxuICAgICAgMjogJ0hpZ2ggZ2FpbiB1cCcsXG4gICAgICAzOiAnTG93IGdhaW4gZG93bicsXG4gICAgICA0OiAnSGlnaCBnYWluIGRvd24nXG4gICAgfSxcbiAgICBDb250cmFzdDoge1xuICAgICAgMDogJ05vcm1hbCcsXG4gICAgICAxOiAnU29mdCcsXG4gICAgICAyOiAnSGFyZCdcbiAgICB9LFxuICAgIFNhdHVyYXRpb246IHtcbiAgICAgIDA6ICdOb3JtYWwnLFxuICAgICAgMTogJ0xvdyBzYXR1cmF0aW9uJyxcbiAgICAgIDI6ICdIaWdoIHNhdHVyYXRpb24nXG4gICAgfSxcbiAgICBTaGFycG5lc3M6IHtcbiAgICAgIDA6ICdOb3JtYWwnLFxuICAgICAgMTogJ1NvZnQnLFxuICAgICAgMjogJ0hhcmQnXG4gICAgfSxcbiAgICBTdWJqZWN0RGlzdGFuY2VSYW5nZToge1xuICAgICAgMDogJ1Vua25vd24nLFxuICAgICAgMTogJ01hY3JvJyxcbiAgICAgIDI6ICdDbG9zZSB2aWV3JyxcbiAgICAgIDM6ICdEaXN0YW50IHZpZXcnXG4gICAgfSxcbiAgICBGaWxlU291cmNlOiB7XG4gICAgICAzOiAnRFNDJ1xuICAgIH0sXG4gICAgQ29tcG9uZW50c0NvbmZpZ3VyYXRpb246IHtcbiAgICAgIDA6ICcnLFxuICAgICAgMTogJ1knLFxuICAgICAgMjogJ0NiJyxcbiAgICAgIDM6ICdDcicsXG4gICAgICA0OiAnUicsXG4gICAgICA1OiAnRycsXG4gICAgICA2OiAnQidcbiAgICB9LFxuICAgIE9yaWVudGF0aW9uOiB7XG4gICAgICAxOiAndG9wLWxlZnQnLFxuICAgICAgMjogJ3RvcC1yaWdodCcsXG4gICAgICAzOiAnYm90dG9tLXJpZ2h0JyxcbiAgICAgIDQ6ICdib3R0b20tbGVmdCcsXG4gICAgICA1OiAnbGVmdC10b3AnLFxuICAgICAgNjogJ3JpZ2h0LXRvcCcsXG4gICAgICA3OiAncmlnaHQtYm90dG9tJyxcbiAgICAgIDg6ICdsZWZ0LWJvdHRvbSdcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2UuRXhpZk1hcC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaWQpXG4gICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnTGlnaHRTb3VyY2UnOlxuICAgICAgY2FzZSAnRmxhc2gnOlxuICAgICAgY2FzZSAnTWV0ZXJpbmdNb2RlJzpcbiAgICAgIGNhc2UgJ0V4cG9zdXJlUHJvZ3JhbSc6XG4gICAgICBjYXNlICdTZW5zaW5nTWV0aG9kJzpcbiAgICAgIGNhc2UgJ1NjZW5lQ2FwdHVyZVR5cGUnOlxuICAgICAgY2FzZSAnU2NlbmVUeXBlJzpcbiAgICAgIGNhc2UgJ0N1c3RvbVJlbmRlcmVkJzpcbiAgICAgIGNhc2UgJ1doaXRlQmFsYW5jZSc6XG4gICAgICBjYXNlICdHYWluQ29udHJvbCc6XG4gICAgICBjYXNlICdDb250cmFzdCc6XG4gICAgICBjYXNlICdTYXR1cmF0aW9uJzpcbiAgICAgIGNhc2UgJ1NoYXJwbmVzcyc6XG4gICAgICBjYXNlICdTdWJqZWN0RGlzdGFuY2VSYW5nZSc6XG4gICAgICBjYXNlICdGaWxlU291cmNlJzpcbiAgICAgIGNhc2UgJ09yaWVudGF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVmFsdWVzW2lkXVt2YWx1ZV1cbiAgICAgIGNhc2UgJ0V4aWZWZXJzaW9uJzpcbiAgICAgIGNhc2UgJ0ZsYXNocGl4VmVyc2lvbic6XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVyblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSlcbiAgICAgIGNhc2UgJ0NvbXBvbmVudHNDb25maWd1cmF0aW9uJzpcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzBdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzFdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzJdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzNdXVxuICAgICAgICApXG4gICAgICBjYXNlICdHUFNWZXJzaW9uSUQnOlxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdICsgJy4nICsgdmFsdWVbMV0gKyAnLicgKyB2YWx1ZVsyXSArICcuJyArIHZhbHVlWzNdXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gIH1cbiAgOyhmdW5jdGlvbihleGlmTWFwUHJvdG90eXBlKSB7XG4gICAgdmFyIHRhZ3MgPSBleGlmTWFwUHJvdG90eXBlLnRhZ3NcbiAgICB2YXIgbWFwID0gZXhpZk1hcFByb3RvdHlwZS5tYXBcbiAgICB2YXIgcHJvcFxuICAgIC8vIE1hcCB0aGUgdGFnIG5hbWVzIHRvIHRhZ3M6XG4gICAgZm9yIChwcm9wIGluIHRhZ3MpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFncywgcHJvcCkpIHtcbiAgICAgICAgbWFwW3RhZ3NbcHJvcF1dID0gcHJvcFxuICAgICAgfVxuICAgIH1cbiAgfSkobG9hZEltYWdlLkV4aWZNYXAucHJvdG90eXBlKVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFwID0ge31cbiAgICB2YXIgcHJvcFxuICAgIHZhciBpZFxuICAgIGZvciAocHJvcCBpbiB0aGlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3ApKSB7XG4gICAgICAgIGlkID0gdGhpcy50YWdzW3Byb3BdXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIG1hcFtpZF0gPSB0aGlzLmdldFRleHQoaWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n/* eslint-disable no-console */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  loadImage.ExifMap = function() {\n    return this\n  }\n\n  loadImage.ExifMap.prototype.map = {\n    Orientation: 0x0112\n  }\n\n  loadImage.ExifMap.prototype.get = function(id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  loadImage.getExifThumbnail = function(dataView, offset, length) {\n    if (!length || offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.')\n      return\n    }\n    return loadImage.createObjectURL(\n      new Blob([dataView.buffer.slice(offset, offset + length)])\n    )\n  }\n\n  loadImage.exifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function(dataView, dataOffset) {\n        return dataView.getUint8(dataOffset)\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function(dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset))\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function(dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian)\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function(dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function(dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getUint32(dataOffset, littleEndian) /\n          dataView.getUint32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function(dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function(dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getInt32(dataOffset, littleEndian) /\n          dataView.getInt32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    }\n  }\n  // undefined, 8-bit byte, value depending on field:\n  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]\n\n  loadImage.getExifValue = function(\n    dataView,\n    tiffOffset,\n    offset,\n    type,\n    length,\n    littleEndian\n  ) {\n    var tagType = loadImage.exifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.')\n      return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset =\n      tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : offset + 8\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.')\n      return\n    }\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(\n        dataView,\n        dataOffset + i * tagType.size,\n        littleEndian\n      )\n    }\n    if (tagType.ascii) {\n      str = ''\n      // Concatenate the chars:\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]\n        // Ignore the terminating NULL byte(s):\n        if (c === '\\u0000') {\n          break\n        }\n        str += c\n      }\n      return str\n    }\n    return values\n  }\n\n  loadImage.parseExifTag = function(\n    dataView,\n    tiffOffset,\n    offset,\n    littleEndian,\n    data\n  ) {\n    var tag = dataView.getUint16(offset, littleEndian)\n    data.exif[tag] = loadImage.getExifValue(\n      dataView,\n      tiffOffset,\n      offset,\n      dataView.getUint16(offset + 2, littleEndian), // tag type\n      dataView.getUint32(offset + 4, littleEndian), // tag length\n      littleEndian\n    )\n  }\n\n  loadImage.parseExifTags = function(\n    dataView,\n    tiffOffset,\n    dirOffset,\n    littleEndian,\n    data\n  ) {\n    var tagsNumber, dirEndOffset, i\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.')\n      return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.')\n      return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n      this.parseExifTag(\n        dataView,\n        tiffOffset,\n        dirOffset + 2 + 12 * i, // tag offset\n        littleEndian,\n        data\n      )\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n  }\n\n  loadImage.parseExifData = function(dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailData\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.')\n      return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.')\n      return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true\n        break\n      case 0x4d4d:\n        littleEndian = false\n        break\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\n        return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.')\n      return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new loadImage.ExifMap()\n    // Parse the tags of the main image directory and retrieve the\n    // offset to the next directory, usually the thumbnail directory:\n    dirOffset = loadImage.parseExifTags(\n      dataView,\n      tiffOffset,\n      tiffOffset + dirOffset,\n      littleEndian,\n      data\n    )\n    if (dirOffset && !options.disableExifThumbnail) {\n      thumbnailData = { exif: {} }\n      dirOffset = loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        thumbnailData\n      )\n      // Check for JPEG Thumbnail offset:\n      if (thumbnailData.exif[0x0201]) {\n        data.exif.Thumbnail = loadImage.getExifThumbnail(\n          dataView,\n          tiffOffset + thumbnailData.exif[0x0201],\n          thumbnailData.exif[0x0202] // Thumbnail data length\n        )\n      }\n    }\n    // Check for Exif Sub IFD Pointer:\n    if (data.exif[0x8769] && !options.disableExifSub) {\n      loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + data.exif[0x8769], // directory offset\n        littleEndian,\n        data\n      )\n    }\n    // Check for GPS Info IFD Pointer:\n    if (data.exif[0x8825] && !options.disableExifGps) {\n      loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + data.exif[0x8825], // directory offset\n        littleEndian,\n        data\n      )\n    }\n  }\n\n  // Registers the Exif parser for the APP1 JPEG meta data segment:\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\n  // Adds the following properties to the parseMetaData callback data:\n  // * exif: The exif tags, parsed by the parseExifData method\n\n  // Adds the following options to the parseMetaData method:\n  // * disableExif: Disables Exif parsing.\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcz83N2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFELEdBQUcsTUFBTSxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgRXhpZiBQYXJzZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1tZXRhJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24obG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGxvYWRJbWFnZS5FeGlmTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS5tYXAgPSB7XG4gICAgT3JpZW50YXRpb246IDB4MDExMlxuICB9XG5cbiAgbG9hZEltYWdlLkV4aWZNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8IHRoaXNbdGhpcy5tYXBbaWRdXVxuICB9XG5cbiAgbG9hZEltYWdlLmdldEV4aWZUaHVtYm5haWwgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIWxlbmd0aCB8fCBvZmZzZXQgKyBsZW5ndGggPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgdGh1bWJuYWlsIGRhdGEuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gbG9hZEltYWdlLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgIG5ldyBCbG9iKFtkYXRhVmlldy5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpXSlcbiAgICApXG4gIH1cblxuICBsb2FkSW1hZ2UuZXhpZlRhZ1R5cGVzID0ge1xuICAgIC8vIGJ5dGUsIDgtYml0IHVuc2lnbmVkIGludDpcbiAgICAxOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZGF0YVZpZXcsIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KGRhdGFPZmZzZXQpXG4gICAgICB9LFxuICAgICAgc2l6ZTogMVxuICAgIH0sXG4gICAgLy8gYXNjaWksIDgtYml0IGJ5dGU6XG4gICAgMjoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGRhdGFPZmZzZXQpKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDEsXG4gICAgICBhc2NpaTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gc2hvcnQsIDE2IGJpdCBpbnQ6XG4gICAgMzoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgICB9LFxuICAgICAgc2l6ZTogMlxuICAgIH0sXG4gICAgLy8gbG9uZywgMzIgYml0IGludDpcbiAgICA0OiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIH0sXG4gICAgICBzaXplOiA0XG4gICAgfSxcbiAgICAvLyByYXRpb25hbCA9IHR3byBsb25nIHZhbHVlcywgZmlyc3QgaXMgbnVtZXJhdG9yLCBzZWNvbmQgaXMgZGVub21pbmF0b3I6XG4gICAgNToge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSAvXG4gICAgICAgICAgZGF0YVZpZXcuZ2V0VWludDMyKGRhdGFPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBzaXplOiA4XG4gICAgfSxcbiAgICAvLyBzbG9uZywgMzIgYml0IHNpZ25lZCBpbnQ6XG4gICAgOToge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIH0sXG4gICAgICBzaXplOiA0XG4gICAgfSxcbiAgICAvLyBzcmF0aW9uYWwsIHR3byBzbG9uZ3MsIGZpcnN0IGlzIG51bWVyYXRvciwgc2Vjb25kIGlzIGRlbm9taW5hdG9yOlxuICAgIDEwOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikgL1xuICAgICAgICAgIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBzaXplOiA4XG4gICAgfVxuICB9XG4gIC8vIHVuZGVmaW5lZCwgOC1iaXQgYnl0ZSwgdmFsdWUgZGVwZW5kaW5nIG9uIGZpZWxkOlxuICBsb2FkSW1hZ2UuZXhpZlRhZ1R5cGVzWzddID0gbG9hZEltYWdlLmV4aWZUYWdUeXBlc1sxXVxuXG4gIGxvYWRJbWFnZS5nZXRFeGlmVmFsdWUgPSBmdW5jdGlvbihcbiAgICBkYXRhVmlldyxcbiAgICB0aWZmT2Zmc2V0LFxuICAgIG9mZnNldCxcbiAgICB0eXBlLFxuICAgIGxlbmd0aCxcbiAgICBsaXR0bGVFbmRpYW5cbiAgKSB7XG4gICAgdmFyIHRhZ1R5cGUgPSBsb2FkSW1hZ2UuZXhpZlRhZ1R5cGVzW3R5cGVdXG4gICAgdmFyIHRhZ1NpemVcbiAgICB2YXIgZGF0YU9mZnNldFxuICAgIHZhciB2YWx1ZXNcbiAgICB2YXIgaVxuICAgIHZhciBzdHJcbiAgICB2YXIgY1xuICAgIGlmICghdGFnVHlwZSkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIHRhZyB0eXBlLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGFnU2l6ZSA9IHRhZ1R5cGUuc2l6ZSAqIGxlbmd0aFxuICAgIC8vIERldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgY29udGFpbmVkIGluIHRoZSBkYXRhT2Zmc2V0IGJ5dGVzLFxuICAgIC8vIG9yIGlmIHRoZSB2YWx1ZSBhdCB0aGUgZGF0YU9mZnNldCBpcyBhIHBvaW50ZXIgdG8gdGhlIGFjdHVhbCBkYXRhOlxuICAgIGRhdGFPZmZzZXQgPVxuICAgICAgdGFnU2l6ZSA+IDRcbiAgICAgICAgPyB0aWZmT2Zmc2V0ICsgZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCArIDgsIGxpdHRsZUVuZGlhbilcbiAgICAgICAgOiBvZmZzZXQgKyA4XG4gICAgaWYgKGRhdGFPZmZzZXQgKyB0YWdTaXplID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGRhdGEgb2Zmc2V0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRhZ1R5cGUuZ2V0VmFsdWUoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICB9XG4gICAgdmFsdWVzID0gW11cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHRhZ1R5cGUuZ2V0VmFsdWUoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICBkYXRhT2Zmc2V0ICsgaSAqIHRhZ1R5cGUuc2l6ZSxcbiAgICAgICAgbGl0dGxlRW5kaWFuXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0YWdUeXBlLmFzY2lpKSB7XG4gICAgICBzdHIgPSAnJ1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGNoYXJzOlxuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gdmFsdWVzW2ldXG4gICAgICAgIC8vIElnbm9yZSB0aGUgdGVybWluYXRpbmcgTlVMTCBieXRlKHMpOlxuICAgICAgICBpZiAoYyA9PT0gJ1xcdTAwMDAnKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gY1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VFeGlmVGFnID0gZnVuY3Rpb24oXG4gICAgZGF0YVZpZXcsXG4gICAgdGlmZk9mZnNldCxcbiAgICBvZmZzZXQsXG4gICAgbGl0dGxlRW5kaWFuLFxuICAgIGRhdGFcbiAgKSB7XG4gICAgdmFyIHRhZyA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICBkYXRhLmV4aWZbdGFnXSA9IGxvYWRJbWFnZS5nZXRFeGlmVmFsdWUoXG4gICAgICBkYXRhVmlldyxcbiAgICAgIHRpZmZPZmZzZXQsXG4gICAgICBvZmZzZXQsXG4gICAgICBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSwgLy8gdGFnIHR5cGVcbiAgICAgIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pLCAvLyB0YWcgbGVuZ3RoXG4gICAgICBsaXR0bGVFbmRpYW5cbiAgICApXG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VFeGlmVGFncyA9IGZ1bmN0aW9uKFxuICAgIGRhdGFWaWV3LFxuICAgIHRpZmZPZmZzZXQsXG4gICAgZGlyT2Zmc2V0LFxuICAgIGxpdHRsZUVuZGlhbixcbiAgICBkYXRhXG4gICkge1xuICAgIHZhciB0YWdzTnVtYmVyLCBkaXJFbmRPZmZzZXQsIGlcbiAgICBpZiAoZGlyT2Zmc2V0ICsgNiA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBkaXJlY3Rvcnkgb2Zmc2V0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGFnc051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNihkaXJPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICBkaXJFbmRPZmZzZXQgPSBkaXJPZmZzZXQgKyAyICsgMTIgKiB0YWdzTnVtYmVyXG4gICAgaWYgKGRpckVuZE9mZnNldCArIDQgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGlyZWN0b3J5IHNpemUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFnc051bWJlcjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnBhcnNlRXhpZlRhZyhcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgIGRpck9mZnNldCArIDIgKyAxMiAqIGksIC8vIHRhZyBvZmZzZXRcbiAgICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgICBkYXRhXG4gICAgICApXG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgb2Zmc2V0IHRvIHRoZSBuZXh0IGRpcmVjdG9yeTpcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKGRpckVuZE9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlRXhpZkRhdGEgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlRXhpZikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciB0aWZmT2Zmc2V0ID0gb2Zmc2V0ICsgMTBcbiAgICB2YXIgbGl0dGxlRW5kaWFuXG4gICAgdmFyIGRpck9mZnNldFxuICAgIHZhciB0aHVtYm5haWxEYXRhXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBBU0NJSSBjb2RlIGZvciBcIkV4aWZcIiAoMHg0NTc4Njk2Nik6XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KSAhPT0gMHg0NTc4Njk2Nikge1xuICAgICAgLy8gTm8gRXhpZiBkYXRhLCBtaWdodCBiZSBYTVAgZGF0YSBpbnN0ZWFkXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRpZmZPZmZzZXQgKyA4ID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIHNlZ21lbnQgc2l6ZS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIENoZWNrIGZvciB0aGUgdHdvIG51bGwgYnl0ZXM6XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA4KSAhPT0gMHgwMDAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IE1pc3NpbmcgYnl0ZSBhbGlnbm1lbnQgb2Zmc2V0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhlIGJ5dGUgYWxpZ25tZW50OlxuICAgIHN3aXRjaCAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpKSB7XG4gICAgICBjYXNlIDB4NDk0OTpcbiAgICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAweDRkNGQ6XG4gICAgICAgIGxpdHRsZUVuZGlhbiA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgYnl0ZSBhbGlnbm1lbnQgbWFya2VyLicpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgdGhlIFRJRkYgdGFnIG1hcmtlciAoMHgwMDJBKTpcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQgKyAyLCBsaXR0bGVFbmRpYW4pICE9PSAweDAwMmEpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogTWlzc2luZyBUSUZGIG1hcmtlci4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIFJldHJpZXZlIHRoZSBkaXJlY3Rvcnkgb2Zmc2V0IGJ5dGVzLCB1c3VhbGx5IDB4MDAwMDAwMDggb3IgOCBkZWNpbWFsOlxuICAgIGRpck9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKVxuICAgIC8vIENyZWF0ZSB0aGUgZXhpZiBvYmplY3QgdG8gc3RvcmUgdGhlIHRhZ3M6XG4gICAgZGF0YS5leGlmID0gbmV3IGxvYWRJbWFnZS5FeGlmTWFwKClcbiAgICAvLyBQYXJzZSB0aGUgdGFncyBvZiB0aGUgbWFpbiBpbWFnZSBkaXJlY3RvcnkgYW5kIHJldHJpZXZlIHRoZVxuICAgIC8vIG9mZnNldCB0byB0aGUgbmV4dCBkaXJlY3RvcnksIHVzdWFsbHkgdGhlIHRodW1ibmFpbCBkaXJlY3Rvcnk6XG4gICAgZGlyT2Zmc2V0ID0gbG9hZEltYWdlLnBhcnNlRXhpZlRhZ3MoXG4gICAgICBkYXRhVmlldyxcbiAgICAgIHRpZmZPZmZzZXQsXG4gICAgICB0aWZmT2Zmc2V0ICsgZGlyT2Zmc2V0LFxuICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgZGF0YVxuICAgIClcbiAgICBpZiAoZGlyT2Zmc2V0ICYmICFvcHRpb25zLmRpc2FibGVFeGlmVGh1bWJuYWlsKSB7XG4gICAgICB0aHVtYm5haWxEYXRhID0geyBleGlmOiB7fSB9XG4gICAgICBkaXJPZmZzZXQgPSBsb2FkSW1hZ2UucGFyc2VFeGlmVGFncyhcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgIHRpZmZPZmZzZXQgKyBkaXJPZmZzZXQsXG4gICAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgICAgdGh1bWJuYWlsRGF0YVxuICAgICAgKVxuICAgICAgLy8gQ2hlY2sgZm9yIEpQRUcgVGh1bWJuYWlsIG9mZnNldDpcbiAgICAgIGlmICh0aHVtYm5haWxEYXRhLmV4aWZbMHgwMjAxXSkge1xuICAgICAgICBkYXRhLmV4aWYuVGh1bWJuYWlsID0gbG9hZEltYWdlLmdldEV4aWZUaHVtYm5haWwoXG4gICAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgICAgdGlmZk9mZnNldCArIHRodW1ibmFpbERhdGEuZXhpZlsweDAyMDFdLFxuICAgICAgICAgIHRodW1ibmFpbERhdGEuZXhpZlsweDAyMDJdIC8vIFRodW1ibmFpbCBkYXRhIGxlbmd0aFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBFeGlmIFN1YiBJRkQgUG9pbnRlcjpcbiAgICBpZiAoZGF0YS5leGlmWzB4ODc2OV0gJiYgIW9wdGlvbnMuZGlzYWJsZUV4aWZTdWIpIHtcbiAgICAgIGxvYWRJbWFnZS5wYXJzZUV4aWZUYWdzKFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCxcbiAgICAgICAgdGlmZk9mZnNldCArIGRhdGEuZXhpZlsweDg3NjldLCAvLyBkaXJlY3Rvcnkgb2Zmc2V0XG4gICAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgICAgZGF0YVxuICAgICAgKVxuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgR1BTIEluZm8gSUZEIFBvaW50ZXI6XG4gICAgaWYgKGRhdGEuZXhpZlsweDg4MjVdICYmICFvcHRpb25zLmRpc2FibGVFeGlmR3BzKSB7XG4gICAgICBsb2FkSW1hZ2UucGFyc2VFeGlmVGFncyhcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgIHRpZmZPZmZzZXQgKyBkYXRhLmV4aWZbMHg4ODI1XSwgLy8gZGlyZWN0b3J5IG9mZnNldFxuICAgICAgICBsaXR0bGVFbmRpYW4sXG4gICAgICAgIGRhdGFcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlcnMgdGhlIEV4aWYgcGFyc2VyIGZvciB0aGUgQVBQMSBKUEVHIG1ldGEgZGF0YSBzZWdtZW50OlxuICBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzLmpwZWdbMHhmZmUxXS5wdXNoKGxvYWRJbWFnZS5wYXJzZUV4aWZEYXRhKVxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBwYXJzZU1ldGFEYXRhIGNhbGxiYWNrIGRhdGE6XG4gIC8vICogZXhpZjogVGhlIGV4aWYgdGFncywgcGFyc2VkIGJ5IHRoZSBwYXJzZUV4aWZEYXRhIG1ldGhvZFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIHRoZSBwYXJzZU1ldGFEYXRhIG1ldGhvZDpcbiAgLy8gKiBkaXNhYmxlRXhpZjogRGlzYWJsZXMgRXhpZiBwYXJzaW5nLlxuICAvLyAqIGRpc2FibGVFeGlmVGh1bWJuYWlsOiBEaXNhYmxlcyBwYXJzaW5nIG9mIHRoZSBFeGlmIFRodW1ibmFpbC5cbiAgLy8gKiBkaXNhYmxlRXhpZlN1YjogRGlzYWJsZXMgcGFyc2luZyBvZiB0aGUgRXhpZiBTdWIgSUZELlxuICAvLyAqIGRpc2FibGVFeGlmR3BzOiBEaXNhYmxlcyBwYXJzaW5nIG9mIHRoZSBFeGlmIEdQUyBJbmZvIElGRC5cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-fetch.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  if (typeof fetch !== 'undefined' && typeof Request !== 'undefined') {\n    loadImage.fetchBlob = function(url, callback, options) {\n      if (loadImage.hasMetaOption(options)) {\n        return fetch(new Request(url, options))\n          .then(function(response) {\n            return response.blob()\n          })\n          .then(callback)\n          .catch(function(err) {\n            console.log(err) // eslint-disable-line no-console\n            callback()\n          })\n      }\n      callback()\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZmV0Y2guanM/YWQyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRCxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWZldGNoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBGZXRjaFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTcsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1tZXRhJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24obG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvYWRJbWFnZS5mZXRjaEJsb2IgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAobG9hZEltYWdlLmhhc01ldGFPcHRpb24ob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9ucykpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-fetch.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://github.com/jseidelin/exif-js\n * https://iptc.org/standards/photo-metadata\n * http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  loadImage.IptcMap.prototype.tags = {\n    // ==========\n    // IPTC tags:\n    // ==========\n    0x03: 'ObjectType',\n    0x04: 'ObjectAttribute',\n    0x05: 'ObjectName',\n    0x07: 'EditStatus',\n    0x08: 'EditorialUpdate',\n    0x0a: 'Urgency',\n    0x0c: 'SubjectRef',\n    0x0f: 'Category',\n    0x14: 'SupplCategory',\n    0x16: 'FixtureID',\n    0x19: 'Keywords',\n    0x1a: 'ContentLocCode',\n    0x1b: 'ContentLocName',\n    0x1e: 'ReleaseDate',\n    0x23: 'ReleaseTime',\n    0x25: 'ExpirationDate',\n    0x26: 'ExpirationTime',\n    0x28: 'SpecialInstructions',\n    0x2a: 'ActionAdvised',\n    0x2d: 'RefService',\n    0x2f: 'RefDate',\n    0x32: 'RefNumber',\n    0x37: 'DateCreated',\n    0x3c: 'TimeCreated',\n    0x3e: 'DigitalCreationDate',\n    0x3f: 'DigitalCreationTime',\n    0x41: 'OriginatingProgram',\n    0x46: 'ProgramVersion',\n    0x4b: 'ObjectCycle',\n    0x50: 'Byline',\n    0x55: 'BylineTitle',\n    0x5a: 'City',\n    0x5c: 'Sublocation',\n    0x5f: 'State',\n    0x64: 'CountryCode',\n    0x65: 'CountryName',\n    0x67: 'OrigTransRef',\n    0x69: 'Headline',\n    0x6e: 'Credit',\n    0x73: 'Source',\n    0x74: 'CopyrightNotice',\n    0x76: 'Contact',\n    0x78: 'Caption',\n    0x7a: 'WriterEditor',\n    0x82: 'ImageType',\n    0x83: 'ImageOrientation',\n    0x87: 'LanguageID'\n\n    // We don't record these tags:\n    //\n    // 0x00: 'RecordVersion',\n    // 0x7d: 'RasterizedCaption',\n    // 0x96: 'AudioType',\n    // 0x97: 'AudioSamplingRate',\n    // 0x98: 'AudioSamplingRes',\n    // 0x99: 'AudioDuration',\n    // 0x9a: 'AudioOutcue',\n    // 0xc8: 'PreviewFileFormat',\n    // 0xc9: 'PreviewFileFormatVer',\n    // 0xca: 'PreviewData'\n  }\n\n  loadImage.IptcMap.prototype.getText = function(id) {\n    var value = this.get(id)\n    return String(value)\n  }\n  ;(function(iptcMapPrototype) {\n    var tags = iptcMapPrototype.tags\n    var map = iptcMapPrototype.map || {}\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = prop\n      }\n    }\n  })(loadImage.IptcMap.prototype)\n\n  loadImage.IptcMap.prototype.getAll = function() {\n    var map = {}\n    var prop\n    var id\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        id = this.tags[prop]\n        if (id) {\n          map[id] = this.getText(id)\n        }\n      }\n    }\n    return map\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanM/ZTkxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUQsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIElQVEMgTWFwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogQ29weXJpZ2h0IDIwMTgsIERhdmUgQmV2YW5cbiAqXG4gKiBJUFRDIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZWlkZWxpbi9leGlmLWpzXG4gKiBodHRwczovL2lwdGMub3JnL3N0YW5kYXJkcy9waG90by1tZXRhZGF0YVxuICogaHR0cDovL3d3dy5pcHRjLm9yZy9zdGQvSUlNLzQuMS9zcGVjaWZpY2F0aW9uL0lJTVY0LjEucGRmXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJywgJy4vbG9hZC1pbWFnZS1pcHRjJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpLCByZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0YycpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICBsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGUudGFncyA9IHtcbiAgICAvLyA9PT09PT09PT09XG4gICAgLy8gSVBUQyB0YWdzOlxuICAgIC8vID09PT09PT09PT1cbiAgICAweDAzOiAnT2JqZWN0VHlwZScsXG4gICAgMHgwNDogJ09iamVjdEF0dHJpYnV0ZScsXG4gICAgMHgwNTogJ09iamVjdE5hbWUnLFxuICAgIDB4MDc6ICdFZGl0U3RhdHVzJyxcbiAgICAweDA4OiAnRWRpdG9yaWFsVXBkYXRlJyxcbiAgICAweDBhOiAnVXJnZW5jeScsXG4gICAgMHgwYzogJ1N1YmplY3RSZWYnLFxuICAgIDB4MGY6ICdDYXRlZ29yeScsXG4gICAgMHgxNDogJ1N1cHBsQ2F0ZWdvcnknLFxuICAgIDB4MTY6ICdGaXh0dXJlSUQnLFxuICAgIDB4MTk6ICdLZXl3b3JkcycsXG4gICAgMHgxYTogJ0NvbnRlbnRMb2NDb2RlJyxcbiAgICAweDFiOiAnQ29udGVudExvY05hbWUnLFxuICAgIDB4MWU6ICdSZWxlYXNlRGF0ZScsXG4gICAgMHgyMzogJ1JlbGVhc2VUaW1lJyxcbiAgICAweDI1OiAnRXhwaXJhdGlvbkRhdGUnLFxuICAgIDB4MjY6ICdFeHBpcmF0aW9uVGltZScsXG4gICAgMHgyODogJ1NwZWNpYWxJbnN0cnVjdGlvbnMnLFxuICAgIDB4MmE6ICdBY3Rpb25BZHZpc2VkJyxcbiAgICAweDJkOiAnUmVmU2VydmljZScsXG4gICAgMHgyZjogJ1JlZkRhdGUnLFxuICAgIDB4MzI6ICdSZWZOdW1iZXInLFxuICAgIDB4Mzc6ICdEYXRlQ3JlYXRlZCcsXG4gICAgMHgzYzogJ1RpbWVDcmVhdGVkJyxcbiAgICAweDNlOiAnRGlnaXRhbENyZWF0aW9uRGF0ZScsXG4gICAgMHgzZjogJ0RpZ2l0YWxDcmVhdGlvblRpbWUnLFxuICAgIDB4NDE6ICdPcmlnaW5hdGluZ1Byb2dyYW0nLFxuICAgIDB4NDY6ICdQcm9ncmFtVmVyc2lvbicsXG4gICAgMHg0YjogJ09iamVjdEN5Y2xlJyxcbiAgICAweDUwOiAnQnlsaW5lJyxcbiAgICAweDU1OiAnQnlsaW5lVGl0bGUnLFxuICAgIDB4NWE6ICdDaXR5JyxcbiAgICAweDVjOiAnU3VibG9jYXRpb24nLFxuICAgIDB4NWY6ICdTdGF0ZScsXG4gICAgMHg2NDogJ0NvdW50cnlDb2RlJyxcbiAgICAweDY1OiAnQ291bnRyeU5hbWUnLFxuICAgIDB4Njc6ICdPcmlnVHJhbnNSZWYnLFxuICAgIDB4Njk6ICdIZWFkbGluZScsXG4gICAgMHg2ZTogJ0NyZWRpdCcsXG4gICAgMHg3MzogJ1NvdXJjZScsXG4gICAgMHg3NDogJ0NvcHlyaWdodE5vdGljZScsXG4gICAgMHg3NjogJ0NvbnRhY3QnLFxuICAgIDB4Nzg6ICdDYXB0aW9uJyxcbiAgICAweDdhOiAnV3JpdGVyRWRpdG9yJyxcbiAgICAweDgyOiAnSW1hZ2VUeXBlJyxcbiAgICAweDgzOiAnSW1hZ2VPcmllbnRhdGlvbicsXG4gICAgMHg4NzogJ0xhbmd1YWdlSUQnXG5cbiAgICAvLyBXZSBkb24ndCByZWNvcmQgdGhlc2UgdGFnczpcbiAgICAvL1xuICAgIC8vIDB4MDA6ICdSZWNvcmRWZXJzaW9uJyxcbiAgICAvLyAweDdkOiAnUmFzdGVyaXplZENhcHRpb24nLFxuICAgIC8vIDB4OTY6ICdBdWRpb1R5cGUnLFxuICAgIC8vIDB4OTc6ICdBdWRpb1NhbXBsaW5nUmF0ZScsXG4gICAgLy8gMHg5ODogJ0F1ZGlvU2FtcGxpbmdSZXMnLFxuICAgIC8vIDB4OTk6ICdBdWRpb0R1cmF0aW9uJyxcbiAgICAvLyAweDlhOiAnQXVkaW9PdXRjdWUnLFxuICAgIC8vIDB4Yzg6ICdQcmV2aWV3RmlsZUZvcm1hdCcsXG4gICAgLy8gMHhjOTogJ1ByZXZpZXdGaWxlRm9ybWF0VmVyJyxcbiAgICAvLyAweGNhOiAnUHJldmlld0RhdGEnXG4gIH1cblxuICBsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaWQpXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgfVxuICA7KGZ1bmN0aW9uKGlwdGNNYXBQcm90b3R5cGUpIHtcbiAgICB2YXIgdGFncyA9IGlwdGNNYXBQcm90b3R5cGUudGFnc1xuICAgIHZhciBtYXAgPSBpcHRjTWFwUHJvdG90eXBlLm1hcCB8fCB7fVxuICAgIHZhciBwcm9wXG4gICAgLy8gTWFwIHRoZSB0YWcgbmFtZXMgdG8gdGFnczpcbiAgICBmb3IgKHByb3AgaW4gdGFncykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWdzLCBwcm9wKSkge1xuICAgICAgICBtYXBbdGFnc1twcm9wXV0gPSBwcm9wXG4gICAgICB9XG4gICAgfVxuICB9KShsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGUpXG5cbiAgbG9hZEltYWdlLklwdGNNYXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXAgPSB7fVxuICAgIHZhciBwcm9wXG4gICAgdmFyIGlkXG4gICAgZm9yIChwcm9wIGluIHRoaXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcHJvcCkpIHtcbiAgICAgICAgaWQgPSB0aGlzLnRhZ3NbcHJvcF1cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgbWFwW2lkXSA9IHRoaXMuZ2V0VGV4dChpZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Buffer */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  loadImage.IptcMap = function() {\n    return this\n  }\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  }\n\n  loadImage.IptcMap.prototype.get = function(id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  loadImage.parseIptcTags = function(\n    dataView,\n    startOffset,\n    sectionLength,\n    data\n  ) {\n    /**\n     * Retrieves string for the given Buffer and range\n     *\n     * @param {Buffer} buffer IPTC buffer\n     * @param {number} start Range start\n     * @param {number} length Range length\n     * @returns {string} String value\n     */\n    function getStringFromDB(buffer, start, length) {\n      var outstr = ''\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n))\n      }\n      return outstr\n    }\n    var fieldValue, dataSize, segmentType\n    var segmentStartPos = startOffset\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (\n        dataView.getUint8(segmentStartPos) === 0x1c &&\n        dataView.getUint8(segmentStartPos + 1) === 0x02\n      ) {\n        segmentType = dataView.getUint8(segmentStartPos + 2)\n        // only store data for known tags\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3)\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize)\n          // Check if we already stored a value with this name\n          if (Object.prototype.hasOwnProperty.call(data.iptc, segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue)\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue]\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue\n          }\n        }\n      }\n      segmentStartPos++\n    }\n  }\n\n  loadImage.parseIptcData = function(dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    // Found '8BIM<EOT><EOT>' ?\n    var isFieldSegmentStart = function(dataView, offset) {\n      return (\n        dataView.getUint32(offset) === 0x3842494d &&\n        dataView.getUint16(offset + 4) === 0x0404\n      )\n    }\n    // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7)\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1\n        // Check for pre photoshop 6 format\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4\n        }\n        var startOffset = offset + 8 + nameHeaderLength\n        if (startOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength)\n        if (offset + sectionLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new loadImage.IptcMap()\n        // Parse the tags\n        return loadImage.parseIptcTags(\n          dataView,\n          startOffset,\n          sectionLength,\n          data\n        )\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset++\n    }\n    // eslint-disable-next-line no-console\n    console.log('No IPTC data at this offset - could be XMP')\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG meta data segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy5qcz85ZmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUQsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1pcHRjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBJUFRDIFBhcnNlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIENvcHlyaWdodCAyMDE4LCBEYXZlIEJldmFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIEJ1ZmZlciAqL1xuXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1tZXRhJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24obG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGxvYWRJbWFnZS5JcHRjTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxvYWRJbWFnZS5JcHRjTWFwLnByb3RvdHlwZS5tYXAgPSB7XG4gICAgT2JqZWN0TmFtZTogMHg1XG4gIH1cblxuICBsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpc1tpZF0gfHwgdGhpc1t0aGlzLm1hcFtpZF1dXG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VJcHRjVGFncyA9IGZ1bmN0aW9uKFxuICAgIGRhdGFWaWV3LFxuICAgIHN0YXJ0T2Zmc2V0LFxuICAgIHNlY3Rpb25MZW5ndGgsXG4gICAgZGF0YVxuICApIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gQnVmZmVyIGFuZCByYW5nZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBJUFRDIGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBSYW5nZSBzdGFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggUmFuZ2UgbGVuZ3RoXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbURCKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgICAgdmFyIG91dHN0ciA9ICcnXG4gICAgICBmb3IgKHZhciBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRzdHJcbiAgICB9XG4gICAgdmFyIGZpZWxkVmFsdWUsIGRhdGFTaXplLCBzZWdtZW50VHlwZVxuICAgIHZhciBzZWdtZW50U3RhcnRQb3MgPSBzdGFydE9mZnNldFxuICAgIHdoaWxlIChzZWdtZW50U3RhcnRQb3MgPCBzdGFydE9mZnNldCArIHNlY3Rpb25MZW5ndGgpIHtcbiAgICAgIC8vIHdlIGN1cnJlbnRseSBoYW5kbGUgdGhlIDI6IGNsYXNzIG9mIGlwdGMgdGFnXG4gICAgICBpZiAoXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQ4KHNlZ21lbnRTdGFydFBvcykgPT09IDB4MWMgJiZcbiAgICAgICAgZGF0YVZpZXcuZ2V0VWludDgoc2VnbWVudFN0YXJ0UG9zICsgMSkgPT09IDB4MDJcbiAgICAgICkge1xuICAgICAgICBzZWdtZW50VHlwZSA9IGRhdGFWaWV3LmdldFVpbnQ4KHNlZ21lbnRTdGFydFBvcyArIDIpXG4gICAgICAgIC8vIG9ubHkgc3RvcmUgZGF0YSBmb3Iga25vd24gdGFnc1xuICAgICAgICBpZiAoc2VnbWVudFR5cGUgaW4gZGF0YS5pcHRjLnRhZ3MpIHtcbiAgICAgICAgICBkYXRhU2l6ZSA9IGRhdGFWaWV3LmdldEludDE2KHNlZ21lbnRTdGFydFBvcyArIDMpXG4gICAgICAgICAgZmllbGRWYWx1ZSA9IGdldFN0cmluZ0Zyb21EQihkYXRhVmlldywgc2VnbWVudFN0YXJ0UG9zICsgNSwgZGF0YVNpemUpXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBzdG9yZWQgYSB2YWx1ZSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5pcHRjLCBzZWdtZW50VHlwZSkpIHtcbiAgICAgICAgICAgIC8vIFZhbHVlIGFscmVhZHkgc3RvcmVkIHdpdGggdGhpcyBuYW1lLCBjcmVhdGUgbXVsdGl2YWx1ZSBmaWVsZFxuICAgICAgICAgICAgaWYgKGRhdGEuaXB0Y1tzZWdtZW50VHlwZV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICBkYXRhLmlwdGNbc2VnbWVudFR5cGVdLnB1c2goZmllbGRWYWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEuaXB0Y1tzZWdtZW50VHlwZV0gPSBbZGF0YS5pcHRjW3NlZ21lbnRUeXBlXSwgZmllbGRWYWx1ZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5pcHRjW3NlZ21lbnRUeXBlXSA9IGZpZWxkVmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlZ21lbnRTdGFydFBvcysrXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlSXB0Y0RhdGEgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlSXB0Yykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBtYXJrZXJMZW5ndGggPSBvZmZzZXQgKyBsZW5ndGhcbiAgICAvLyBGb3VuZCAnOEJJTTxFT1Q+PEVPVD4nID9cbiAgICB2YXIgaXNGaWVsZFNlZ21lbnRTdGFydCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpID09PSAweDM4NDI0OTRkICYmXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA0KSA9PT0gMHgwNDA0XG4gICAgICApXG4gICAgfVxuICAgIC8vIEh1bnQgZm9yd2FyZCwgbG9va2luZyBmb3IgdGhlIGNvcnJlY3QgSVBUQyBibG9jayBzaWduYXR1cmU6XG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL21ldGFjcGFuLm9yZy9wb2QvZGlzdHJpYnV0aW9uL0ltYWdlLU1ldGFEYXRhLUpQRUcvbGliL0ltYWdlL01ldGFEYXRhL0pQRUcvU3RydWN0dXJlcy5wb2QjU3RydWN0dXJlLW9mLWEtUGhvdG9zaG9wLXN0eWxlLUFQUDEzLXNlZ21lbnRcbiAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanMvYmxvYi9tYXN0ZXIvZXhpZi5qcyB+IGxpbmUgNDc0IG9uXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBtYXJrZXJMZW5ndGgpIHtcbiAgICAgIGlmIChpc0ZpZWxkU2VnbWVudFN0YXJ0KGRhdGFWaWV3LCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBuYW1lSGVhZGVyTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgNylcbiAgICAgICAgaWYgKG5hbWVIZWFkZXJMZW5ndGggJSAyICE9PSAwKSBuYW1lSGVhZGVyTGVuZ3RoICs9IDFcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHByZSBwaG90b3Nob3AgNiBmb3JtYXRcbiAgICAgICAgaWYgKG5hbWVIZWFkZXJMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBBbHdheXMgNFxuICAgICAgICAgIG5hbWVIZWFkZXJMZW5ndGggPSA0XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0ICsgOCArIG5hbWVIZWFkZXJMZW5ndGhcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID4gbWFya2VyTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBJUFRDIGRhdGE6IEludmFsaWQgc2VnbWVudCBvZmZzZXQuJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDYgKyBuYW1lSGVhZGVyTGVuZ3RoKVxuICAgICAgICBpZiAob2Zmc2V0ICsgc2VjdGlvbkxlbmd0aCA+IG1hcmtlckxlbmd0aCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSVBUQyBkYXRhOiBJbnZhbGlkIHNlZ21lbnQgc2l6ZS4nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpcHRjIG9iamVjdCB0byBzdG9yZSB0aGUgdGFnczpcbiAgICAgICAgZGF0YS5pcHRjID0gbmV3IGxvYWRJbWFnZS5JcHRjTWFwKClcbiAgICAgICAgLy8gUGFyc2UgdGhlIHRhZ3NcbiAgICAgICAgcmV0dXJuIGxvYWRJbWFnZS5wYXJzZUlwdGNUYWdzKFxuICAgICAgICAgIGRhdGFWaWV3LFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgIHNlY3Rpb25MZW5ndGgsXG4gICAgICAgICAgZGF0YVxuICAgICAgICApXG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG9mZnNldCsrXG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coJ05vIElQVEMgZGF0YSBhdCB0aGlzIG9mZnNldCAtIGNvdWxkIGJlIFhNUCcpXG4gIH1cblxuICAvLyBSZWdpc3RlcnMgdGhpcyBJUFRDIHBhcnNlciBmb3IgdGhlIEFQUDEzIEpQRUcgbWV0YSBkYXRhIHNlZ21lbnQ6XG4gIGxvYWRJbWFnZS5tZXRhRGF0YVBhcnNlcnMuanBlZ1sweGZmZWRdLnB1c2gobG9hZEltYWdlLnBhcnNlSXB0Y0RhdGEpXG5cbiAgLy8gQWRkcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgdG8gdGhlIHBhcnNlTWV0YURhdGEgY2FsbGJhY2sgZGF0YTpcbiAgLy8gKiBpcHRjOiBUaGUgaXB0YyB0YWdzLCBwYXJzZWQgYnkgdGhlIHBhcnNlSXB0Y0RhdGEgbWV0aG9kXG5cbiAgLy8gQWRkcyB0aGUgZm9sbG93aW5nIG9wdGlvbnMgdG8gdGhlIHBhcnNlTWV0YURhdGEgbWV0aG9kOlxuICAvLyAqIGRpc2FibGVJcHRjOiBEaXNhYmxlcyBJUFRDIHBhcnNpbmcuXG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-meta.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim Sthr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  var hasblobSlice =\n    typeof Blob !== 'undefined' &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  loadImage.blobSlice =\n    hasblobSlice &&\n    function() {\n      var slice = this.slice || this.webkitSlice || this.mozSlice\n      return slice.apply(this, arguments)\n    }\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function(file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var that = this\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\n    var noMetaData = !(\n      typeof DataView !== 'undefined' &&\n      file &&\n      file.size >= 12 &&\n      file.type === 'image/jpeg' &&\n      loadImage.blobSlice\n    )\n    if (\n      noMetaData ||\n      !loadImage.readFile(\n        loadImage.blobSlice.call(file, 0, maxMetaDataSize),\n        function(e) {\n          if (e.target.error) {\n            // FileReader error\n            // eslint-disable-next-line no-console\n            console.log(e.target.error)\n            callback(data)\n            return\n          }\n          // Note on endianness:\n          // Since the marker and length bytes in JPEG files are always\n          // stored in big endian order, we can leave the endian parameter\n          // of the DataView methods undefined, defaulting to big endian.\n          var buffer = e.target.result\n          var dataView = new DataView(buffer)\n          var offset = 2\n          var maxOffset = dataView.byteLength - 4\n          var headLength = offset\n          var markerBytes\n          var markerLength\n          var parsers\n          var i\n          // Check for the JPEG marker (0xffd8):\n          if (dataView.getUint16(0) === 0xffd8) {\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific meta-data like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid meta data: Invalid segment size.')\n                  break\n                }\n                parsers = loadImage.metaDataParsers.jpeg[markerBytes]\n                if (parsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the meta data\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              if (buffer.slice) {\n                data.imageHead = buffer.slice(0, headLength)\n              } else {\n                // Workaround for IE10, which does not yet\n                // support ArrayBuffer.slice:\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\n              }\n            }\n          } else {\n            // eslint-disable-next-line no-console\n            console.log('Invalid JPEG file: Missing JPEG marker.')\n          }\n          callback(data)\n        },\n        'readAsArrayBuffer'\n      )\n    ) {\n      callback(data)\n    }\n  }\n\n  // Determines if meta data should be loaded automatically:\n  loadImage.hasMetaOption = function(options) {\n    return options && options.meta\n  }\n\n  var originalTransform = loadImage.transform\n  loadImage.transform = function(img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(\n        file,\n        function(data) {\n          originalTransform.call(loadImage, img, options, callback, file, data)\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcz8wNzhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDckMsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgTWV0YVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBJbWFnZSBtZXRhIGRhdGEgaGFuZGxpbmcgaW1wbGVtZW50YXRpb25cbiAqIGJhc2VkIG9uIHRoZSBoZWxwIGFuZCBjb250cmlidXRpb24gb2ZcbiAqIEFjaGltIFN0w7Zoci5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSwgRGF0YVZpZXcsIFVpbnQ4QXJyYXkgKi9cblxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgaGFzYmxvYlNsaWNlID1cbiAgICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoQmxvYi5wcm90b3R5cGUuc2xpY2UgfHxcbiAgICAgIEJsb2IucHJvdG90eXBlLndlYmtpdFNsaWNlIHx8XG4gICAgICBCbG9iLnByb3RvdHlwZS5tb3pTbGljZSlcblxuICBsb2FkSW1hZ2UuYmxvYlNsaWNlID1cbiAgICBoYXNibG9iU2xpY2UgJiZcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2UgfHwgdGhpcy53ZWJraXRTbGljZSB8fCB0aGlzLm1velNsaWNlXG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH1cblxuICBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzID0ge1xuICAgIGpwZWc6IHtcbiAgICAgIDB4ZmZlMTogW10sIC8vIEFQUDEgbWFya2VyXG4gICAgICAweGZmZWQ6IFtdIC8vIEFQUDEzIG1hcmtlclxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlcyBpbWFnZSBtZXRhIGRhdGEgYW5kIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIGFuIG9iamVjdCBhcmd1bWVudFxuICAvLyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgLy8gKiBpbWFnZUhlYWQ6IFRoZSBjb21wbGV0ZSBpbWFnZSBoZWFkIGFzIEFycmF5QnVmZmVyIChVaW50OEFycmF5IGZvciBJRTEwKVxuICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBhY2NlcHRzIGFuIG9iamVjdCBhbmQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZ1xuICAvLyBwcm9wZXJ0aWVzOlxuICAvLyAqIG1heE1ldGFEYXRhU2l6ZTogRGVmaW5lcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2UuXG4gIC8vICogZGlzYWJsZUltYWdlSGVhZDogRGlzYWJsZXMgY3JlYXRpbmcgdGhlIGltYWdlSGVhZCBwcm9wZXJ0eS5cbiAgbG9hZEltYWdlLnBhcnNlTWV0YURhdGEgPSBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaywgb3B0aW9ucywgZGF0YSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgZGF0YSA9IGRhdGEgfHwge31cbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAvLyAyNTYgS2lCIHNob3VsZCBjb250YWluIGFsbCBFWElGL0lDQy9JUFRDIHNlZ21lbnRzOlxuICAgIHZhciBtYXhNZXRhRGF0YVNpemUgPSBvcHRpb25zLm1heE1ldGFEYXRhU2l6ZSB8fCAyNjIxNDRcbiAgICB2YXIgbm9NZXRhRGF0YSA9ICEoXG4gICAgICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBmaWxlICYmXG4gICAgICBmaWxlLnNpemUgPj0gMTIgJiZcbiAgICAgIGZpbGUudHlwZSA9PT0gJ2ltYWdlL2pwZWcnICYmXG4gICAgICBsb2FkSW1hZ2UuYmxvYlNsaWNlXG4gICAgKVxuICAgIGlmIChcbiAgICAgIG5vTWV0YURhdGEgfHxcbiAgICAgICFsb2FkSW1hZ2UucmVhZEZpbGUoXG4gICAgICAgIGxvYWRJbWFnZS5ibG9iU2xpY2UuY2FsbChmaWxlLCAwLCBtYXhNZXRhRGF0YVNpemUpLFxuICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmVycm9yKSB7XG4gICAgICAgICAgICAvLyBGaWxlUmVhZGVyIGVycm9yXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZS50YXJnZXQuZXJyb3IpXG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGUgb24gZW5kaWFubmVzczpcbiAgICAgICAgICAvLyBTaW5jZSB0aGUgbWFya2VyIGFuZCBsZW5ndGggYnl0ZXMgaW4gSlBFRyBmaWxlcyBhcmUgYWx3YXlzXG4gICAgICAgICAgLy8gc3RvcmVkIGluIGJpZyBlbmRpYW4gb3JkZXIsIHdlIGNhbiBsZWF2ZSB0aGUgZW5kaWFuIHBhcmFtZXRlclxuICAgICAgICAgIC8vIG9mIHRoZSBEYXRhVmlldyBtZXRob2RzIHVuZGVmaW5lZCwgZGVmYXVsdGluZyB0byBiaWcgZW5kaWFuLlxuICAgICAgICAgIHZhciBidWZmZXIgPSBlLnRhcmdldC5yZXN1bHRcbiAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICAgIHZhciBvZmZzZXQgPSAyXG4gICAgICAgICAgdmFyIG1heE9mZnNldCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGggLSA0XG4gICAgICAgICAgdmFyIGhlYWRMZW5ndGggPSBvZmZzZXRcbiAgICAgICAgICB2YXIgbWFya2VyQnl0ZXNcbiAgICAgICAgICB2YXIgbWFya2VyTGVuZ3RoXG4gICAgICAgICAgdmFyIHBhcnNlcnNcbiAgICAgICAgICB2YXIgaVxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgSlBFRyBtYXJrZXIgKDB4ZmZkOCk6XG4gICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSA9PT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG1hcmtlckJ5dGVzID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldClcbiAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBBUFBuICgweGZmZU4pIGFuZCBDT00gKDB4ZmZmZSkgbWFya2VycyxcbiAgICAgICAgICAgICAgLy8gd2hpY2ggY29udGFpbiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhLWRhdGEgbGlrZVxuICAgICAgICAgICAgICAvLyBFeGlmLCBJQ0MgYW5kIElQVEMgZGF0YSBhbmQgdGV4dCBjb21tZW50czpcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChtYXJrZXJCeXRlcyA+PSAweGZmZTAgJiYgbWFya2VyQnl0ZXMgPD0gMHhmZmVmKSB8fFxuICAgICAgICAgICAgICAgIG1hcmtlckJ5dGVzID09PSAweGZmZmVcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1hcmtlciBieXRlcyAoMikgYXJlIGFsd2F5cyBmb2xsb3dlZCBieVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggYnl0ZXMgKDIpLCBpbmRpY2F0aW5nIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbWFya2VyIHNlZ21lbnQsIHdoaWNoIGluY2x1ZGVzIHRoZSBsZW5ndGggYnl0ZXMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5vdCB0aGUgbWFya2VyIGJ5dGVzLCBzbyB3ZSBhZGQgMjpcbiAgICAgICAgICAgICAgICBtYXJrZXJMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMikgKyAyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIG1hcmtlckxlbmd0aCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBtZXRhIGRhdGE6IEludmFsaWQgc2VnbWVudCBzaXplLicpXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXJzID0gbG9hZEltYWdlLm1ldGFEYXRhUGFyc2Vycy5qcGVnW21hcmtlckJ5dGVzXVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJzKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJzW2ldLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya2VyTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBtYXJrZXJMZW5ndGhcbiAgICAgICAgICAgICAgICBoZWFkTGVuZ3RoID0gb2Zmc2V0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGFuIEFQUG4gb3IgQ09NIG1hcmtlciwgcHJvYmFibHkgc2FmZSB0b1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgbWV0YSBkYXRhXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWV0YSBsZW5ndGggbXVzdCBiZSBsb25nZXIgdGhhbiBKUEVHIG1hcmtlciAoMilcbiAgICAgICAgICAgIC8vIHBsdXMgQVBQbiBtYXJrZXIgKDIpLCBmb2xsb3dlZCBieSBsZW5ndGggYnl0ZXMgKDIpOlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRpc2FibGVJbWFnZUhlYWQgJiYgaGVhZExlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5zbGljZSkge1xuICAgICAgICAgICAgICAgIGRhdGEuaW1hZ2VIZWFkID0gYnVmZmVyLnNsaWNlKDAsIGhlYWRMZW5ndGgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgSUUxMCwgd2hpY2ggZG9lcyBub3QgeWV0XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBBcnJheUJ1ZmZlci5zbGljZTpcbiAgICAgICAgICAgICAgICBkYXRhLmltYWdlSGVhZCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc3ViYXJyYXkoMCwgaGVhZExlbmd0aClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSlBFRyBmaWxlOiBNaXNzaW5nIEpQRUcgbWFya2VyLicpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgICdyZWFkQXNBcnJheUJ1ZmZlcidcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrKGRhdGEpXG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiBtZXRhIGRhdGEgc2hvdWxkIGJlIGxvYWRlZCBhdXRvbWF0aWNhbGx5OlxuICBsb2FkSW1hZ2UuaGFzTWV0YU9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLm1ldGFcbiAgfVxuXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybSA9IGxvYWRJbWFnZS50cmFuc2Zvcm1cbiAgbG9hZEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBpZiAobG9hZEltYWdlLmhhc01ldGFPcHRpb24ob3B0aW9ucykpIHtcbiAgICAgIGxvYWRJbWFnZS5wYXJzZU1ldGFEYXRhKFxuICAgICAgICBmaWxlLFxuICAgICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uY2FsbChsb2FkSW1hZ2UsIGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGFcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uYXBwbHkobG9hZEltYWdlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-meta.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-orientation.js":
/*!**********************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-orientation.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  var originalHasCanvasOption = loadImage.hasCanvasOption\n  var originalHasMetaOption = loadImage.hasMetaOption\n  var originalTransformCoordinates = loadImage.transformCoordinates\n  var originalGetTransformedOptions = loadImage.getTransformedOptions\n\n  // Determines if the target image should be a canvas element:\n  loadImage.hasCanvasOption = function(options) {\n    return (\n      !!options.orientation || originalHasCanvasOption.call(loadImage, options)\n    )\n  }\n\n  // Determines if meta data should be loaded automatically:\n  loadImage.hasMetaOption = function(options) {\n    return (\n      (options && options.orientation === true) ||\n      originalHasMetaOption.call(loadImage, options)\n    )\n  }\n\n  // Transform image orientation based on\n  // the given EXIF orientation option:\n  loadImage.transformCoordinates = function(canvas, options) {\n    originalTransformCoordinates.call(loadImage, canvas, options)\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var styleWidth = canvas.style.width\n    var styleHeight = canvas.style.height\n    var orientation = options.orientation\n    if (!orientation || orientation > 8) {\n      return\n    }\n    if (orientation > 4) {\n      canvas.width = height\n      canvas.height = width\n      canvas.style.width = styleHeight\n      canvas.style.height = styleWidth\n    }\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        ctx.translate(width, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180 rotate left\n        ctx.translate(width, height)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // vertical flip\n        ctx.translate(0, height)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // vertical flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.scale(1, -1)\n        break\n      case 6:\n        // 90 rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -height)\n        break\n      case 7:\n        // horizontal flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(width, -height)\n        ctx.scale(-1, 1)\n        break\n      case 8:\n        // 90 rotate left\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-width, 0)\n        break\n    }\n  }\n\n  // Transforms coordinate and dimension options\n  // based on the given orientation option:\n  loadImage.getTransformedOptions = function(img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var orientation = options.orientation\n    var newOptions\n    var i\n    if (orientation === true && data && data.exif) {\n      orientation = data.exif.get('Orientation')\n    }\n    if (!orientation || orientation > 8 || orientation === 1) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.orientation = orientation\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        newOptions.left = options.right\n        newOptions.right = options.left\n        break\n      case 3:\n        // 180 rotate left\n        newOptions.left = options.right\n        newOptions.top = options.bottom\n        newOptions.right = options.left\n        newOptions.bottom = options.top\n        break\n      case 4:\n        // vertical flip\n        newOptions.top = options.bottom\n        newOptions.bottom = options.top\n        break\n      case 5:\n        // vertical flip + 90 rotate right\n        newOptions.left = options.top\n        newOptions.top = options.left\n        newOptions.right = options.bottom\n        newOptions.bottom = options.right\n        break\n      case 6:\n        // 90 rotate right\n        newOptions.left = options.top\n        newOptions.top = options.right\n        newOptions.right = options.bottom\n        newOptions.bottom = options.left\n        break\n      case 7:\n        // horizontal flip + 90 rotate right\n        newOptions.left = options.bottom\n        newOptions.top = options.right\n        newOptions.right = options.top\n        newOptions.bottom = options.left\n        break\n      case 8:\n        // 90 rotate left\n        newOptions.left = options.bottom\n        newOptions.top = options.left\n        newOptions.right = options.top\n        newOptions.bottom = options.right\n        break\n    }\n    if (newOptions.orientation > 4) {\n      newOptions.maxWidth = options.maxHeight\n      newOptions.maxHeight = options.maxWidth\n      newOptions.minWidth = options.minHeight\n      newOptions.minHeight = options.minWidth\n      newOptions.sourceWidth = options.sourceHeight\n      newOptions.sourceHeight = options.sourceWidth\n    }\n    return newOptions\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanM/NzliYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUseUdBQW9CLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNoRixHQUFHLE1BQU0sRUFTTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIE9yaWVudGF0aW9uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG5cbjsoZnVuY3Rpb24oZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2Utc2NhbGUnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSxcbiAgICAgIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1zY2FsZScpLFxuICAgICAgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbihsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIG9yaWdpbmFsSGFzQ2FudmFzT3B0aW9uID0gbG9hZEltYWdlLmhhc0NhbnZhc09wdGlvblxuICB2YXIgb3JpZ2luYWxIYXNNZXRhT3B0aW9uID0gbG9hZEltYWdlLmhhc01ldGFPcHRpb25cbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXNcbiAgdmFyIG9yaWdpbmFsR2V0VHJhbnNmb3JtZWRPcHRpb25zID0gbG9hZEltYWdlLmdldFRyYW5zZm9ybWVkT3B0aW9uc1xuXG4gIC8vIERldGVybWluZXMgaWYgdGhlIHRhcmdldCBpbWFnZSBzaG91bGQgYmUgYSBjYW52YXMgZWxlbWVudDpcbiAgbG9hZEltYWdlLmhhc0NhbnZhc09wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgISFvcHRpb25zLm9yaWVudGF0aW9uIHx8IG9yaWdpbmFsSGFzQ2FudmFzT3B0aW9uLmNhbGwobG9hZEltYWdlLCBvcHRpb25zKVxuICAgIClcbiAgfVxuXG4gIC8vIERldGVybWluZXMgaWYgbWV0YSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgYXV0b21hdGljYWxseTpcbiAgbG9hZEltYWdlLmhhc01ldGFPcHRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChvcHRpb25zICYmIG9wdGlvbnMub3JpZW50YXRpb24gPT09IHRydWUpIHx8XG4gICAgICBvcmlnaW5hbEhhc01ldGFPcHRpb24uY2FsbChsb2FkSW1hZ2UsIG9wdGlvbnMpXG4gICAgKVxuICB9XG5cbiAgLy8gVHJhbnNmb3JtIGltYWdlIG9yaWVudGF0aW9uIGJhc2VkIG9uXG4gIC8vIHRoZSBnaXZlbiBFWElGIG9yaWVudGF0aW9uIG9wdGlvbjpcbiAgbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24oY2FudmFzLCBvcHRpb25zKSB7XG4gICAgb3JpZ2luYWxUcmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKGxvYWRJbWFnZSwgY2FudmFzLCBvcHRpb25zKVxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0XG4gICAgdmFyIHN0eWxlV2lkdGggPSBjYW52YXMuc3R5bGUud2lkdGhcbiAgICB2YXIgc3R5bGVIZWlnaHQgPSBjYW52YXMuc3R5bGUuaGVpZ2h0XG4gICAgdmFyIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvblxuICAgIGlmICghb3JpZW50YXRpb24gfHwgb3JpZW50YXRpb24gPiA4KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID4gNCkge1xuICAgICAgY2FudmFzLndpZHRoID0gaGVpZ2h0XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGhcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHN0eWxlSGVpZ2h0XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gc3R5bGVXaWR0aFxuICAgIH1cbiAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIGhvcml6b250YWwgZmxpcFxuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKVxuICAgICAgICBjdHguc2NhbGUoLTEsIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIDE4MMKwIHJvdGF0ZSBsZWZ0XG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIGhlaWdodClcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0OlxuICAgICAgICAvLyB2ZXJ0aWNhbCBmbGlwXG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0KVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIDkwwrAgcm90YXRlIHJpZ2h0XG4gICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBob3Jpem9udGFsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAtaGVpZ2h0KVxuICAgICAgICBjdHguc2NhbGUoLTEsIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8vIDkwwrAgcm90YXRlIGxlZnRcbiAgICAgICAgY3R4LnJvdGF0ZSgtMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtd2lkdGgsIDApXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gVHJhbnNmb3JtcyBjb29yZGluYXRlIGFuZCBkaW1lbnNpb24gb3B0aW9uc1xuICAvLyBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3JpZW50YXRpb24gb3B0aW9uOlxuICBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zID0gZnVuY3Rpb24oaW1nLCBvcHRzLCBkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcmlnaW5hbEdldFRyYW5zZm9ybWVkT3B0aW9ucy5jYWxsKGxvYWRJbWFnZSwgaW1nLCBvcHRzKVxuICAgIHZhciBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICB2YXIgbmV3T3B0aW9uc1xuICAgIHZhciBpXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSB0cnVlICYmIGRhdGEgJiYgZGF0YS5leGlmKSB7XG4gICAgICBvcmllbnRhdGlvbiA9IGRhdGEuZXhpZi5nZXQoJ09yaWVudGF0aW9uJylcbiAgICB9XG4gICAgaWYgKCFvcmllbnRhdGlvbiB8fCBvcmllbnRhdGlvbiA+IDggfHwgb3JpZW50YXRpb24gPT09IDEpIHtcbiAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuICAgIG5ld09wdGlvbnMgPSB7fVxuICAgIGZvciAoaSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgIG5ld09wdGlvbnNbaV0gPSBvcHRpb25zW2ldXG4gICAgICB9XG4gICAgfVxuICAgIG5ld09wdGlvbnMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwXG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMubGVmdFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyAxODDCsCByb3RhdGUgbGVmdFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMubGVmdFxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IG9wdGlvbnMudG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXBcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IG9wdGlvbnMudG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy50b3BcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA2OlxuICAgICAgICAvLyA5MMKwIHJvdGF0ZSByaWdodFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLnRvcFxuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIGhvcml6b250YWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMudG9wXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8vIDkwwrAgcm90YXRlIGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMudG9wXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobmV3T3B0aW9ucy5vcmllbnRhdGlvbiA+IDQpIHtcbiAgICAgIG5ld09wdGlvbnMubWF4V2lkdGggPSBvcHRpb25zLm1heEhlaWdodFxuICAgICAgbmV3T3B0aW9ucy5tYXhIZWlnaHQgPSBvcHRpb25zLm1heFdpZHRoXG4gICAgICBuZXdPcHRpb25zLm1pbldpZHRoID0gb3B0aW9ucy5taW5IZWlnaHRcbiAgICAgIG5ld09wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5taW5XaWR0aFxuICAgICAgbmV3T3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0XG4gICAgICBuZXdPcHRpb25zLnNvdXJjZUhlaWdodCA9IG9wdGlvbnMuc291cmNlV2lkdGhcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnNcbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-orientation.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-scale.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-scale.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function(factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function(loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n\n  loadImage.transform = function(img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      loadImage.scale(img, options, data),\n      options,\n      callback,\n      file,\n      data\n    )\n  }\n\n  // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options passed as arguments:\n  loadImage.transformCoordinates = function() {}\n\n  // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options passed as arguments:\n  loadImage.getTransformedOptions = function(img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio\n      newOptions.maxHeight = height\n    } else {\n      newOptions.maxWidth = width\n      newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n  }\n\n  // Canvas render method, allows to implement a different rendering algorithm:\n  loadImage.renderImageToCanvas = function(\n    canvas,\n    img,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destX,\n    destY,\n    destWidth,\n    destHeight\n  ) {\n    canvas\n      .getContext('2d')\n      .drawImage(\n        img,\n        sourceX,\n        sourceY,\n        sourceWidth,\n        sourceHeight,\n        destX,\n        destY,\n        destWidth,\n        destHeight\n      )\n    return canvas\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.hasCanvasOption = function(options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n  }\n\n  // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options.\n  // Returns a canvas object if the browser supports canvas\n  // and the hasCanvasOption method returns true or a canvas\n  // object is passed as image, else the scaled image:\n  loadImage.scale = function(img, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    var canvas = document.createElement('canvas')\n    var useCanvas =\n      img.getContext ||\n      (loadImage.hasCanvasOption(options) && canvas.getContext)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    /**\n     * Scales up image dimensions\n     */\n    function scaleUp() {\n      var scale = Math.max(\n        (minWidth || destWidth) / destWidth,\n        (minHeight || destHeight) / destHeight\n      )\n      if (scale > 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    /**\n     * Scales down image dimensions\n     */\n    function scaleDown() {\n      var scale = Math.min(\n        (maxWidth || destWidth) / destWidth,\n        (maxHeight || destHeight) / destHeight\n      )\n      if (scale < 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    if (useCanvas) {\n      // eslint-disable-next-line no-param-reassign\n      options = loadImage.getTransformedOptions(img, options, data)\n      sourceX = options.left || 0\n      sourceY = options.top || 0\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0)\n      }\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0)\n      }\n      destWidth = sourceWidth\n      destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth\n      destHeight = maxHeight\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n      if (tmp < 0) {\n        sourceHeight = (maxHeight * sourceWidth) / maxWidth\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2\n        }\n      } else if (tmp > 0) {\n        sourceWidth = (maxWidth * sourceHeight) / maxHeight\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth\n        minHeight = maxHeight = maxHeight || minHeight\n      }\n      if (options.cover) {\n        scaleDown()\n        scaleUp()\n      } else {\n        scaleUp()\n        scaleDown()\n      }\n    }\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio\n      if (pixelRatio > 1) {\n        canvas.style.width = destWidth + 'px'\n        canvas.style.height = destHeight + 'px'\n        destWidth *= pixelRatio\n        destHeight *= pixelRatio\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio)\n      }\n      downsamplingRatio = options.downsamplingRatio\n      if (\n        downsamplingRatio > 0 &&\n        downsamplingRatio < 1 &&\n        destWidth < sourceWidth &&\n        destHeight < sourceHeight\n      ) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas.width = sourceWidth * downsamplingRatio\n          canvas.height = sourceHeight * downsamplingRatio\n          loadImage.renderImageToCanvas(\n            canvas,\n            img,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            0,\n            0,\n            canvas.width,\n            canvas.height\n          )\n          sourceX = 0\n          sourceY = 0\n          sourceWidth = canvas.width\n          sourceHeight = canvas.height\n          // eslint-disable-next-line no-param-reassign\n          img = document.createElement('canvas')\n          img.width = sourceWidth\n          img.height = sourceHeight\n          loadImage.renderImageToCanvas(\n            img,\n            canvas,\n            0,\n            0,\n            sourceWidth,\n            sourceHeight,\n            0,\n            0,\n            sourceWidth,\n            sourceHeight\n          )\n        }\n      }\n      canvas.width = destWidth\n      canvas.height = destHeight\n      loadImage.transformCoordinates(canvas, options)\n      return loadImage.renderImageToCanvas(\n        canvas,\n        img,\n        sourceX,\n        sourceY,\n        sourceWidth,\n        sourceHeight,\n        0,\n        0,\n        destWidth,\n        destHeight\n      )\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanM/YTcyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNyQyxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIFNjYWxpbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgb3JpZ2luYWxUcmFuc2Zvcm0gPSBsb2FkSW1hZ2UudHJhbnNmb3JtXG5cbiAgbG9hZEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBvcmlnaW5hbFRyYW5zZm9ybS5jYWxsKFxuICAgICAgbG9hZEltYWdlLFxuICAgICAgbG9hZEltYWdlLnNjYWxlKGltZywgb3B0aW9ucywgZGF0YSksXG4gICAgICBvcHRpb25zLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBmaWxlLFxuICAgICAgZGF0YVxuICAgIClcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBpbWFnZSBjb29yZGluYXRlcywgYWxsb3dzIHRvIG92ZXJyaWRlIGUuZy5cbiAgLy8gdGhlIGNhbnZhcyBvcmllbnRhdGlvbiBiYXNlZCBvbiB0aGUgb3JpZW50YXRpb24gb3B0aW9uLFxuICAvLyBnZXRzIGNhbnZhcywgb3B0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzOlxuICBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbigpIHt9XG5cbiAgLy8gUmV0dXJucyB0cmFuc2Zvcm1lZCBvcHRpb25zLCBhbGxvd3MgdG8gb3ZlcnJpZGUgZS5nLlxuICAvLyBtYXhXaWR0aCwgbWF4SGVpZ2h0IGFuZCBjcm9wIG9wdGlvbnMgYmFzZWQgb24gdGhlIGFzcGVjdFJhdGlvLlxuICAvLyBnZXRzIGltZywgb3B0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzOlxuICBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zID0gZnVuY3Rpb24oaW1nLCBvcHRpb25zKSB7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgIHZhciBuZXdPcHRpb25zXG4gICAgdmFyIGlcbiAgICB2YXIgd2lkdGhcbiAgICB2YXIgaGVpZ2h0XG4gICAgaWYgKCFhc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICB9XG4gICAgbmV3T3B0aW9ucyA9IHt9XG4gICAgZm9yIChpIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcbiAgICAgICAgbmV3T3B0aW9uc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV3T3B0aW9ucy5jcm9wID0gdHJ1ZVxuICAgIHdpZHRoID0gaW1nLm5hdHVyYWxXaWR0aCB8fCBpbWcud2lkdGhcbiAgICBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodCB8fCBpbWcuaGVpZ2h0XG4gICAgaWYgKHdpZHRoIC8gaGVpZ2h0ID4gYXNwZWN0UmF0aW8pIHtcbiAgICAgIG5ld09wdGlvbnMubWF4V2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpb1xuICAgICAgbmV3T3B0aW9ucy5tYXhIZWlnaHQgPSBoZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3T3B0aW9ucy5tYXhXaWR0aCA9IHdpZHRoXG4gICAgICBuZXdPcHRpb25zLm1heEhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW9cbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnNcbiAgfVxuXG4gIC8vIENhbnZhcyByZW5kZXIgbWV0aG9kLCBhbGxvd3MgdG8gaW1wbGVtZW50IGEgZGlmZmVyZW50IHJlbmRlcmluZyBhbGdvcml0aG06XG4gIGxvYWRJbWFnZS5yZW5kZXJJbWFnZVRvQ2FudmFzID0gZnVuY3Rpb24oXG4gICAgY2FudmFzLFxuICAgIGltZyxcbiAgICBzb3VyY2VYLFxuICAgIHNvdXJjZVksXG4gICAgc291cmNlV2lkdGgsXG4gICAgc291cmNlSGVpZ2h0LFxuICAgIGRlc3RYLFxuICAgIGRlc3RZLFxuICAgIGRlc3RXaWR0aCxcbiAgICBkZXN0SGVpZ2h0XG4gICkge1xuICAgIGNhbnZhc1xuICAgICAgLmdldENvbnRleHQoJzJkJylcbiAgICAgIC5kcmF3SW1hZ2UoXG4gICAgICAgIGltZyxcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgICAgZGVzdFgsXG4gICAgICAgIGRlc3RZLFxuICAgICAgICBkZXN0V2lkdGgsXG4gICAgICAgIGRlc3RIZWlnaHRcbiAgICAgIClcbiAgICByZXR1cm4gY2FudmFzXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB0YXJnZXQgaW1hZ2Ugc2hvdWxkIGJlIGEgY2FudmFzIGVsZW1lbnQ6XG4gIGxvYWRJbWFnZS5oYXNDYW52YXNPcHRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuY2FudmFzIHx8IG9wdGlvbnMuY3JvcCB8fCAhIW9wdGlvbnMuYXNwZWN0UmF0aW9cbiAgfVxuXG4gIC8vIFNjYWxlcyBhbmQvb3IgY3JvcHMgdGhlIGdpdmVuIGltYWdlIChpbWcgb3IgY2FudmFzIEhUTUwgZWxlbWVudClcbiAgLy8gdXNpbmcgdGhlIGdpdmVuIG9wdGlvbnMuXG4gIC8vIFJldHVybnMgYSBjYW52YXMgb2JqZWN0IGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGNhbnZhc1xuICAvLyBhbmQgdGhlIGhhc0NhbnZhc09wdGlvbiBtZXRob2QgcmV0dXJucyB0cnVlIG9yIGEgY2FudmFzXG4gIC8vIG9iamVjdCBpcyBwYXNzZWQgYXMgaW1hZ2UsIGVsc2UgdGhlIHNjYWxlZCBpbWFnZTpcbiAgbG9hZEltYWdlLnNjYWxlID0gZnVuY3Rpb24oaW1nLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICB2YXIgdXNlQ2FudmFzID1cbiAgICAgIGltZy5nZXRDb250ZXh0IHx8XG4gICAgICAobG9hZEltYWdlLmhhc0NhbnZhc09wdGlvbihvcHRpb25zKSAmJiBjYW52YXMuZ2V0Q29udGV4dClcbiAgICB2YXIgd2lkdGggPSBpbWcubmF0dXJhbFdpZHRoIHx8IGltZy53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodCB8fCBpbWcuaGVpZ2h0XG4gICAgdmFyIGRlc3RXaWR0aCA9IHdpZHRoXG4gICAgdmFyIGRlc3RIZWlnaHQgPSBoZWlnaHRcbiAgICB2YXIgbWF4V2lkdGhcbiAgICB2YXIgbWF4SGVpZ2h0XG4gICAgdmFyIG1pbldpZHRoXG4gICAgdmFyIG1pbkhlaWdodFxuICAgIHZhciBzb3VyY2VXaWR0aFxuICAgIHZhciBzb3VyY2VIZWlnaHRcbiAgICB2YXIgc291cmNlWFxuICAgIHZhciBzb3VyY2VZXG4gICAgdmFyIHBpeGVsUmF0aW9cbiAgICB2YXIgZG93bnNhbXBsaW5nUmF0aW9cbiAgICB2YXIgdG1wXG4gICAgLyoqXG4gICAgICogU2NhbGVzIHVwIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsZVVwKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoXG4gICAgICAgIChtaW5XaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWluSGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlID4gMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgZG93biBpbWFnZSBkaW1lbnNpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGVEb3duKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4oXG4gICAgICAgIChtYXhXaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWF4SGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlIDwgMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlQ2FudmFzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG9wdGlvbnMgPSBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zKGltZywgb3B0aW9ucywgZGF0YSlcbiAgICAgIHNvdXJjZVggPSBvcHRpb25zLmxlZnQgfHwgMFxuICAgICAgc291cmNlWSA9IG9wdGlvbnMudG9wIHx8IDBcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9IHdpZHRoIC0gc291cmNlV2lkdGggLSBvcHRpb25zLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gd2lkdGggLSBzb3VyY2VYIC0gKG9wdGlvbnMucmlnaHQgfHwgMClcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZUhlaWdodCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5ib3R0b20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWSA9IGhlaWdodCAtIHNvdXJjZUhlaWdodCAtIG9wdGlvbnMuYm90dG9tXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUhlaWdodCA9IGhlaWdodCAtIHNvdXJjZVkgLSAob3B0aW9ucy5ib3R0b20gfHwgMClcbiAgICAgIH1cbiAgICAgIGRlc3RXaWR0aCA9IHNvdXJjZVdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gc291cmNlSGVpZ2h0XG4gICAgfVxuICAgIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aFxuICAgIG1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0XG4gICAgbWluV2lkdGggPSBvcHRpb25zLm1pbldpZHRoXG4gICAgbWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHRcbiAgICBpZiAodXNlQ2FudmFzICYmIG1heFdpZHRoICYmIG1heEhlaWdodCAmJiBvcHRpb25zLmNyb3ApIHtcbiAgICAgIGRlc3RXaWR0aCA9IG1heFdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gbWF4SGVpZ2h0XG4gICAgICB0bXAgPSBzb3VyY2VXaWR0aCAvIHNvdXJjZUhlaWdodCAtIG1heFdpZHRoIC8gbWF4SGVpZ2h0XG4gICAgICBpZiAodG1wIDwgMCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSAobWF4SGVpZ2h0ICogc291cmNlV2lkdGgpIC8gbWF4V2lkdGhcbiAgICAgICAgaWYgKG9wdGlvbnMudG9wID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5ib3R0b20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNvdXJjZVkgPSAoaGVpZ2h0IC0gc291cmNlSGVpZ2h0KSAvIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0bXAgPiAwKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gKG1heFdpZHRoICogc291cmNlSGVpZ2h0KSAvIG1heEhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9ICh3aWR0aCAtIHNvdXJjZVdpZHRoKSAvIDJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluIHx8IG9wdGlvbnMuY292ZXIpIHtcbiAgICAgICAgbWluV2lkdGggPSBtYXhXaWR0aCA9IG1heFdpZHRoIHx8IG1pbldpZHRoXG4gICAgICAgIG1pbkhlaWdodCA9IG1heEhlaWdodCA9IG1heEhlaWdodCB8fCBtaW5IZWlnaHRcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICAgIHNjYWxlVXAoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVVcCgpXG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VDYW52YXMpIHtcbiAgICAgIHBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW9cbiAgICAgIGlmIChwaXhlbFJhdGlvID4gMSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBkZXN0V2lkdGggKyAncHgnXG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBkZXN0SGVpZ2h0ICsgJ3B4J1xuICAgICAgICBkZXN0V2lkdGggKj0gcGl4ZWxSYXRpb1xuICAgICAgICBkZXN0SGVpZ2h0ICo9IHBpeGVsUmF0aW9cbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbylcbiAgICAgIH1cbiAgICAgIGRvd25zYW1wbGluZ1JhdGlvID0gb3B0aW9ucy5kb3duc2FtcGxpbmdSYXRpb1xuICAgICAgaWYgKFxuICAgICAgICBkb3duc2FtcGxpbmdSYXRpbyA+IDAgJiZcbiAgICAgICAgZG93bnNhbXBsaW5nUmF0aW8gPCAxICYmXG4gICAgICAgIGRlc3RXaWR0aCA8IHNvdXJjZVdpZHRoICYmXG4gICAgICAgIGRlc3RIZWlnaHQgPCBzb3VyY2VIZWlnaHRcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAoc291cmNlV2lkdGggKiBkb3duc2FtcGxpbmdSYXRpbyA+IGRlc3RXaWR0aCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNvdXJjZVdpZHRoICogZG93bnNhbXBsaW5nUmF0aW9cbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc291cmNlSGVpZ2h0ICogZG93bnNhbXBsaW5nUmF0aW9cbiAgICAgICAgICBsb2FkSW1hZ2UucmVuZGVySW1hZ2VUb0NhbnZhcyhcbiAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHRcbiAgICAgICAgICApXG4gICAgICAgICAgc291cmNlWCA9IDBcbiAgICAgICAgICBzb3VyY2VZID0gMFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gY2FudmFzLndpZHRoXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gY2FudmFzLmhlaWdodFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgaW1nLndpZHRoID0gc291cmNlV2lkdGhcbiAgICAgICAgICBpbWcuaGVpZ2h0ID0gc291cmNlSGVpZ2h0XG4gICAgICAgICAgbG9hZEltYWdlLnJlbmRlckltYWdlVG9DYW52YXMoXG4gICAgICAgICAgICBpbWcsXG4gICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzb3VyY2VXaWR0aCxcbiAgICAgICAgICAgIHNvdXJjZUhlaWdodFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FudmFzLndpZHRoID0gZGVzdFdpZHRoXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gZGVzdEhlaWdodFxuICAgICAgbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGNhbnZhcywgb3B0aW9ucylcbiAgICAgIHJldHVybiBsb2FkSW1hZ2UucmVuZGVySW1hZ2VUb0NhbnZhcyhcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBpbWcsXG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGRlc3RXaWR0aCxcbiAgICAgICAgZGVzdEhlaWdodFxuICAgICAgKVxuICAgIH1cbiAgICBpbWcud2lkdGggPSBkZXN0V2lkdGhcbiAgICBpbWcuaGVpZ2h0ID0gZGVzdEhlaWdodFxuICAgIHJldHVybiBpbWdcbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-scale.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image.js":
/*!**********************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, webkitURL, module */\n\n;(function($) {\n  'use strict'\n\n  /**\n   * Loads an image for a given File object.\n   * Invokes the callback with an img or optional canvas element\n   * (if supported by the browser) as parameter:.\n   *\n   * @param {File|Blob|string} file File or Blob object or image URL\n   * @param {Function} [callback] Image load event callback\n   * @param {object} [options] Options object\n   * @returns {HTMLImageElement|HTMLCanvasElement|FileReader} image object\n   */\n  function loadImage(file, callback, options) {\n    var img = document.createElement('img')\n    var url\n    img.onerror = function(event) {\n      return loadImage.onerror(img, event, file, callback, options)\n    }\n    img.onload = function(event) {\n      return loadImage.onload(img, event, file, callback, options)\n    }\n    if (typeof file === 'string') {\n      loadImage.fetchBlob(\n        file,\n        function(blob) {\n          if (blob) {\n            // eslint-disable-next-line no-param-reassign\n            file = blob\n            url = loadImage.createObjectURL(file)\n          } else {\n            url = file\n            if (options && options.crossOrigin) {\n              img.crossOrigin = options.crossOrigin\n            }\n          }\n          img.src = url\n        },\n        options\n      )\n      return img\n    } else if (\n      loadImage.isInstanceOf('Blob', file) ||\n      // Files are also Blob instances, but some browsers\n      // (Firefox 3.6) support the File API but not Blobs:\n      loadImage.isInstanceOf('File', file)\n    ) {\n      url = img._objectURL = loadImage.createObjectURL(file)\n      if (url) {\n        img.src = url\n        return img\n      }\n      return loadImage.readFile(file, function(e) {\n        var target = e.target\n        if (target && target.result) {\n          img.src = target.result\n        } else if (callback) {\n          callback(e)\n        }\n      })\n    }\n  }\n  // The check for URL.revokeObjectURL fixes an issue with Opera 12,\n  // which provides URL.createObjectURL but doesn't properly implement it:\n  var urlAPI =\n    ($.createObjectURL && $) ||\n    ($.URL && URL.revokeObjectURL && URL) ||\n    ($.webkitURL && webkitURL)\n\n  /**\n   * Helper function to revoke an object URL\n   *\n   * @param {HTMLImageElement} img Image element\n   * @param {object} [options] Options object\n   */\n  function revokeHelper(img, options) {\n    if (img._objectURL && !(options && options.noRevoke)) {\n      loadImage.revokeObjectURL(img._objectURL)\n      delete img._objectURL\n    }\n  }\n\n  // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n  loadImage.fetchBlob = function(url, callback) {\n    callback()\n  }\n\n  loadImage.isInstanceOf = function(type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n  }\n\n  loadImage.transform = function(img, options, callback, file, data) {\n    callback(img, data)\n  }\n\n  loadImage.onerror = function(img, event, file, callback, options) {\n    revokeHelper(img, options)\n    if (callback) {\n      callback.call(img, event)\n    }\n  }\n\n  loadImage.onload = function(img, event, file, callback, options) {\n    revokeHelper(img, options)\n    if (callback) {\n      loadImage.transform(img, options, callback, file, {\n        originalWidth: img.naturalWidth || img.width,\n        originalHeight: img.naturalHeight || img.height\n      })\n    }\n  }\n\n  loadImage.createObjectURL = function(file) {\n    return urlAPI ? urlAPI.createObjectURL(file) : false\n  }\n\n  loadImage.revokeObjectURL = function(url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n  }\n\n  // Loads a given File object via FileReader interface,\n  // invokes the callback with the event object (load or error).\n  // The result can be read via event.target.result:\n  loadImage.readFile = function(file, callback, method) {\n    if ($.FileReader) {\n      var fileReader = new FileReader()\n      fileReader.onload = fileReader.onerror = callback\n      // eslint-disable-next-line no-param-reassign\n      method = method || 'readAsDataURL'\n      if (fileReader[method]) {\n        fileReader[method](file)\n        return fileReader\n      }\n    }\n    return false\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return loadImage\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})((typeof window !== 'undefined' && window) || this)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanM/MDliNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTixHQUFHLE1BQU0sRUFJTjtBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgd2Via2l0VVJMLCBtb2R1bGUgKi9cblxuOyhmdW5jdGlvbigkKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIC8qKlxuICAgKiBMb2FkcyBhbiBpbWFnZSBmb3IgYSBnaXZlbiBGaWxlIG9iamVjdC5cbiAgICogSW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCBhbiBpbWcgb3Igb3B0aW9uYWwgY2FudmFzIGVsZW1lbnRcbiAgICogKGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcikgYXMgcGFyYW1ldGVyOi5cbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfEJsb2J8c3RyaW5nfSBmaWxlIEZpbGUgb3IgQmxvYiBvYmplY3Qgb3IgaW1hZ2UgVVJMXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSW1hZ2UgbG9hZCBldmVudCBjYWxsYmFja1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEZpbGVSZWFkZXJ9IGltYWdlIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZEltYWdlKGZpbGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgdmFyIHVybFxuICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHJldHVybiBsb2FkSW1hZ2Uub25lcnJvcihpbWcsIGV2ZW50LCBmaWxlLCBjYWxsYmFjaywgb3B0aW9ucylcbiAgICB9XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlLm9ubG9hZChpbWcsIGV2ZW50LCBmaWxlLCBjYWxsYmFjaywgb3B0aW9ucylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgbG9hZEltYWdlLmZldGNoQmxvYihcbiAgICAgICAgZmlsZSxcbiAgICAgICAgZnVuY3Rpb24oYmxvYikge1xuICAgICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpbGUgPSBibG9iXG4gICAgICAgICAgICB1cmwgPSBsb2FkSW1hZ2UuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IGZpbGVcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbWcuc3JjID0gdXJsXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICAgIHJldHVybiBpbWdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbG9hZEltYWdlLmlzSW5zdGFuY2VPZignQmxvYicsIGZpbGUpIHx8XG4gICAgICAvLyBGaWxlcyBhcmUgYWxzbyBCbG9iIGluc3RhbmNlcywgYnV0IHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIChGaXJlZm94IDMuNikgc3VwcG9ydCB0aGUgRmlsZSBBUEkgYnV0IG5vdCBCbG9iczpcbiAgICAgIGxvYWRJbWFnZS5pc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKVxuICAgICkge1xuICAgICAgdXJsID0gaW1nLl9vYmplY3RVUkwgPSBsb2FkSW1hZ2UuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGltZy5zcmMgPSB1cmxcbiAgICAgICAgcmV0dXJuIGltZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvYWRJbWFnZS5yZWFkRmlsZShmaWxlLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldFxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5yZXN1bHQpIHtcbiAgICAgICAgICBpbWcuc3JjID0gdGFyZ2V0LnJlc3VsdFxuICAgICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgLy8gVGhlIGNoZWNrIGZvciBVUkwucmV2b2tlT2JqZWN0VVJMIGZpeGVzIGFuIGlzc3VlIHdpdGggT3BlcmEgMTIsXG4gIC8vIHdoaWNoIHByb3ZpZGVzIFVSTC5jcmVhdGVPYmplY3RVUkwgYnV0IGRvZXNuJ3QgcHJvcGVybHkgaW1wbGVtZW50IGl0OlxuICB2YXIgdXJsQVBJID1cbiAgICAoJC5jcmVhdGVPYmplY3RVUkwgJiYgJCkgfHxcbiAgICAoJC5VUkwgJiYgVVJMLnJldm9rZU9iamVjdFVSTCAmJiBVUkwpIHx8XG4gICAgKCQud2Via2l0VVJMICYmIHdlYmtpdFVSTClcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldm9rZSBhbiBvYmplY3QgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nIEltYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gcmV2b2tlSGVscGVyKGltZywgb3B0aW9ucykge1xuICAgIGlmIChpbWcuX29iamVjdFVSTCAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Jldm9rZSkpIHtcbiAgICAgIGxvYWRJbWFnZS5yZXZva2VPYmplY3RVUkwoaW1nLl9vYmplY3RVUkwpXG4gICAgICBkZWxldGUgaW1nLl9vYmplY3RVUkxcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2FsbGJhY2sgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYmxvYiwgaXQgaXMgdXNlZCBhcyBpbWFnZVxuICAvLyBzb3VyY2UgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdXJsIGFuZCBvdmVycmlkZXMgdGhlIGZpbGUgYXJndW1lbnQgdXNlZCBpblxuICAvLyB0aGUgb25sb2FkIGFuZCBvbmVycm9yIGV2ZW50IGNhbGxiYWNrczpcbiAgbG9hZEltYWdlLmZldGNoQmxvYiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpXG4gIH1cblxuICBsb2FkSW1hZ2UuaXNJbnN0YW5jZU9mID0gZnVuY3Rpb24odHlwZSwgb2JqKSB7XG4gICAgLy8gQ3Jvc3MtZnJhbWUgaW5zdGFuY2VvZiBjaGVja1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSdcbiAgfVxuXG4gIGxvYWRJbWFnZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCBkYXRhKSB7XG4gICAgY2FsbGJhY2soaW1nLCBkYXRhKVxuICB9XG5cbiAgbG9hZEltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihpbWcsIGV2ZW50LCBmaWxlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHJldm9rZUhlbHBlcihpbWcsIG9wdGlvbnMpXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGltZywgZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKGltZywgZXZlbnQsIGZpbGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgcmV2b2tlSGVscGVyKGltZywgb3B0aW9ucylcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGxvYWRJbWFnZS50cmFuc2Zvcm0oaW1nLCBvcHRpb25zLCBjYWxsYmFjaywgZmlsZSwge1xuICAgICAgICBvcmlnaW5hbFdpZHRoOiBpbWcubmF0dXJhbFdpZHRoIHx8IGltZy53aWR0aCxcbiAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHRcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICByZXR1cm4gdXJsQVBJID8gdXJsQVBJLmNyZWF0ZU9iamVjdFVSTChmaWxlKSA6IGZhbHNlXG4gIH1cblxuICBsb2FkSW1hZ2UucmV2b2tlT2JqZWN0VVJMID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybEFQSSA/IHVybEFQSS5yZXZva2VPYmplY3RVUkwodXJsKSA6IGZhbHNlXG4gIH1cblxuICAvLyBMb2FkcyBhIGdpdmVuIEZpbGUgb2JqZWN0IHZpYSBGaWxlUmVhZGVyIGludGVyZmFjZSxcbiAgLy8gaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZXZlbnQgb2JqZWN0IChsb2FkIG9yIGVycm9yKS5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgcmVhZCB2aWEgZXZlbnQudGFyZ2V0LnJlc3VsdDpcbiAgbG9hZEltYWdlLnJlYWRGaWxlID0gZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2ssIG1ldGhvZCkge1xuICAgIGlmICgkLkZpbGVSZWFkZXIpIHtcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSBjYWxsYmFja1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtZXRob2QgPSBtZXRob2QgfHwgJ3JlYWRBc0RhdGFVUkwnXG4gICAgICBpZiAoZmlsZVJlYWRlclttZXRob2RdKSB7XG4gICAgICAgIGZpbGVSZWFkZXJbbWV0aG9kXShmaWxlKVxuICAgICAgICByZXR1cm4gZmlsZVJlYWRlclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbG9hZEltYWdlXG4gIH0gZWxzZSB7XG4gICAgJC5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2VcbiAgfVxufSkoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHwgdGhpcylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image.js\n");

/***/ }),

/***/ "./node_modules/croppr/dist/croppr.js":
/*!********************************************!*\
  !*** ./node_modules/croppr/dist/croppr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Croppr.js\n * https://github.com/jamesssooi/Croppr.js\n * \n * A JavaScript image cropper that's lightweight, awesome, and has\n * zero dependencies.\n * \n * (C) 2017 James Ooi. Released under the MIT License.\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n(function () {\n  if (typeof window.CustomEvent === \"function\") return false;\n  function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n})();\n(function (window) {\n  try {\n    new CustomEvent('test');\n    return false;\n  } catch (e) {}\n  function MouseEvent(eventType, params) {\n    params = params || { bubbles: false, cancelable: false };\n    var mouseEvent = document.createEvent('MouseEvent');\n    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    return mouseEvent;\n  }\n  MouseEvent.prototype = Event.prototype;\n  window.MouseEvent = MouseEvent;\n})(window);\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar Handle =\n/**\n * Creates a new Handle instance.\n * @constructor\n * @param {Array} position The x and y ratio position of the handle\n *      within the crop region. Accepts a value between 0 to 1 in the order\n *      of [X, Y].\n * @param {Array} constraints Define the side of the crop region that\n *      is to be affected by this handle. Accepts a value of 0 or 1 in the\n *      order of [TOP, RIGHT, BOTTOM, LEFT].\n * @param {String} cursor The CSS cursor of this handle.\n * @param {Element} eventBus The element to dispatch events to.\n */\nfunction Handle(position, constraints, cursor, eventBus) {\n  classCallCheck(this, Handle);\n  var self = this;\n  this.position = position;\n  this.constraints = constraints;\n  this.cursor = cursor;\n  this.eventBus = eventBus;\n  this.el = document.createElement('div');\n  this.el.className = 'croppr-handle';\n  this.el.style.cursor = cursor;\n  this.el.addEventListener('mousedown', onMouseDown);\n  function onMouseDown(e) {\n    e.stopPropagation();\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseUp(e) {\n    e.stopPropagation();\n    document.removeEventListener('mouseup', onMouseUp);\n    document.removeEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseMove(e) {\n    e.stopPropagation();\n    self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n      detail: { mouseX: e.clientX, mouseY: e.clientY }\n    }));\n  }\n};\n\nvar Box = function () {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  function Box(x1, y1, x2, y2) {\n    classCallCheck(this, Box);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  /**\n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  createClass(Box, [{\n    key: 'set',\n    value: function set$$1() {\n      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      this.x1 = x1 == null ? this.x1 : x1;\n      this.y1 = y1 == null ? this.y1 : y1;\n      this.x2 = x2 == null ? this.x2 : x2;\n      this.y2 = y2 == null ? this.y2 : y2;\n      return this;\n    }\n    /**\n     * Calculates the width of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'width',\n    value: function width() {\n      return Math.abs(this.x2 - this.x1);\n    }\n    /**\n     * Calculates the height of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'height',\n    value: function height() {\n      return Math.abs(this.y2 - this.y1);\n    }\n    /**\n     * Resizes the box to a new size.\n     * @param {Number} newWidth\n     * @param {Number} newHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'resize',\n    value: function resize(newWidth, newHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var fromX = this.x1 + this.width() * origin[0];\n      var fromY = this.y1 + this.height() * origin[1];\n      this.x1 = fromX - newWidth * origin[0];\n      this.y1 = fromY - newHeight * origin[1];\n      this.x2 = this.x1 + newWidth;\n      this.y2 = this.y1 + newHeight;\n      return this;\n    }\n    /**\n     * Scale the box by a factor.\n     * @param {Number} factor\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'scale',\n    value: function scale(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var newWidth = this.width() * factor;\n      var newHeight = this.height() * factor;\n      this.resize(newWidth, newHeight, origin);\n      return this;\n    }\n  }, {\n    key: 'move',\n    value: function move() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var width = this.width();\n      var height = this.height();\n      x = x === null ? this.x1 : x;\n      y = y === null ? this.y1 : y;\n      this.x1 = x;\n      this.y1 = y;\n      this.x2 = x + width;\n      this.y2 = y + height;\n      return this;\n    }\n    /**\n     * Get relative x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getRelativePoint',\n    value: function getRelativePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.width() * point[0];\n      var y = this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Get absolute x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getAbsolutePoint',\n    value: function getAbsolutePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.x1 + this.width() * point[0];\n      var y = this.y1 + this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Constrain the box to a fixed ratio.\n     * @param {Number} ratio\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {String} [grow] The axis to grow to maintain the ratio.\n     *     Defaults to 'height'.\n     */\n  }, {\n    key: 'constrainToRatio',\n    value: function constrainToRatio(ratio) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var grow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'height';\n      if (ratio === null) {\n        return;\n      }\n      var width = this.width();\n      var height = this.height();\n      switch (grow) {\n        case 'height':\n          this.resize(this.width(), this.width() * ratio, origin);\n          break;\n        case 'width':\n          this.resize(this.height() * 1 / ratio, this.height(), origin);\n          break;\n        default:\n          this.resize(this.width(), this.width() * ratio, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box within a boundary.\n     * @param {Number} boundaryWidth\n     * @param {Number} boundaryHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'constrainToBoundary',\n    value: function constrainToBoundary(boundaryWidth, boundaryHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var _getAbsolutePoint = this.getAbsolutePoint(origin),\n          _getAbsolutePoint2 = slicedToArray(_getAbsolutePoint, 2),\n          originX = _getAbsolutePoint2[0],\n          originY = _getAbsolutePoint2[1];\n      var maxIfLeft = originX;\n      var maxIfTop = originY;\n      var maxIfRight = boundaryWidth - originX;\n      var maxIfBottom = boundaryHeight - originY;\n      var directionX = -2 * origin[0] + 1;\n      var directionY = -2 * origin[1] + 1;\n      var maxWidth = null,\n          maxHeight = null;\n      switch (directionX) {\n        case -1:\n          maxWidth = maxIfLeft;break;\n        case 0:\n          maxWidth = Math.min(maxIfLeft, maxIfRight) * 2;break;\n        case +1:\n          maxWidth = maxIfRight;break;\n      }\n      switch (directionY) {\n        case -1:\n          maxHeight = maxIfTop;break;\n        case 0:\n          maxHeight = Math.min(maxIfTop, maxIfBottom) * 2;break;\n        case +1:\n          maxHeight = maxIfBottom;break;\n      }\n      if (this.width() > maxWidth) {\n        var factor = maxWidth / this.width();\n        this.scale(factor, origin);\n      }\n      if (this.height() > maxHeight) {\n        var _factor = maxHeight / this.height();\n        this.scale(_factor, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box to a maximum/minimum size.\n     * @param {Number} [maxWidth]\n     * @param {Number} [maxHeight]\n     * @param {Number} [minWidth]\n     * @param {Number} [minHeight]\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {Number} [ratio] Ratio to maintain.\n     */\n  }, {\n    key: 'constrainToSize',\n    value: function constrainToSize() {\n      var maxWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var maxHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var minWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var minHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n      var ratio = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      if (ratio) {\n        if (ratio > 1) {\n          maxWidth = maxHeight * 1 / ratio;\n          minHeight = minHeight * ratio;\n        } else if (ratio < 1) {\n          maxHeight = maxWidth * ratio;\n          minWidth = minHeight * 1 / ratio;\n        }\n      }\n      if (maxWidth && this.width() > maxWidth) {\n        var newWidth = maxWidth,\n            newHeight = ratio === null ? this.height() : maxHeight;\n        this.resize(newWidth, newHeight, origin);\n      }\n      if (maxHeight && this.height() > maxHeight) {\n        var _newWidth = ratio === null ? this.width() : maxWidth,\n            _newHeight = maxHeight;\n        this.resize(_newWidth, _newHeight, origin);\n      }\n      if (minWidth && this.width() < minWidth) {\n        var _newWidth2 = minWidth,\n            _newHeight2 = ratio === null ? this.height() : minHeight;\n        this.resize(_newWidth2, _newHeight2, origin);\n      }\n      if (minHeight && this.height() < minHeight) {\n        var _newWidth3 = ratio === null ? this.width() : minWidth,\n            _newHeight3 = minHeight;\n        this.resize(_newWidth3, _newHeight3, origin);\n      }\n      return this;\n    }\n  }]);\n  return Box;\n}();\n\n/**\n * Binds an element's touch events to be simulated as mouse events.\n * @param {Element} element\n */\nfunction enableTouch(element) {\n  element.addEventListener('touchstart', simulateMouseEvent);\n  element.addEventListener('touchend', simulateMouseEvent);\n  element.addEventListener('touchmove', simulateMouseEvent);\n}\n/**\n * Translates a touch event to a mouse event.\n * @param {Event} e\n */\nfunction simulateMouseEvent(e) {\n  e.preventDefault();\n  var touch = e.changedTouches[0];\n  var eventMap = {\n    'touchstart': 'mousedown',\n    'touchmove': 'mousemove',\n    'touchend': 'mouseup'\n  };\n  touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {\n    bubbles: true,\n    cancelable: true,\n    view: window,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    screenX: touch.screenX,\n    screenY: touch.screenY\n  }));\n}\n\n/**\n * Define a list of handles to create.\n *\n * @property {Array} position - The x and y ratio position of the handle within\n *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].\n * @property {Array} constraints - Define the side of the crop region that is to\n *      be affected by this handle. Accepts a value of 0 or 1 in the order of\n *      [TOP, RIGHT, BOTTOM, LEFT].\n * @property {String} cursor - The CSS cursor of this handle.\n */\nvar HANDLES = [{ position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: 'nw-resize' }, { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: 'n-resize' }, { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: 'ne-resize' }, { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: 'e-resize' }, { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: 'se-resize' }, { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: 's-resize' }, { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: 'sw-resize' }, { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: 'w-resize' }];\nvar CropprCore = function () {\n  function CropprCore(element, options) {\n    var _this = this;\n    var deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, CropprCore);\n    this.options = CropprCore.parseOptions(options || {});\n    if (!element.nodeName) {\n      element = document.querySelector(element);\n      if (element == null) {\n        throw 'Unable to find element.';\n      }\n    }\n    if (!element.getAttribute('src')) {\n      throw 'Image src not provided.';\n    }\n    this._initialized = false;\n    this._restore = {\n      parent: element.parentNode,\n      element: element\n    };\n    if (!deferred) {\n      if (element.width === 0 || element.height === 0) {\n        element.onload = function () {\n          _this.initialize(element);\n        };\n      } else {\n        this.initialize(element);\n      }\n    }\n  }\n  createClass(CropprCore, [{\n    key: 'initialize',\n    value: function initialize(element) {\n      this.createDOM(element);\n      this.options.convertToPixels(this.cropperEl);\n      this.attachHandlerEvents();\n      this.attachRegionEvents();\n      this.attachOverlayEvents();\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      this._initialized = true;\n      if (this.options.onInitialize !== null) {\n        this.options.onInitialize(this);\n      }\n    }\n  }, {\n    key: 'createDOM',\n    value: function createDOM(targetEl) {\n      this.containerEl = document.createElement('div');\n      this.containerEl.className = 'croppr-container';\n      this.eventBus = this.containerEl;\n      enableTouch(this.containerEl);\n      this.cropperEl = document.createElement('div');\n      this.cropperEl.className = 'croppr';\n      this.imageEl = document.createElement('img');\n      this.imageEl.setAttribute('src', targetEl.getAttribute('src'));\n      this.imageEl.setAttribute('alt', targetEl.getAttribute('alt'));\n      this.imageEl.className = 'croppr-image';\n      this.imageClippedEl = this.imageEl.cloneNode();\n      this.imageClippedEl.className = 'croppr-imageClipped';\n      this.regionEl = document.createElement('div');\n      this.regionEl.className = 'croppr-region';\n      this.overlayEl = document.createElement('div');\n      this.overlayEl.className = 'croppr-overlay';\n      var handleContainerEl = document.createElement('div');\n      handleContainerEl.className = 'croppr-handleContainer';\n      this.handles = [];\n      for (var i = 0; i < HANDLES.length; i++) {\n        var handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);\n        this.handles.push(handle);\n        handleContainerEl.appendChild(handle.el);\n      }\n      this.cropperEl.appendChild(this.imageEl);\n      this.cropperEl.appendChild(this.imageClippedEl);\n      this.cropperEl.appendChild(this.regionEl);\n      this.cropperEl.appendChild(this.overlayEl);\n      this.cropperEl.appendChild(handleContainerEl);\n      this.containerEl.appendChild(this.cropperEl);\n      targetEl.parentElement.replaceChild(this.containerEl, targetEl);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      var _this2 = this;\n      this.imageEl.onload = function () {\n        _this2.box = _this2.initializeBox(_this2.options);\n        _this2.redraw();\n      };\n      this.imageEl.src = src;\n      this.imageClippedEl.src = src;\n      return this;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._restore.parent.replaceChild(this._restore.element, this.containerEl);\n    }\n    /**\n     * Create a new box region with a set of options.\n     * @param {Object} opts The options.\n     * @returns {Box}\n     */\n  }, {\n    key: 'initializeBox',\n    value: function initializeBox(opts) {\n      var width = opts.startSize.width;\n      var height = opts.startSize.height;\n      var box = new Box(0, 0, width, height);\n      box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);\n      var min = opts.minSize;\n      var max = opts.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);\n      var x = this.cropperEl.offsetWidth / 2 - box.width() / 2;\n      var y = this.cropperEl.offsetHeight / 2 - box.height() / 2;\n      box.move(x, y);\n      return box;\n    }\n  }, {\n    key: 'redraw',\n    value: function redraw() {\n      var _this3 = this;\n      var width = Math.round(this.box.width()),\n          height = Math.round(this.box.height()),\n          x1 = Math.round(this.box.x1),\n          y1 = Math.round(this.box.y1),\n          x2 = Math.round(this.box.x2),\n          y2 = Math.round(this.box.y2);\n      window.requestAnimationFrame(function () {\n        _this3.regionEl.style.transform = 'translate(' + x1 + 'px, ' + y1 + 'px)';\n        _this3.regionEl.style.width = width + 'px';\n        _this3.regionEl.style.height = height + 'px';\n        _this3.imageClippedEl.style.clip = 'rect(' + y1 + 'px, ' + x2 + 'px, ' + y2 + 'px, ' + x1 + 'px)';\n        var center = _this3.box.getAbsolutePoint([.5, .5]);\n        var xSign = center[0] - _this3.cropperEl.offsetWidth / 2 >> 31;\n        var ySign = center[1] - _this3.cropperEl.offsetHeight / 2 >> 31;\n        var quadrant = (xSign ^ ySign) + ySign + ySign + 4;\n        var foregroundHandleIndex = -2 * quadrant + 8;\n        for (var i = 0; i < _this3.handles.length; i++) {\n          var handle = _this3.handles[i];\n          var handleWidth = handle.el.offsetWidth;\n          var handleHeight = handle.el.offsetHeight;\n          var left = x1 + width * handle.position[0] - handleWidth / 2;\n          var top = y1 + height * handle.position[1] - handleHeight / 2;\n          handle.el.style.transform = 'translate(' + Math.round(left) + 'px, ' + Math.round(top) + 'px)';\n          handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;\n        }\n      });\n    }\n  }, {\n    key: 'attachHandlerEvents',\n    value: function attachHandlerEvents() {\n      var eventBus = this.eventBus;\n      eventBus.addEventListener('handlestart', this.onHandleMoveStart.bind(this));\n      eventBus.addEventListener('handlemove', this.onHandleMoveMoving.bind(this));\n      eventBus.addEventListener('handleend', this.onHandleMoveEnd.bind(this));\n    }\n  }, {\n    key: 'attachRegionEvents',\n    value: function attachRegionEvents() {\n      var eventBus = this.eventBus;\n      var self = this;\n      this.regionEl.addEventListener('mousedown', onMouseDown);\n      eventBus.addEventListener('regionstart', this.onRegionMoveStart.bind(this));\n      eventBus.addEventListener('regionmove', this.onRegionMoveMoving.bind(this));\n      eventBus.addEventListener('regionend', this.onRegionMoveEnd.bind(this));\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionstart', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        eventBus.dispatchEvent(new CustomEvent('regionmove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'attachOverlayEvents',\n    value: function attachOverlayEvents() {\n      var SOUTHEAST_HANDLE_IDX = 4;\n      var self = this;\n      var tmpBox = null;\n      this.overlayEl.addEventListener('mousedown', onMouseDown);\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        var container = self.cropperEl.getBoundingClientRect();\n        var mouseX = e.clientX - container.left;\n        var mouseY = e.clientY - container.top;\n        tmpBox = self.box;\n        self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);\n        self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n          detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        if (self.box.width() === 1 && self.box.height() === 1) {\n          self.box = tmpBox;\n          return;\n        }\n        self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'onHandleMoveStart',\n    value: function onHandleMoveStart(e) {\n      var handle = e.detail.handle;\n      var originPoint = [1 - handle.position[0], 1 - handle.position[1]];\n      var _box$getAbsolutePoint = this.box.getAbsolutePoint(originPoint),\n          _box$getAbsolutePoint2 = slicedToArray(_box$getAbsolutePoint, 2),\n          originX = _box$getAbsolutePoint2[0],\n          originY = _box$getAbsolutePoint2[1];\n      this.activeHandle = { handle: handle, originPoint: originPoint, originX: originX, originY: originY };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveMoving',\n    value: function onHandleMoveMoving(e) {\n      var _e$detail = e.detail,\n          mouseX = _e$detail.mouseX,\n          mouseY = _e$detail.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      if (mouseX < 0) {\n        mouseX = 0;\n      } else if (mouseX > container.width) {\n        mouseX = container.width;\n      }\n      if (mouseY < 0) {\n        mouseY = 0;\n      } else if (mouseY > container.height) {\n        mouseY = container.height;\n      }\n      var origin = this.activeHandle.originPoint.slice();\n      var originX = this.activeHandle.originX;\n      var originY = this.activeHandle.originY;\n      var handle = this.activeHandle.handle;\n      var TOP_MOVABLE = handle.constraints[0] === 1;\n      var RIGHT_MOVABLE = handle.constraints[1] === 1;\n      var BOTTOM_MOVABLE = handle.constraints[2] === 1;\n      var LEFT_MOVABLE = handle.constraints[3] === 1;\n      var MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);\n      var x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;\n      var x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;\n      var y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;\n      var y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;\n      x1 = LEFT_MOVABLE ? mouseX : x1;\n      x2 = RIGHT_MOVABLE ? mouseX : x2;\n      y1 = TOP_MOVABLE ? mouseY : y1;\n      y2 = BOTTOM_MOVABLE ? mouseY : y2;\n      var isFlippedX = false,\n          isFlippedY = false;\n      if (LEFT_MOVABLE || RIGHT_MOVABLE) {\n        isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;\n      }\n      if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n        isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;\n      }\n      if (isFlippedX) {\n        var tmp = x1;x1 = x2;x2 = tmp;\n        origin[0] = 1 - origin[0];\n      }\n      if (isFlippedY) {\n        var _tmp = y1;y1 = y2;y2 = _tmp;\n        origin[1] = 1 - origin[1];\n      }\n      var box = new Box(x1, y1, x2, y2);\n      if (this.options.aspectRatio) {\n        var ratio = this.options.aspectRatio;\n        var isVerticalMovement = false;\n        if (MULTI_AXIS) {\n          isVerticalMovement = mouseY > box.y1 + ratio * box.width() || mouseY < box.y2 - ratio * box.width();\n        } else if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n          isVerticalMovement = true;\n        }\n        var ratioMode = isVerticalMovement ? 'width' : 'height';\n        box.constrainToRatio(ratio, origin, ratioMode);\n      }\n      var min = this.options.minSize;\n      var max = this.options.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, origin);\n      this.box = box;\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveEnd',\n    value: function onHandleMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveStart',\n    value: function onRegionMoveStart(e) {\n      var _e$detail2 = e.detail,\n          mouseX = _e$detail2.mouseX,\n          mouseY = _e$detail2.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.currentMove = {\n        offsetX: mouseX - this.box.x1,\n        offsetY: mouseY - this.box.y1\n      };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveMoving',\n    value: function onRegionMoveMoving(e) {\n      var _e$detail3 = e.detail,\n          mouseX = _e$detail3.mouseX,\n          mouseY = _e$detail3.mouseY;\n      var _currentMove = this.currentMove,\n          offsetX = _currentMove.offsetX,\n          offsetY = _currentMove.offsetY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.box.move(mouseX - offsetX, mouseY - offsetY);\n      if (this.box.x1 < 0) {\n        this.box.move(0, null);\n      }\n      if (this.box.x2 > container.width) {\n        this.box.move(container.width - this.box.width(), null);\n      }\n      if (this.box.y1 < 0) {\n        this.box.move(null, 0);\n      }\n      if (this.box.y2 > container.height) {\n        this.box.move(null, container.height - this.box.height());\n      }\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveEnd',\n    value: function onRegionMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (mode === null) {\n        mode = this.options.returnMode;\n      }\n      if (mode == 'real') {\n        var actualWidth = this.imageEl.naturalWidth;\n        var actualHeight = this.imageEl.naturalHeight;\n        var _imageEl$getBoundingC = this.imageEl.getBoundingClientRect(),\n            elementWidth = _imageEl$getBoundingC.width,\n            elementHeight = _imageEl$getBoundingC.height;\n        var factorX = actualWidth / elementWidth;\n        var factorY = actualHeight / elementHeight;\n        return {\n          x: Math.round(this.box.x1 * factorX),\n          y: Math.round(this.box.y1 * factorY),\n          width: Math.round(this.box.width() * factorX),\n          height: Math.round(this.box.height() * factorY)\n        };\n      } else if (mode == 'ratio') {\n        var _imageEl$getBoundingC2 = this.imageEl.getBoundingClientRect(),\n            _elementWidth = _imageEl$getBoundingC2.width,\n            _elementHeight = _imageEl$getBoundingC2.height;\n        return {\n          x: round(this.box.x1 / _elementWidth, 3),\n          y: round(this.box.y1 / _elementHeight, 3),\n          width: round(this.box.width() / _elementWidth, 3),\n          height: round(this.box.height() / _elementHeight, 3)\n        };\n      } else if (mode == 'raw') {\n        return {\n          x: Math.round(this.box.x1),\n          y: Math.round(this.box.y1),\n          width: Math.round(this.box.width()),\n          height: Math.round(this.box.height())\n        };\n      }\n    }\n  }], [{\n    key: 'parseOptions',\n    value: function parseOptions(opts) {\n      var defaults$$1 = {\n        aspectRatio: null,\n        maxSize: { width: null, height: null },\n        minSize: { width: null, height: null },\n        startSize: { width: 100, height: 100, unit: '%' },\n        returnMode: 'real',\n        onInitialize: null,\n        onCropStart: null,\n        onCropMove: null,\n        onCropEnd: null\n      };\n      var aspectRatio = null;\n      if (opts.aspectRatio !== undefined) {\n        if (typeof opts.aspectRatio === 'number') {\n          aspectRatio = opts.aspectRatio;\n        } else if (opts.aspectRatio instanceof Array) {\n          aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];\n        }\n      }\n      var maxSize = null;\n      if (opts.maxSize !== undefined && opts.maxSize !== null) {\n        maxSize = {\n          width: opts.maxSize[0] || null,\n          height: opts.maxSize[1] || null,\n          unit: opts.maxSize[2] || 'px'\n        };\n      }\n      var minSize = null;\n      if (opts.minSize !== undefined && opts.minSize !== null) {\n        minSize = {\n          width: opts.minSize[0] || null,\n          height: opts.minSize[1] || null,\n          unit: opts.minSize[2] || 'px'\n        };\n      }\n      var startSize = null;\n      if (opts.startSize !== undefined && opts.startSize !== null) {\n        startSize = {\n          width: opts.startSize[0] || null,\n          height: opts.startSize[1] || null,\n          unit: opts.startSize[2] || '%'\n        };\n      }\n      var onInitialize = null;\n      if (typeof opts.onInitialize === 'function') {\n        onInitialize = opts.onInitialize;\n      }\n      var onCropStart = null;\n      if (typeof opts.onCropStart === 'function') {\n        onCropStart = opts.onCropStart;\n      }\n      var onCropEnd = null;\n      if (typeof opts.onCropEnd === 'function') {\n        onCropEnd = opts.onCropEnd;\n      }\n      var onCropMove = null;\n      if (typeof opts.onUpdate === 'function') {\n        console.warn('Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.');\n        onCropMove = opts.onUpdate;\n      }\n      if (typeof opts.onCropMove === 'function') {\n        onCropMove = opts.onCropMove;\n      }\n      var returnMode = null;\n      if (opts.returnMode !== undefined) {\n        var s = opts.returnMode.toLowerCase();\n        if (['real', 'ratio', 'raw'].indexOf(s) === -1) {\n          throw \"Invalid return mode.\";\n        }\n        returnMode = s;\n      }\n      var convertToPixels = function convertToPixels(container) {\n        var width = container.offsetWidth;\n        var height = container.offsetHeight;\n        var sizeKeys = ['maxSize', 'minSize', 'startSize'];\n        for (var i = 0; i < sizeKeys.length; i++) {\n          var key = sizeKeys[i];\n          if (this[key] !== null) {\n            if (this[key].unit == '%') {\n              if (this[key].width !== null) {\n                this[key].width = this[key].width / 100 * width;\n              }\n              if (this[key].height !== null) {\n                this[key].height = this[key].height / 100 * height;\n              }\n            }\n            delete this[key].unit;\n          }\n        }\n      };\n      var defaultValue = function defaultValue(v, d) {\n        return v !== null ? v : d;\n      };\n      return {\n        aspectRatio: defaultValue(aspectRatio, defaults$$1.aspectRatio),\n        maxSize: defaultValue(maxSize, defaults$$1.maxSize),\n        minSize: defaultValue(minSize, defaults$$1.minSize),\n        startSize: defaultValue(startSize, defaults$$1.startSize),\n        returnMode: defaultValue(returnMode, defaults$$1.returnMode),\n        onInitialize: defaultValue(onInitialize, defaults$$1.onInitialize),\n        onCropStart: defaultValue(onCropStart, defaults$$1.onCropStart),\n        onCropMove: defaultValue(onCropMove, defaults$$1.onCropMove),\n        onCropEnd: defaultValue(onCropEnd, defaults$$1.onCropEnd),\n        convertToPixels: convertToPixels\n      };\n    }\n  }]);\n  return CropprCore;\n}();\nfunction round(value, decimals) {\n  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);\n}\n\nvar Croppr$1 = function (_CropprCore) {\n  inherits(Croppr, _CropprCore);\n  /**\n   * @constructor\n   * Calls the CropprCore's constructor.\n   */\n  function Croppr(element, options) {\n    var _deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Croppr);\n    return possibleConstructorReturn(this, (Croppr.__proto__ || Object.getPrototypeOf(Croppr)).call(this, element, options, _deferred));\n  }\n  /**\n   * Gets the value of the crop region.\n   * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or\n   *      'raw'.\n   */\n  createClass(Croppr, [{\n    key: 'getValue',\n    value: function getValue(mode) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'getValue', this).call(this, mode);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'setImage', this).call(this, src);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'destroy', this).call(this);\n    }\n    /**\n     * Moves the crop region to a specified coordinate.\n     * @param {Number} x\n     * @param {Number} y\n     */\n  }, {\n    key: 'moveTo',\n    value: function moveTo(x, y) {\n      this.box.move(x, y);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Resizes the crop region to a specified width and height.\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'resizeTo',\n    value: function resizeTo(width, height) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [.5, .5];\n      this.box.resize(width, height, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Scale the crop region by a factor.\n     * @param {Number} factor\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'scaleBy',\n    value: function scaleBy(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [.5, .5];\n      this.box.scale(factor, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }]);\n  return Croppr;\n}(CropprCore);\n\nreturn Croppr$1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL2Rpc3QvY3JvcHByLmpzPzc1ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQzJCO0FBQzVCLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQXFEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRTtBQUN6bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QyxrQkFBa0IsNEJBQTRCO0FBQzlDLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3Bwci9kaXN0L2Nyb3Bwci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JvcHByLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFtZXNzc29vaS9Dcm9wcHIuanNcbiAqIFxuICogQSBKYXZhU2NyaXB0IGltYWdlIGNyb3BwZXIgdGhhdCdzIGxpZ2h0d2VpZ2h0LCBhd2Vzb21lLCBhbmQgaGFzXG4gKiB6ZXJvIGRlcGVuZGVuY2llcy5cbiAqIFxuICogKEMpIDIwMTcgSmFtZXMgT29pLiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkNyb3BwciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RUaW1lID0gMDtcbiAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG59KSgpO1xuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VzdG9tRXZlbnQoJ3Rlc3QnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGZ1bmN0aW9uIE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfTtcbiAgICB2YXIgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgbW91c2VFdmVudC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cbiAgTW91c2VFdmVudC5wcm90b3R5cGUgPSBFdmVudC5wcm90b3R5cGU7XG4gIHdpbmRvdy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcbn0pKHdpbmRvdyk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgSGFuZGxlID1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBIYW5kbGUgaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9uIFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGVcbiAqICAgICAgd2l0aGluIHRoZSBjcm9wIHJlZ2lvbi4gQWNjZXB0cyBhIHZhbHVlIGJldHdlZW4gMCB0byAxIGluIHRoZSBvcmRlclxuICogICAgICBvZiBbWCwgWV0uXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50cyBEZWZpbmUgdGhlIHNpZGUgb2YgdGhlIGNyb3AgcmVnaW9uIHRoYXRcbiAqICAgICAgaXMgdG8gYmUgYWZmZWN0ZWQgYnkgdGhpcyBoYW5kbGUuIEFjY2VwdHMgYSB2YWx1ZSBvZiAwIG9yIDEgaW4gdGhlXG4gKiAgICAgIG9yZGVyIG9mIFtUT1AsIFJJR0hULCBCT1RUT00sIExFRlRdLlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnNvciBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZXZlbnRCdXMgVGhlIGVsZW1lbnQgdG8gZGlzcGF0Y2ggZXZlbnRzIHRvLlxuICovXG5mdW5jdGlvbiBIYW5kbGUocG9zaXRpb24sIGNvbnN0cmFpbnRzLCBjdXJzb3IsIGV2ZW50QnVzKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSAnY3JvcHByLWhhbmRsZSc7XG4gIHRoaXMuZWwuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZXN0YXJ0Jywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZW1vdmUnLCB7XG4gICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICB9KSk7XG4gIH1cbn07XG5cbnZhciBCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEJveCBpbnN0YW5jZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgZnVuY3Rpb24gQm94KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5ldyBkaW1lbnNpb25zIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCQkMSgpIHtcbiAgICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRoaXMueDEgPSB4MSA9PSBudWxsID8gdGhpcy54MSA6IHgxO1xuICAgICAgdGhpcy55MSA9IHkxID09IG51bGwgPyB0aGlzLnkxIDogeTE7XG4gICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gdGhpcy55MiA6IHkyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBib3guXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3dpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgYm94IHRvIGEgbmV3IHNpemUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbMCwgMF07XG4gICAgICB2YXIgZnJvbVggPSB0aGlzLngxICsgdGhpcy53aWR0aCgpICogb3JpZ2luWzBdO1xuICAgICAgdmFyIGZyb21ZID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBvcmlnaW5bMV07XG4gICAgICB0aGlzLngxID0gZnJvbVggLSBuZXdXaWR0aCAqIG9yaWdpblswXTtcbiAgICAgIHRoaXMueTEgPSBmcm9tWSAtIG5ld0hlaWdodCAqIG9yaWdpblsxXTtcbiAgICAgIHRoaXMueDIgPSB0aGlzLngxICsgbmV3V2lkdGg7XG4gICAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgYm94IGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlKGZhY3Rvcikge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzAsIDBdO1xuICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy53aWR0aCgpICogZmFjdG9yO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0KCkgKiBmYWN0b3I7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICB4ID0geCA9PT0gbnVsbCA/IHRoaXMueDEgOiB4O1xuICAgICAgeSA9IHkgPT09IG51bGwgPyB0aGlzLnkxIDogeTtcbiAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgdGhpcy55MSA9IHk7XG4gICAgICB0aGlzLngyID0geCArIHdpZHRoO1xuICAgICAgdGhpcy55MiA9IHkgKyBoZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlbGF0aXZlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgYSBnaXZlbiBwb2ludCB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIFt4LCB5XS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldFJlbGF0aXZlUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvaW50KCkge1xuICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbMCwgMF07XG4gICAgICB2YXIgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50IFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgW3gsIHldLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0QWJzb2x1dGVQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFic29sdXRlUG9pbnQoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFswLCAwXTtcbiAgICAgIHZhciB4ID0gdGhpcy54MSArIHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLnkxICsgdGhpcy5oZWlnaHQoKSAqIHBvaW50WzFdO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBmaXhlZCByYXRpby5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3ddIFRoZSBheGlzIHRvIGdyb3cgdG8gbWFpbnRhaW4gdGhlIHJhdGlvLlxuICAgICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbnN0cmFpblRvUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1JhdGlvKHJhdGlvKSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMCwgMF07XG4gICAgICB2YXIgZ3JvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2hlaWdodCc7XG4gICAgICBpZiAocmF0aW8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICBzd2l0Y2ggKGdyb3cpIHtcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbiB0aGUgYm94IHdpdGhpbiBhIGJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJvdW5kYXJ5SGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub0JvdW5kYXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3RyYWluVG9Cb3VuZGFyeShib3VuZGFyeVdpZHRoLCBib3VuZGFyeUhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWzAsIDBdO1xuICAgICAgdmFyIF9nZXRBYnNvbHV0ZVBvaW50ID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbiksXG4gICAgICAgICAgX2dldEFic29sdXRlUG9pbnQyID0gc2xpY2VkVG9BcnJheShfZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9nZXRBYnNvbHV0ZVBvaW50MlswXSxcbiAgICAgICAgICBvcmlnaW5ZID0gX2dldEFic29sdXRlUG9pbnQyWzFdO1xuICAgICAgdmFyIG1heElmTGVmdCA9IG9yaWdpblg7XG4gICAgICB2YXIgbWF4SWZUb3AgPSBvcmlnaW5ZO1xuICAgICAgdmFyIG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWDtcbiAgICAgIHZhciBtYXhJZkJvdHRvbSA9IGJvdW5kYXJ5SGVpZ2h0IC0gb3JpZ2luWTtcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gLTIgKiBvcmlnaW5bMF0gKyAxO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSAtMiAqIG9yaWdpblsxXSArIDE7XG4gICAgICB2YXIgbWF4V2lkdGggPSBudWxsLFxuICAgICAgICAgIG1heEhlaWdodCA9IG51bGw7XG4gICAgICBzd2l0Y2ggKGRpcmVjdGlvblgpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBtYXhXaWR0aCA9IG1heElmTGVmdDticmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4SWZMZWZ0LCBtYXhJZlJpZ2h0KSAqIDI7YnJlYWs7XG4gICAgICAgIGNhc2UgKzE6XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhJZlJpZ2h0O2JyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkaXJlY3Rpb25ZKSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4SWZUb3A7YnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjticmVhaztcbiAgICAgICAgY2FzZSArMTpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTticmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICAgIHRoaXMuc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgdmFyIF9mYWN0b3IgPSBtYXhIZWlnaHQgLyB0aGlzLmhlaWdodCgpO1xuICAgICAgICB0aGlzLnNjYWxlKF9mYWN0b3IsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBtYXhpbXVtL21pbmltdW0gc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4SGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluV2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub1NpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1NpemUoKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIG1pbldpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbkhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFswLCAwXTtcbiAgICAgIHZhciByYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAgIGlmIChyYXRpbykge1xuICAgICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhIZWlnaHQgKiAxIC8gcmF0aW87XG4gICAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAocmF0aW8gPCAxKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4V2lkdGggKiByYXRpbztcbiAgICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFdpZHRoICYmIHRoaXMud2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IG1heFdpZHRoLFxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmF0aW8gPT09IG51bGwgPyB0aGlzLmhlaWdodCgpIDogbWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1heFdpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoLCBfbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGgyID0gbWluV2lkdGgsXG4gICAgICAgICAgICBfbmV3SGVpZ2h0MiA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1pbkhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoMiwgX25ld0hlaWdodDIsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICBpZiAobWluSGVpZ2h0ICYmIHRoaXMuaGVpZ2h0KCkgPCBtaW5IZWlnaHQpIHtcbiAgICAgICAgdmFyIF9uZXdXaWR0aDMgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodDMgPSBtaW5IZWlnaHQ7XG4gICAgICAgIHRoaXMucmVzaXplKF9uZXdXaWR0aDMsIF9uZXdIZWlnaHQzLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbi8qKlxuICogQmluZHMgYW4gZWxlbWVudCdzIHRvdWNoIGV2ZW50cyB0byBiZSBzaW11bGF0ZWQgYXMgbW91c2UgZXZlbnRzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZVRvdWNoKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHNpbXVsYXRlTW91c2VFdmVudCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbn1cbi8qKlxuICogVHJhbnNsYXRlcyBhIHRvdWNoIGV2ZW50IHRvIGEgbW91c2UgZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBlXG4gKi9cbmZ1bmN0aW9uIHNpbXVsYXRlTW91c2VFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgdmFyIGV2ZW50TWFwID0ge1xuICAgICd0b3VjaHN0YXJ0JzogJ21vdXNlZG93bicsXG4gICAgJ3RvdWNobW92ZSc6ICdtb3VzZW1vdmUnLFxuICAgICd0b3VjaGVuZCc6ICdtb3VzZXVwJ1xuICB9O1xuICB0b3VjaC50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldmVudE1hcFtlLnR5cGVdLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIHZpZXc6IHdpbmRvdyxcbiAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgc2NyZWVuWDogdG91Y2guc2NyZWVuWCxcbiAgICBzY3JlZW5ZOiB0b3VjaC5zY3JlZW5ZXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBsaXN0IG9mIGhhbmRsZXMgdG8gY3JlYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBvc2l0aW9uIC0gVGhlIHggYW5kIHkgcmF0aW8gcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW5cbiAqICAgICAgdGhlIGNyb3AgcmVnaW9uLiBBY2NlcHRzIGEgdmFsdWUgYmV0d2VlbiAwIHRvIDEgaW4gdGhlIG9yZGVyIG9mIFtYLCBZXS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnN0cmFpbnRzIC0gRGVmaW5lIHRoZSBzaWRlIG9mIHRoZSBjcm9wIHJlZ2lvbiB0aGF0IGlzIHRvXG4gKiAgICAgIGJlIGFmZmVjdGVkIGJ5IHRoaXMgaGFuZGxlLiBBY2NlcHRzIGEgdmFsdWUgb2YgMCBvciAxIGluIHRoZSBvcmRlciBvZlxuICogICAgICBbVE9QLCBSSUdIVCwgQk9UVE9NLCBMRUZUXS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjdXJzb3IgLSBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqL1xudmFyIEhBTkRMRVMgPSBbeyBwb3NpdGlvbjogWzAuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAwLCAwLCAxXSwgY3Vyc29yOiAnbnctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAwLjBdLCBjb25zdHJhaW50czogWzEsIDAsIDAsIDBdLCBjdXJzb3I6ICduLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAxLCAwLCAwXSwgY3Vyc29yOiAnbmUtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMS4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDEsIDAsIDBdLCBjdXJzb3I6ICdlLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAxLCAxLCAwXSwgY3Vyc29yOiAnc2UtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAxLjBdLCBjb25zdHJhaW50czogWzAsIDAsIDEsIDBdLCBjdXJzb3I6ICdzLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzAuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAwLCAxLCAxXSwgY3Vyc29yOiAnc3ctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDAsIDAsIDFdLCBjdXJzb3I6ICd3LXJlc2l6ZScgfV07XG52YXIgQ3JvcHByQ29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3JvcHByQ29yZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwckNvcmUpO1xuICAgIHRoaXMub3B0aW9ucyA9IENyb3BwckNvcmUucGFyc2VPcHRpb25zKG9wdGlvbnMgfHwge30pO1xuICAgIGlmICghZWxlbWVudC5ub2RlTmFtZSkge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICdVbmFibGUgdG8gZmluZCBlbGVtZW50Lic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICB0aHJvdyAnSW1hZ2Ugc3JjIG5vdCBwcm92aWRlZC4nO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc3RvcmUgPSB7XG4gICAgICBwYXJlbnQ6IGVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICB9O1xuICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgIGlmIChlbGVtZW50LndpZHRoID09PSAwIHx8IGVsZW1lbnQuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNsYXNzKENyb3BwckNvcmUsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jcmVhdGVET00oZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMuY29udmVydFRvUGl4ZWxzKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRoaXMuYXR0YWNoSGFuZGxlckV2ZW50cygpO1xuICAgICAgdGhpcy5hdHRhY2hSZWdpb25FdmVudHMoKTtcbiAgICAgIHRoaXMuYXR0YWNoT3ZlcmxheUV2ZW50cygpO1xuICAgICAgdGhpcy5ib3ggPSB0aGlzLmluaXRpYWxpemVCb3godGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5pdGlhbGl6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Jbml0aWFsaXplKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZURPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURPTSh0YXJnZXRFbCkge1xuICAgICAgdGhpcy5jb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc05hbWUgPSAnY3JvcHByLWNvbnRhaW5lcic7XG4gICAgICB0aGlzLmV2ZW50QnVzID0gdGhpcy5jb250YWluZXJFbDtcbiAgICAgIGVuYWJsZVRvdWNoKHRoaXMuY29udGFpbmVyRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmNsYXNzTmFtZSA9ICdjcm9wcHInO1xuICAgICAgdGhpcy5pbWFnZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB0aGlzLmltYWdlRWwuc2V0QXR0cmlidXRlKCdzcmMnLCB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpKTtcbiAgICAgIHRoaXMuaW1hZ2VFbC5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRhcmdldEVsLmdldEF0dHJpYnV0ZSgnYWx0JykpO1xuICAgICAgdGhpcy5pbWFnZUVsLmNsYXNzTmFtZSA9ICdjcm9wcHItaW1hZ2UnO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbCA9IHRoaXMuaW1hZ2VFbC5jbG9uZU5vZGUoKTtcbiAgICAgIHRoaXMuaW1hZ2VDbGlwcGVkRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1pbWFnZUNsaXBwZWQnO1xuICAgICAgdGhpcy5yZWdpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5yZWdpb25FbC5jbGFzc05hbWUgPSAnY3JvcHByLXJlZ2lvbic7XG4gICAgICB0aGlzLm92ZXJsYXlFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vdmVybGF5RWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1vdmVybGF5JztcbiAgICAgIHZhciBoYW5kbGVDb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaGFuZGxlQ29udGFpbmVyRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1oYW5kbGVDb250YWluZXInO1xuICAgICAgdGhpcy5oYW5kbGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhBTkRMRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyBIYW5kbGUoSEFORExFU1tpXS5wb3NpdGlvbiwgSEFORExFU1tpXS5jb25zdHJhaW50cywgSEFORExFU1tpXS5jdXJzb3IsIHRoaXMuZXZlbnRCdXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgICAgICBoYW5kbGVDb250YWluZXJFbC5hcHBlbmRDaGlsZChoYW5kbGUuZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VDbGlwcGVkRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5yZWdpb25FbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlFbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZChoYW5kbGVDb250YWluZXJFbCk7XG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRhcmdldEVsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHRoaXMuY29udGFpbmVyRWwsIHRhcmdldEVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuaW1hZ2VFbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5ib3ggPSBfdGhpczIuaW5pdGlhbGl6ZUJveChfdGhpczIub3B0aW9ucyk7XG4gICAgICAgIF90aGlzMi5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmltYWdlRWwuc3JjID0gc3JjO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbC5zcmMgPSBzcmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmUucGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLl9yZXN0b3JlLmVsZW1lbnQsIHRoaXMuY29udGFpbmVyRWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYm94IHJlZ2lvbiB3aXRoIGEgc2V0IG9mIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge0JveH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQm94KG9wdHMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdHMuc3RhcnRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IG9wdHMuc3RhcnRTaXplLmhlaWdodDtcbiAgICAgIHZhciBib3ggPSBuZXcgQm94KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYm94LmNvbnN0cmFpblRvUmF0aW8ob3B0cy5hc3BlY3RSYXRpbywgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgbWluID0gb3B0cy5taW5TaXplO1xuICAgICAgdmFyIG1heCA9IG9wdHMubWF4U2l6ZTtcbiAgICAgIGJveC5jb25zdHJhaW5Ub1NpemUobWF4LndpZHRoLCBtYXguaGVpZ2h0LCBtaW4ud2lkdGgsIG1pbi5oZWlnaHQsIFswLjUsIDAuNV0sIG9wdHMuYXNwZWN0UmF0aW8pO1xuICAgICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgcGFyZW50SGVpZ2h0ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgYm94LmNvbnN0cmFpblRvQm91bmRhcnkocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgeCA9IHRoaXMuY3JvcHBlckVsLm9mZnNldFdpZHRoIC8gMiAtIGJveC53aWR0aCgpIC8gMjtcbiAgICAgIHZhciB5ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0IC8gMiAtIGJveC5oZWlnaHQoKSAvIDI7XG4gICAgICBib3gubW92ZSh4LCB5KTtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuYm94LndpZHRoKCkpLFxuICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpLFxuICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh0aGlzLmJveC54MSksXG4gICAgICAgICAgeTEgPSBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB4MiA9IE1hdGgucm91bmQodGhpcy5ib3gueDIpLFxuICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh0aGlzLmJveC55Mik7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHgxICsgJ3B4LCAnICsgeTEgKyAncHgpJztcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBfdGhpczMucmVnaW9uRWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgX3RoaXMzLmltYWdlQ2xpcHBlZEVsLnN0eWxlLmNsaXAgPSAncmVjdCgnICsgeTEgKyAncHgsICcgKyB4MiArICdweCwgJyArIHkyICsgJ3B4LCAnICsgeDEgKyAncHgpJztcbiAgICAgICAgdmFyIGNlbnRlciA9IF90aGlzMy5ib3guZ2V0QWJzb2x1dGVQb2ludChbLjUsIC41XSk7XG4gICAgICAgIHZhciB4U2lnbiA9IGNlbnRlclswXSAtIF90aGlzMy5jcm9wcGVyRWwub2Zmc2V0V2lkdGggLyAyID4+IDMxO1xuICAgICAgICB2YXIgeVNpZ24gPSBjZW50ZXJbMV0gLSBfdGhpczMuY3JvcHBlckVsLm9mZnNldEhlaWdodCAvIDIgPj4gMzE7XG4gICAgICAgIHZhciBxdWFkcmFudCA9ICh4U2lnbiBeIHlTaWduKSArIHlTaWduICsgeVNpZ24gKyA0O1xuICAgICAgICB2YXIgZm9yZWdyb3VuZEhhbmRsZUluZGV4ID0gLTIgKiBxdWFkcmFudCArIDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaGFuZGxlID0gX3RoaXMzLmhhbmRsZXNbaV07XG4gICAgICAgICAgdmFyIGhhbmRsZVdpZHRoID0gaGFuZGxlLmVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIHZhciBoYW5kbGVIZWlnaHQgPSBoYW5kbGUuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHZhciBsZWZ0ID0geDEgKyB3aWR0aCAqIGhhbmRsZS5wb3NpdGlvblswXSAtIGhhbmRsZVdpZHRoIC8gMjtcbiAgICAgICAgICB2YXIgdG9wID0geTEgKyBoZWlnaHQgKiBoYW5kbGUucG9zaXRpb25bMV0gLSBoYW5kbGVIZWlnaHQgLyAyO1xuICAgICAgICAgIGhhbmRsZS5lbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBNYXRoLnJvdW5kKGxlZnQpICsgJ3B4LCAnICsgTWF0aC5yb3VuZCh0b3ApICsgJ3B4KSc7XG4gICAgICAgICAgaGFuZGxlLmVsLnN0eWxlLnpJbmRleCA9IGZvcmVncm91bmRIYW5kbGVJbmRleCA9PSBpID8gNSA6IDQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaEhhbmRsZXJFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hIYW5kbGVyRXZlbnRzKCkge1xuICAgICAgdmFyIGV2ZW50QnVzID0gdGhpcy5ldmVudEJ1cztcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZXN0YXJ0JywgdGhpcy5vbkhhbmRsZU1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZW1vdmUnLCB0aGlzLm9uSGFuZGxlTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZWVuZCcsIHRoaXMub25IYW5kbGVNb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaFJlZ2lvbkV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaFJlZ2lvbkV2ZW50cygpIHtcbiAgICAgIHZhciBldmVudEJ1cyA9IHRoaXMuZXZlbnRCdXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlZ2lvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbnN0YXJ0JywgdGhpcy5vblJlZ2lvbk1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbm1vdmUnLCB0aGlzLm9uUmVnaW9uTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbmVuZCcsIHRoaXMub25SZWdpb25Nb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgICBldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVnaW9uc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZ2lvbm1vdmUnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIGV2ZW50QnVzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyZWdpb25lbmQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2hPdmVybGF5RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoT3ZlcmxheUV2ZW50cygpIHtcbiAgICAgIHZhciBTT1VUSEVBU1RfSEFORExFX0lEWCA9IDQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG1wQm94ID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuY3JvcHBlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgbW91c2VYID0gZS5jbGllbnRYIC0gY29udGFpbmVyLmxlZnQ7XG4gICAgICAgIHZhciBtb3VzZVkgPSBlLmNsaWVudFkgLSBjb250YWluZXIudG9wO1xuICAgICAgICB0bXBCb3ggPSBzZWxmLmJveDtcbiAgICAgICAgc2VsZi5ib3ggPSBuZXcgQm94KG1vdXNlWCwgbW91c2VZLCBtb3VzZVggKyAxLCBtb3VzZVkgKyAxKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZi5oYW5kbGVzW1NPVVRIRUFTVF9IQU5ETEVfSURYXSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlbW92ZScsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgaWYgKHNlbGYuYm94LndpZHRoKCkgPT09IDEgJiYgc2VsZi5ib3guaGVpZ2h0KCkgPT09IDEpIHtcbiAgICAgICAgICBzZWxmLmJveCA9IHRtcEJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgICAgIGRldGFpbDogeyBtb3VzZVg6IGUuY2xpZW50WCwgbW91c2VZOiBlLmNsaWVudFkgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVTdGFydChlKSB7XG4gICAgICB2YXIgaGFuZGxlID0gZS5kZXRhaWwuaGFuZGxlO1xuICAgICAgdmFyIG9yaWdpblBvaW50ID0gWzEgLSBoYW5kbGUucG9zaXRpb25bMF0sIDEgLSBoYW5kbGUucG9zaXRpb25bMV1dO1xuICAgICAgdmFyIF9ib3gkZ2V0QWJzb2x1dGVQb2ludCA9IHRoaXMuYm94LmdldEFic29sdXRlUG9pbnQob3JpZ2luUG9pbnQpLFxuICAgICAgICAgIF9ib3gkZ2V0QWJzb2x1dGVQb2ludDIgPSBzbGljZWRUb0FycmF5KF9ib3gkZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMF0sXG4gICAgICAgICAgb3JpZ2luWSA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMV07XG4gICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IHsgaGFuZGxlOiBoYW5kbGUsIG9yaWdpblBvaW50OiBvcmlnaW5Qb2ludCwgb3JpZ2luWDogb3JpZ2luWCwgb3JpZ2luWTogb3JpZ2luWSB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wU3RhcnQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkhhbmRsZU1vdmVNb3ZpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVNb3ZpbmcoZSkge1xuICAgICAgdmFyIF9lJGRldGFpbCA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbC5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsLm1vdXNlWTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIGlmIChtb3VzZVggPCAwKSB7XG4gICAgICAgIG1vdXNlWCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlWCA+IGNvbnRhaW5lci53aWR0aCkge1xuICAgICAgICBtb3VzZVggPSBjb250YWluZXIud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VZIDwgMCkge1xuICAgICAgICBtb3VzZVkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZVkgPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgIG1vdXNlWSA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luUG9pbnQuc2xpY2UoKTtcbiAgICAgIHZhciBvcmlnaW5YID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWDtcbiAgICAgIHZhciBvcmlnaW5ZID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWTtcbiAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmFjdGl2ZUhhbmRsZS5oYW5kbGU7XG4gICAgICB2YXIgVE9QX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbMF0gPT09IDE7XG4gICAgICB2YXIgUklHSFRfTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1sxXSA9PT0gMTtcbiAgICAgIHZhciBCT1RUT01fTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1syXSA9PT0gMTtcbiAgICAgIHZhciBMRUZUX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbM10gPT09IDE7XG4gICAgICB2YXIgTVVMVElfQVhJUyA9IChMRUZUX01PVkFCTEUgfHwgUklHSFRfTU9WQUJMRSkgJiYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKTtcbiAgICAgIHZhciB4MSA9IExFRlRfTU9WQUJMRSB8fCBSSUdIVF9NT1ZBQkxFID8gb3JpZ2luWCA6IHRoaXMuYm94LngxO1xuICAgICAgdmFyIHgyID0gTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUgPyBvcmlnaW5YIDogdGhpcy5ib3gueDI7XG4gICAgICB2YXIgeTEgPSBUT1BfTU9WQUJMRSB8fCBCT1RUT01fTU9WQUJMRSA/IG9yaWdpblkgOiB0aGlzLmJveC55MTtcbiAgICAgIHZhciB5MiA9IFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFID8gb3JpZ2luWSA6IHRoaXMuYm94LnkyO1xuICAgICAgeDEgPSBMRUZUX01PVkFCTEUgPyBtb3VzZVggOiB4MTtcbiAgICAgIHgyID0gUklHSFRfTU9WQUJMRSA/IG1vdXNlWCA6IHgyO1xuICAgICAgeTEgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA6IHkxO1xuICAgICAgeTIgPSBCT1RUT01fTU9WQUJMRSA/IG1vdXNlWSA6IHkyO1xuICAgICAgdmFyIGlzRmxpcHBlZFggPSBmYWxzZSxcbiAgICAgICAgICBpc0ZsaXBwZWRZID0gZmFsc2U7XG4gICAgICBpZiAoTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUpIHtcbiAgICAgICAgaXNGbGlwcGVkWCA9IExFRlRfTU9WQUJMRSA/IG1vdXNlWCA+IG9yaWdpblggOiBtb3VzZVggPCBvcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKSB7XG4gICAgICAgIGlzRmxpcHBlZFkgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA+IG9yaWdpblkgOiBtb3VzZVkgPCBvcmlnaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmxpcHBlZFgpIHtcbiAgICAgICAgdmFyIHRtcCA9IHgxO3gxID0geDI7eDIgPSB0bXA7XG4gICAgICAgIG9yaWdpblswXSA9IDEgLSBvcmlnaW5bMF07XG4gICAgICB9XG4gICAgICBpZiAoaXNGbGlwcGVkWSkge1xuICAgICAgICB2YXIgX3RtcCA9IHkxO3kxID0geTI7eTIgPSBfdG1wO1xuICAgICAgICBvcmlnaW5bMV0gPSAxIC0gb3JpZ2luWzFdO1xuICAgICAgfVxuICAgICAgdmFyIGJveCA9IG5ldyBCb3goeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbykge1xuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKE1VTFRJX0FYSVMpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBtb3VzZVkgPiBib3gueTEgKyByYXRpbyAqIGJveC53aWR0aCgpIHx8IG1vdXNlWSA8IGJveC55MiAtIHJhdGlvICogYm94LndpZHRoKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoVE9QX01PVkFCTEUgfHwgQk9UVE9NX01PVkFCTEUpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXRpb01vZGUgPSBpc1ZlcnRpY2FsTW92ZW1lbnQgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGJveC5jb25zdHJhaW5Ub1JhdGlvKHJhdGlvLCBvcmlnaW4sIHJhdGlvTW9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pblNpemU7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5vcHRpb25zLm1heFNpemU7XG4gICAgICBib3guY29uc3RyYWluVG9TaXplKG1heC53aWR0aCwgbWF4LmhlaWdodCwgbWluLndpZHRoLCBtaW4uaGVpZ2h0LCBvcmlnaW4sIHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBwYXJlbnRIZWlnaHQgPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBib3guY29uc3RyYWluVG9Cb3VuZGFyeShwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgdGhpcy5ib3ggPSBib3g7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IYW5kbGVNb3ZlRW5kKGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblJlZ2lvbk1vdmVTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZVN0YXJ0KGUpIHtcbiAgICAgIHZhciBfZSRkZXRhaWwyID0gZS5kZXRhaWwsXG4gICAgICAgICAgbW91c2VYID0gX2UkZGV0YWlsMi5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsMi5tb3VzZVk7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jcm9wcGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBtb3VzZVggPSBtb3VzZVggLSBjb250YWluZXIubGVmdDtcbiAgICAgIG1vdXNlWSA9IG1vdXNlWSAtIGNvbnRhaW5lci50b3A7XG4gICAgICB0aGlzLmN1cnJlbnRNb3ZlID0ge1xuICAgICAgICBvZmZzZXRYOiBtb3VzZVggLSB0aGlzLmJveC54MSxcbiAgICAgICAgb2Zmc2V0WTogbW91c2VZIC0gdGhpcy5ib3gueTFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcFN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZU1vdmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZU1vdmluZyhlKSB7XG4gICAgICB2YXIgX2UkZGV0YWlsMyA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbDMubW91c2VYLFxuICAgICAgICAgIG1vdXNlWSA9IF9lJGRldGFpbDMubW91c2VZO1xuICAgICAgdmFyIF9jdXJyZW50TW92ZSA9IHRoaXMuY3VycmVudE1vdmUsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9jdXJyZW50TW92ZS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfY3VycmVudE1vdmUub2Zmc2V0WTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIHRoaXMuYm94Lm1vdmUobW91c2VYIC0gb2Zmc2V0WCwgbW91c2VZIC0gb2Zmc2V0WSk7XG4gICAgICBpZiAodGhpcy5ib3gueDEgPCAwKSB7XG4gICAgICAgIHRoaXMuYm94Lm1vdmUoMCwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib3gueDIgPiBjb250YWluZXIud2lkdGgpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShjb250YWluZXIud2lkdGggLSB0aGlzLmJveC53aWR0aCgpLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MSA8IDApIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MiA+IGNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCBjb250YWluZXIuaGVpZ2h0IC0gdGhpcy5ib3guaGVpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZUVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZUVuZChlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgaWYgKG1vZGUgPT09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IHRoaXMub3B0aW9ucy5yZXR1cm5Nb2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUgPT0gJ3JlYWwnKSB7XG4gICAgICAgIHZhciBhY3R1YWxXaWR0aCA9IHRoaXMuaW1hZ2VFbC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSB0aGlzLmltYWdlRWwubmF0dXJhbEhlaWdodDtcbiAgICAgICAgdmFyIF9pbWFnZUVsJGdldEJvdW5kaW5nQyA9IHRoaXMuaW1hZ2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQy53aWR0aCxcbiAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MuaGVpZ2h0O1xuICAgICAgICB2YXIgZmFjdG9yWCA9IGFjdHVhbFdpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICB2YXIgZmFjdG9yWSA9IGFjdHVhbEhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJveC54MSAqIGZhY3RvclgpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib3gueTEgKiBmYWN0b3JZKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpICogZmFjdG9yWCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuYm94LmhlaWdodCgpICogZmFjdG9yWSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAncmF0aW8nKSB7XG4gICAgICAgIHZhciBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MyID0gdGhpcy5pbWFnZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgX2VsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIud2lkdGgsXG4gICAgICAgICAgICBfZWxlbWVudEhlaWdodCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIuaGVpZ2h0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJvdW5kKHRoaXMuYm94LngxIC8gX2VsZW1lbnRXaWR0aCwgMyksXG4gICAgICAgICAgeTogcm91bmQodGhpcy5ib3gueTEgLyBfZWxlbWVudEhlaWdodCwgMyksXG4gICAgICAgICAgd2lkdGg6IHJvdW5kKHRoaXMuYm94LndpZHRoKCkgLyBfZWxlbWVudFdpZHRoLCAzKSxcbiAgICAgICAgICBoZWlnaHQ6IHJvdW5kKHRoaXMuYm94LmhlaWdodCgpIC8gX2VsZW1lbnRIZWlnaHQsIDMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3JhdycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKHRoaXMuYm94LngxKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0cykge1xuICAgICAgdmFyIGRlZmF1bHRzJCQxID0ge1xuICAgICAgICBhc3BlY3RSYXRpbzogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsIH0sXG4gICAgICAgIG1pblNpemU6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9LFxuICAgICAgICBzdGFydFNpemU6IHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAsIHVuaXQ6ICclJyB9LFxuICAgICAgICByZXR1cm5Nb2RlOiAncmVhbCcsXG4gICAgICAgIG9uSW5pdGlhbGl6ZTogbnVsbCxcbiAgICAgICAgb25Dcm9wU3RhcnQ6IG51bGwsXG4gICAgICAgIG9uQ3JvcE1vdmU6IG51bGwsXG4gICAgICAgIG9uQ3JvcEVuZDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgICBpZiAob3B0cy5hc3BlY3RSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5hc3BlY3RSYXRpbyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbyA9IG9wdHMuYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5hc3BlY3RSYXRpbyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBvcHRzLmFzcGVjdFJhdGlvWzFdIC8gb3B0cy5hc3BlY3RSYXRpb1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1heFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMubWF4U2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9wdHMubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICBtYXhTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLm1heFNpemVbMF0gfHwgbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG9wdHMubWF4U2l6ZVsxXSB8fCBudWxsLFxuICAgICAgICAgIHVuaXQ6IG9wdHMubWF4U2l6ZVsyXSB8fCAncHgnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbWluU2l6ZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5taW5TaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgIG1pblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IG9wdHMubWluU2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5taW5TaXplWzFdIHx8IG51bGwsXG4gICAgICAgICAgdW5pdDogb3B0cy5taW5TaXplWzJdIHx8ICdweCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMuc3RhcnRTaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5zdGFydFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLnN0YXJ0U2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5zdGFydFNpemVbMV0gfHwgbnVsbCxcbiAgICAgICAgICB1bml0OiBvcHRzLnN0YXJ0U2l6ZVsyXSB8fCAnJSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkluaXRpYWxpemUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uSW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkluaXRpYWxpemUgPSBvcHRzLm9uSW5pdGlhbGl6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkNyb3BTdGFydCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Dcm9wU3RhcnQgPSBvcHRzLm9uQ3JvcFN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcEVuZCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcEVuZCA9IG9wdHMub25Dcm9wRW5kO1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcE1vdmUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ3JvcHByLmpzOiBgb25VcGRhdGVgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIGBvbkNyb3BNb3ZlYCBvciBgb25Dcm9wRW5kYCBpbnN0ZWFkLicpO1xuICAgICAgICBvbkNyb3BNb3ZlID0gb3B0cy5vblVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkNyb3BNb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcE1vdmUgPSBvcHRzLm9uQ3JvcE1vdmU7XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuTW9kZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5yZXR1cm5Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBvcHRzLnJldHVybk1vZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFsncmVhbCcsICdyYXRpbycsICdyYXcnXS5pbmRleE9mKHMpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCByZXR1cm4gbW9kZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5Nb2RlID0gcztcbiAgICAgIH1cbiAgICAgIHZhciBjb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbiBjb252ZXJ0VG9QaXhlbHMoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBzaXplS2V5cyA9IFsnbWF4U2l6ZScsICdtaW5TaXplJywgJ3N0YXJ0U2l6ZSddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHNpemVLZXlzW2ldO1xuICAgICAgICAgIGlmICh0aGlzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0udW5pdCA9PSAnJScpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XS53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XS53aWR0aCA9IHRoaXNba2V5XS53aWR0aCAvIDEwMCAqIHdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzW2tleV0uaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldLmhlaWdodCA9IHRoaXNba2V5XS5oZWlnaHQgLyAxMDAgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV0udW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYgIT09IG51bGwgPyB2IDogZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3BlY3RSYXRpbzogZGVmYXVsdFZhbHVlKGFzcGVjdFJhdGlvLCBkZWZhdWx0cyQkMS5hc3BlY3RSYXRpbyksXG4gICAgICAgIG1heFNpemU6IGRlZmF1bHRWYWx1ZShtYXhTaXplLCBkZWZhdWx0cyQkMS5tYXhTaXplKSxcbiAgICAgICAgbWluU2l6ZTogZGVmYXVsdFZhbHVlKG1pblNpemUsIGRlZmF1bHRzJCQxLm1pblNpemUpLFxuICAgICAgICBzdGFydFNpemU6IGRlZmF1bHRWYWx1ZShzdGFydFNpemUsIGRlZmF1bHRzJCQxLnN0YXJ0U2l6ZSksXG4gICAgICAgIHJldHVybk1vZGU6IGRlZmF1bHRWYWx1ZShyZXR1cm5Nb2RlLCBkZWZhdWx0cyQkMS5yZXR1cm5Nb2RlKSxcbiAgICAgICAgb25Jbml0aWFsaXplOiBkZWZhdWx0VmFsdWUob25Jbml0aWFsaXplLCBkZWZhdWx0cyQkMS5vbkluaXRpYWxpemUpLFxuICAgICAgICBvbkNyb3BTdGFydDogZGVmYXVsdFZhbHVlKG9uQ3JvcFN0YXJ0LCBkZWZhdWx0cyQkMS5vbkNyb3BTdGFydCksXG4gICAgICAgIG9uQ3JvcE1vdmU6IGRlZmF1bHRWYWx1ZShvbkNyb3BNb3ZlLCBkZWZhdWx0cyQkMS5vbkNyb3BNb3ZlKSxcbiAgICAgICAgb25Dcm9wRW5kOiBkZWZhdWx0VmFsdWUob25Dcm9wRW5kLCBkZWZhdWx0cyQkMS5vbkNyb3BFbmQpLFxuICAgICAgICBjb252ZXJ0VG9QaXhlbHM6IGNvbnZlcnRUb1BpeGVsc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3BwckNvcmU7XG59KCk7XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbn1cblxudmFyIENyb3BwciQxID0gZnVuY3Rpb24gKF9Dcm9wcHJDb3JlKSB7XG4gIGluaGVyaXRzKENyb3BwciwgX0Nyb3BwckNvcmUpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIENhbGxzIHRoZSBDcm9wcHJDb3JlJ3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBmdW5jdGlvbiBDcm9wcHIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3Bwcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENyb3Bwci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENyb3BwcikpLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucywgX2RlZmVycmVkKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlXSBXaGljaCBtb2RlIG9mIGNhbGN1bGF0aW9uIHRvIHVzZTogJ3JlYWwnLCAncmF0aW8nIG9yXG4gICAqICAgICAgJ3JhdycuXG4gICAqL1xuICBjcmVhdGVDbGFzcyhDcm9wcHIsIFt7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShtb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ2dldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ3NldEltYWdlJywgdGhpcykuY2FsbCh0aGlzLCBzcmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmV0dXJuIGdldChDcm9wcHIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3JvcHByLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbW92ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICAgIHRoaXMuYm94Lm1vdmUoeCwgeSk7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BFbmQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ3JvcEVuZCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAuNSwgMC41XSAoY2VudGVyKS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplVG8od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWy41LCAuNV07XG4gICAgICB0aGlzLmJveC5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGNyb3AgcmVnaW9uIGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvcmlnaW4gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgIERlZmF1bHRzIHRvIFswLjUsIDAuNV0gKGNlbnRlcikuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZUJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IpIHtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsuNSwgLjVdO1xuICAgICAgdGhpcy5ib3guc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmJveCA9IHRoaXMuaW5pdGlhbGl6ZUJveCh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3JvcHByO1xufShDcm9wcHJDb3JlKTtcblxucmV0dXJuIENyb3BwciQxO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/croppr/dist/croppr.js\n");

/***/ }),

/***/ "./node_modules/croppr/src/box.js":
/*!****************************************!*\
  !*** ./node_modules/croppr/src/box.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Box; });\n/**\n * Box component\n */\nclass Box {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /** \n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  set(x1 = null, y1 = null, x2 = null, y2 = null) {\n    this.x1 = x1 == null ? this.x1 : x1;\n    this.y1 = y1 == null ? this.y1 : y1;\n    this.x2 = x2 == null ? this.x2 : x2;\n    this.y2 = y2 == null ? this.y2 : y2;\n    return this;\n  }\n\n  /**\n   * Calculates the width of the box.\n   * @returns {Number}\n   */\n  width() {\n    return Math.abs(this.x2 - this.x1);\n  }\n\n  /**\n   * Calculates the height of the box.\n   * @returns {Number}\n   */\n  height() {\n    return Math.abs(this.y2 - this.y1);\n  }\n\n  /**\n   * Resizes the box to a new size.\n   * @param {Number} newWidth\n   * @param {Number} newHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  resize(newWidth, newHeight, origin = [0, 0]) {\n    const fromX = this.x1 + (this.width() * origin[0]);\n    const fromY = this.y1 + (this.height() * origin[1]);\n\n    this.x1 = fromX - (newWidth * origin[0]);\n    this.y1 = fromY - (newHeight * origin[1]);\n    this.x2 = this.x1 + newWidth;\n    this.y2 = this.y1 + newHeight;\n\n    return this;\n  }\n\n  /**\n   * Scale the box by a factor.\n   * @param {Number} factor\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  scale(factor, origin = [0, 0]) {\n    const newWidth = this.width() * factor;\n    const newHeight = this.height() * factor;\n    this.resize(newWidth, newHeight, origin);\n    return this;\n  }\n\n  /**\n   * Move the box to the specified coordinates.\n   */\n  move(x = null, y = null) {\n    let width = this.width();\n    let height = this.height();\n    x = x === null ? this.x1 : x;\n    y = y === null ? this.y1 : y;\n\n    this.x1 = x;\n    this.y1 = y;\n    this.x2 = x + width;\n    this.y2 = y + height;\n    return this;\n  }\n\n  /**\n   * Get relative x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getRelativePoint(point = [0, 0]) {\n    const x = this.width() * point[0];\n    const y = this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Get absolute x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getAbsolutePoint(point = [0, 0]) {\n    const x = this.x1 + this.width() * point[0];\n    const y = this.y1 + this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Constrain the box to a fixed ratio.\n   * @param {Number} ratio\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {String} [grow] The axis to grow to maintain the ratio.\n   *     Defaults to 'height'.\n   */\n  constrainToRatio(ratio, origin = [0, 0], grow = 'height') {\n    if (ratio === null) { return; }\n    const width = this.width();\n    const height = this.height();\n    switch (grow) {\n      case 'height': // Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n        break;\n      case 'width': // Grow width only\n        this.resize(this.height() * 1 / ratio, this.height(), origin);\n        break;\n      default: // Default: Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box within a boundary.\n   * @param {Number} boundaryWidth\n   * @param {Number} boundaryHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   */\n  constrainToBoundary(boundaryWidth, boundaryHeight, origin = [0, 0]) {\n\n    // Calculate the maximum sizes for each direction of growth\n    const [originX, originY] = this.getAbsolutePoint(origin);\n    const maxIfLeft = originX\n    const maxIfTop = originY\n    const maxIfRight = boundaryWidth - originX\n    const maxIfBottom = boundaryHeight - originY\n\n    // Express the direction of growth in terms of left, both,\n    // and right as -1, 0, and 1 respectively. Ditto for top/both/down.\n    const directionX = -2 * origin[0] + 1;\n    const directionY = -2 * origin[1] + 1;\n\n    // Determine the max size to use according to the direction of growth.\n    let [maxWidth, maxHeight] = [null, null];\n    switch (directionX) {\n      case -1: maxWidth = maxIfLeft; break;\n      case 0: maxWidth = Math.min(maxIfLeft, maxIfRight) * 2; break;\n      case +1: maxWidth = maxIfRight; break;\n    }\n    switch (directionY) {\n      case -1: maxHeight = maxIfTop; break;\n      case 0: maxHeight = Math.min(maxIfTop, maxIfBottom) * 2; break;\n      case +1: maxHeight = maxIfBottom; break;\n    }\n\n    // Resize if the box exceeds the calculated max width/height.\n    if (this.width() > maxWidth) {\n      const factor = maxWidth / this.width();\n      this.scale(factor, origin);\n    }\n    if (this.height() > maxHeight) {\n      const factor = maxHeight / this.height();\n      this.scale(factor, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box to a maximum/minimum size.\n   * @param {Number} [maxWidth]\n   * @param {Number} [maxHeight]\n   * @param {Number} [minWidth]\n   * @param {Number} [minHeight]\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {Number} [ratio] Ratio to maintain.\n   */\n  constrainToSize(maxWidth = null, maxHeight = null,\n    minWidth = null, minHeight = null,\n    origin = [0, 0], ratio = null) {\n\n    // Calculate new max/min widths & heights that constrains to the ratio\n    if (ratio) {\n      if (ratio > 1) {\n        maxWidth = maxHeight * 1 / ratio;\n        minHeight = minHeight * ratio;\n      } else if (ratio < 1) {\n        maxHeight = maxWidth * ratio;\n        minWidth = minHeight * 1 / ratio;\n      }\n    }\n\n    if (maxWidth && this.width() > maxWidth) {\n      const newWidth = maxWidth,\n        newHeight = ratio === null ? this.height() : maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (maxHeight && this.height() > maxHeight) {\n      const newWidth = ratio === null ? this.width() : maxWidth,\n        newHeight = maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minWidth && this.width() < minWidth) {\n      const newWidth = minWidth,\n        newHeight = ratio === null ? this.height() : minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minHeight && this.height() < minHeight) {\n      const newWidth = ratio === null ? this.width() : minWidth,\n        newHeight = minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    return this;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL3NyYy9ib3guanM/NGY5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsNkRBQTZEO0FBQzdELHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDhEQUE4RDtBQUM5RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcm9wcHIvc3JjL2JveC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQm94IGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3gge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCb3ggaW5zdGFuY2UuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICB9XG5cbiAgLyoqIFxuICAgKiBTZXRzIHRoZSBuZXcgZGltZW5zaW9ucyBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIHNldCh4MSA9IG51bGwsIHkxID0gbnVsbCwgeDIgPSBudWxsLCB5MiA9IG51bGwpIHtcbiAgICB0aGlzLngxID0geDEgPT0gbnVsbCA/IHRoaXMueDEgOiB4MTtcbiAgICB0aGlzLnkxID0geTEgPT0gbnVsbCA/IHRoaXMueTEgOiB5MTtcbiAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IHRoaXMueTIgOiB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCBvZiB0aGUgYm94LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGJveCB0byBhIG5ldyBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV3V2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgIERlZmF1bHRzIHRvIFswLCAwXSAodG9wIGxlZnQpLlxuICAgKi9cbiAgcmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGZyb21YID0gdGhpcy54MSArICh0aGlzLndpZHRoKCkgKiBvcmlnaW5bMF0pO1xuICAgIGNvbnN0IGZyb21ZID0gdGhpcy55MSArICh0aGlzLmhlaWdodCgpICogb3JpZ2luWzFdKTtcblxuICAgIHRoaXMueDEgPSBmcm9tWCAtIChuZXdXaWR0aCAqIG9yaWdpblswXSk7XG4gICAgdGhpcy55MSA9IGZyb21ZIC0gKG5ld0hlaWdodCAqIG9yaWdpblsxXSk7XG4gICAgdGhpcy54MiA9IHRoaXMueDEgKyBuZXdXaWR0aDtcbiAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBib3ggYnkgYSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICovXG4gIHNjYWxlKGZhY3Rvciwgb3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoKCkgKiBmYWN0b3I7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSAqIGZhY3RvcjtcbiAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGJveCB0byB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgbW92ZSh4ID0gbnVsbCwgeSA9IG51bGwpIHtcbiAgICBsZXQgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgbGV0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgeCA9IHggPT09IG51bGwgPyB0aGlzLngxIDogeDtcbiAgICB5ID0geSA9PT0gbnVsbCA/IHRoaXMueTEgOiB5O1xuXG4gICAgdGhpcy54MSA9IHg7XG4gICAgdGhpcy55MSA9IHk7XG4gICAgdGhpcy54MiA9IHggKyB3aWR0aDtcbiAgICB0aGlzLnkyID0geSArIGhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmVsYXRpdmUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRSZWxhdGl2ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgIGNvbnN0IHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRBYnNvbHV0ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMueDEgKyB0aGlzLndpZHRoKCkgKiBwb2ludFswXTtcbiAgICBjb25zdCB5ID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBwb2ludFsxXTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbiB0aGUgYm94IHRvIGEgZml4ZWQgcmF0aW8uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3Jvd10gVGhlIGF4aXMgdG8gZ3JvdyB0byBtYWludGFpbiB0aGUgcmF0aW8uXG4gICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICovXG4gIGNvbnN0cmFpblRvUmF0aW8ocmF0aW8sIG9yaWdpbiA9IFswLCAwXSwgZ3JvdyA9ICdoZWlnaHQnKSB7XG4gICAgaWYgKHJhdGlvID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgc3dpdGNoIChncm93KSB7XG4gICAgICBjYXNlICdoZWlnaHQnOiAvLyBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOiAvLyBHcm93IHdpZHRoIG9ubHlcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBEZWZhdWx0OiBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RyYWluIHRoZSBib3ggd2l0aGluIGEgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeUhlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqL1xuICBjb25zdHJhaW5Ub0JvdW5kYXJ5KGJvdW5kYXJ5V2lkdGgsIGJvdW5kYXJ5SGVpZ2h0LCBvcmlnaW4gPSBbMCwgMF0pIHtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBzaXplcyBmb3IgZWFjaCBkaXJlY3Rpb24gb2YgZ3Jvd3RoXG4gICAgY29uc3QgW29yaWdpblgsIG9yaWdpblldID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbik7XG4gICAgY29uc3QgbWF4SWZMZWZ0ID0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmVG9wID0gb3JpZ2luWVxuICAgIGNvbnN0IG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmQm90dG9tID0gYm91bmRhcnlIZWlnaHQgLSBvcmlnaW5ZXG5cbiAgICAvLyBFeHByZXNzIHRoZSBkaXJlY3Rpb24gb2YgZ3Jvd3RoIGluIHRlcm1zIG9mIGxlZnQsIGJvdGgsXG4gICAgLy8gYW5kIHJpZ2h0IGFzIC0xLCAwLCBhbmQgMSByZXNwZWN0aXZlbHkuIERpdHRvIGZvciB0b3AvYm90aC9kb3duLlxuICAgIGNvbnN0IGRpcmVjdGlvblggPSAtMiAqIG9yaWdpblswXSArIDE7XG4gICAgY29uc3QgZGlyZWN0aW9uWSA9IC0yICogb3JpZ2luWzFdICsgMTtcblxuICAgIC8vIERldGVybWluZSB0aGUgbWF4IHNpemUgdG8gdXNlIGFjY29yZGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIGdyb3d0aC5cbiAgICBsZXQgW21heFdpZHRoLCBtYXhIZWlnaHRdID0gW251bGwsIG51bGxdO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uWCkge1xuICAgICAgY2FzZSAtMTogbWF4V2lkdGggPSBtYXhJZkxlZnQ7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhXaWR0aCA9IE1hdGgubWluKG1heElmTGVmdCwgbWF4SWZSaWdodCkgKiAyOyBicmVhaztcbiAgICAgIGNhc2UgKzE6IG1heFdpZHRoID0gbWF4SWZSaWdodDsgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZGlyZWN0aW9uWSkge1xuICAgICAgY2FzZSAtMTogbWF4SGVpZ2h0ID0gbWF4SWZUb3A7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjsgYnJlYWs7XG4gICAgICBjYXNlICsxOiBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTsgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplIGlmIHRoZSBib3ggZXhjZWVkcyB0aGUgY2FsY3VsYXRlZCBtYXggd2lkdGgvaGVpZ2h0LlxuICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IG1heEhlaWdodCAvIHRoaXMuaGVpZ2h0KCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW4gdGhlIGJveCB0byBhIG1heGltdW0vbWluaW11bSBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heEhlaWdodF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5XaWR0aF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAqL1xuICBjb25zdHJhaW5Ub1NpemUobWF4V2lkdGggPSBudWxsLCBtYXhIZWlnaHQgPSBudWxsLFxuICAgIG1pbldpZHRoID0gbnVsbCwgbWluSGVpZ2h0ID0gbnVsbCxcbiAgICBvcmlnaW4gPSBbMCwgMF0sIHJhdGlvID0gbnVsbCkge1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyBtYXgvbWluIHdpZHRocyAmIGhlaWdodHMgdGhhdCBjb25zdHJhaW5zIHRvIHRoZSByYXRpb1xuICAgIGlmIChyYXRpbykge1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICBtYXhXaWR0aCA9IG1heEhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMSkge1xuICAgICAgICBtYXhIZWlnaHQgPSBtYXhXaWR0aCAqIHJhdGlvO1xuICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggJiYgdGhpcy53aWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHJhdGlvID09PSBudWxsID8gdGhpcy53aWR0aCgpIDogbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMuaGVpZ2h0KCkgOiBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIGlmIChtaW5IZWlnaHQgJiYgdGhpcy5oZWlnaHQoKSA8IG1pbkhlaWdodCkge1xuICAgICAgY29uc3QgbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/croppr/src/box.js\n");

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"./node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/lodash/toNumber.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzP2IwNDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHFEQUFZO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQywyQ0FBTztBQUN6QixlQUFlLG1CQUFPLENBQUMscURBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sWUFBWTtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/debounce.js\n");

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcz80MDhjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/now.js\n");

/***/ })

}]);