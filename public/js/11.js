(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[11],{

/***/ "./node_modules/blueimp-load-image/js/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global module, require */\n\nmodule.exports = __webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")\n\n__webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\")\n__webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")\n__webpack_require__(/*! ./load-image-fetch */ \"./node_modules/blueimp-load-image/js/load-image-fetch.js\")\n__webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")\n__webpack_require__(/*! ./load-image-exif-map */ \"./node_modules/blueimp-load-image/js/load-image-exif-map.js\")\n__webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")\n__webpack_require__(/*! ./load-image-iptc-map */ \"./node_modules/blueimp-load-image/js/load-image-iptc-map.js\")\n__webpack_require__(/*! ./load-image-orientation */ \"./node_modules/blueimp-load-image/js/load-image-orientation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2luZGV4LmpzP2ZiZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXZDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsZ0dBQTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKVxuXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2Utc2NhbGUnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLWZldGNoJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmLW1hcCcpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0YycpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0Yy1tYXAnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW9yaWVudGF0aW9uJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/index.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  loadImage.ExifMap.prototype.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x8769: 'ExifIFDPointer',\n    0x8825: 'GPSInfoIFDPointer',\n    0xa005: 'InteroperabilityIFDPointer',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    // ==================\n    // Exif Sub IFD tags:\n    // ==================\n    0x9000: 'ExifVersion', // EXIF version\n    0xa000: 'FlashpixVersion', // Flashpix format version\n    0xa001: 'ColorSpace', // Color space information tag\n    0xa002: 'PixelXDimension', // Valid width of meaningful image\n    0xa003: 'PixelYDimension', // Valid height of meaningful image\n    0xa500: 'Gamma',\n    0x9101: 'ComponentsConfiguration', // Information about channels\n    0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel\n    0x927c: 'MakerNote', // Any desired information written by the manufacturer\n    0x9286: 'UserComment', // Comments by user\n    0xa004: 'RelatedSoundFile', // Name of related sound file\n    0x9003: 'DateTimeOriginal', // Date and time when the original image was generated\n    0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally\n    0x9290: 'SubSecTime', // Fractions of seconds for DateTime\n    0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal\n    0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized\n    0x829a: 'ExposureTime', // Exposure time (in seconds)\n    0x829d: 'FNumber',\n    0x8822: 'ExposureProgram', // Exposure program\n    0x8824: 'SpectralSensitivity', // Spectral sensitivity\n    0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n    0x8828: 'OECF', // Optoelectric conversion factor\n    0x8830: 'SensitivityType',\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9201: 'ShutterSpeedValue', // Shutter speed\n    0x9202: 'ApertureValue', // Lens aperture\n    0x9203: 'BrightnessValue', // Value of brightness\n    0x9204: 'ExposureBias', // Exposure bias\n    0x9205: 'MaxApertureValue', // Smallest F number of lens\n    0x9206: 'SubjectDistance', // Distance to subject in meters\n    0x9207: 'MeteringMode', // Metering mode\n    0x9208: 'LightSource', // Kind of light source\n    0x9209: 'Flash', // Flash status\n    0x9214: 'SubjectArea', // Location and area of main subject\n    0x920a: 'FocalLength', // Focal length of the lens in mm\n    0xa20b: 'FlashEnergy', // Strobe energy in BCPS\n    0xa20c: 'SpatialFrequencyResponse',\n    0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit\n    0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit\n    0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution\n    0xa214: 'SubjectLocation', // Location of subject in image\n    0xa215: 'ExposureIndex', // Exposure index selected on camera\n    0xa217: 'SensingMethod', // Image sensor type\n    0xa300: 'FileSource', // Image source (3 == DSC)\n    0xa301: 'SceneType', // Scene type (1 == directly photographed)\n    0xa302: 'CFAPattern', // Color filter array geometric pattern\n    0xa401: 'CustomRendered', // Special processing\n    0xa402: 'ExposureMode', // Exposure mode\n    0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual\n    0xa404: 'DigitalZoomRatio', // Digital zoom ratio\n    0xa405: 'FocalLengthIn35mmFilm',\n    0xa406: 'SceneCaptureType', // Type of scene\n    0xa407: 'GainControl', // Degree of overall image gain adjustment\n    0xa408: 'Contrast', // Direction of contrast processing applied by camera\n    0xa409: 'Saturation', // Direction of saturation processing applied by camera\n    0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera\n    0xa40b: 'DeviceSettingDescription',\n    0xa40c: 'SubjectDistanceRange', // Distance to subject\n    0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: 'LensSpecification',\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    // ==============\n    // GPS Info tags:\n    // ==============\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000a: 'GPSMeasureMode',\n    0x000b: 'GPSDOP',\n    0x000c: 'GPSSpeedRef',\n    0x000d: 'GPSSpeed',\n    0x000e: 'GPSTrackRef',\n    0x000f: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001a: 'GPSDestDistance',\n    0x001b: 'GPSProcessingMethod',\n    0x001c: 'GPSAreaInformation',\n    0x001d: 'GPSDateStamp',\n    0x001e: 'GPSDifferential',\n    0x001f: 'GPSHPositioningError'\n  }\n\n  loadImage.ExifMap.prototype.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'top-left',\n      2: 'top-right',\n      3: 'bottom-right',\n      4: 'bottom-left',\n      5: 'left-top',\n      6: 'right-top',\n      7: 'right-bottom',\n      8: 'left-bottom'\n    }\n  }\n\n  loadImage.ExifMap.prototype.getText = function (id) {\n    var value = this.get(id)\n    switch (id) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[id][value]\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return\n        return String.fromCharCode(value[0], value[1], value[2], value[3])\n      case 'ComponentsConfiguration':\n        if (!value) return\n        return (\n          this.stringValues[id][value[0]] +\n          this.stringValues[id][value[1]] +\n          this.stringValues[id][value[2]] +\n          this.stringValues[id][value[3]]\n        )\n      case 'GPSVersionID':\n        if (!value) return\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]\n    }\n    return String(value)\n  }\n  ;(function (exifMapPrototype) {\n    var tags = exifMapPrototype.tags\n    var map = exifMapPrototype.map\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = prop\n      }\n    }\n  })(loadImage.ExifMap.prototype)\n\n  loadImage.ExifMap.prototype.getAll = function () {\n    var map = {}\n    var prop\n    var id\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        id = this.tags[prop]\n        if (id) {\n          map[id] = this.getText(id)\n        }\n      }\n    }\n    return map\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi1tYXAuanM/NzU2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRCxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWV4aWYtbWFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBFeGlmIE1hcFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBFeGlmIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZWlkZWxpbi9leGlmLWpzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtZXhpZiddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLWV4aWYnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS50YWdzID0ge1xuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgLy8gVElGRiB0YWdzIChJRkQwKTpcbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAgIDB4MDEwMTogJ0ltYWdlSGVpZ2h0JyxcbiAgICAweDg3Njk6ICdFeGlmSUZEUG9pbnRlcicsXG4gICAgMHg4ODI1OiAnR1BTSW5mb0lGRFBvaW50ZXInLFxuICAgIDB4YTAwNTogJ0ludGVyb3BlcmFiaWxpdHlJRkRQb2ludGVyJyxcbiAgICAweDAxMDI6ICdCaXRzUGVyU2FtcGxlJyxcbiAgICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gICAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gICAgMHgwMTEyOiAnT3JpZW50YXRpb24nLFxuICAgIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gICAgMHgwMTFjOiAnUGxhbmFyQ29uZmlndXJhdGlvbicsXG4gICAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gICAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gICAgMHgwMTFhOiAnWFJlc29sdXRpb24nLFxuICAgIDB4MDExYjogJ1lSZXNvbHV0aW9uJyxcbiAgICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gICAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgICAweDAxMTY6ICdSb3dzUGVyU3RyaXAnLFxuICAgIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gICAgMHgwMjAxOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0JyxcbiAgICAweDAyMDI6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgnLFxuICAgIDB4MDEyZDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAgIDB4MDEzZTogJ1doaXRlUG9pbnQnLFxuICAgIDB4MDEzZjogJ1ByaW1hcnlDaHJvbWF0aWNpdGllcycsXG4gICAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAgIDB4MDIxNDogJ1JlZmVyZW5jZUJsYWNrV2hpdGUnLFxuICAgIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgICAweDAxMGU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgICAweDAxMGY6ICdNYWtlJyxcbiAgICAweDAxMTA6ICdNb2RlbCcsXG4gICAgMHgwMTMxOiAnU29mdHdhcmUnLFxuICAgIDB4MDEzYjogJ0FydGlzdCcsXG4gICAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgICAvLyA9PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeGlmIFN1YiBJRkQgdGFnczpcbiAgICAvLyA9PT09PT09PT09PT09PT09PT1cbiAgICAweDkwMDA6ICdFeGlmVmVyc2lvbicsIC8vIEVYSUYgdmVyc2lvblxuICAgIDB4YTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsIC8vIEZsYXNocGl4IGZvcm1hdCB2ZXJzaW9uXG4gICAgMHhhMDAxOiAnQ29sb3JTcGFjZScsIC8vIENvbG9yIHNwYWNlIGluZm9ybWF0aW9uIHRhZ1xuICAgIDB4YTAwMjogJ1BpeGVsWERpbWVuc2lvbicsIC8vIFZhbGlkIHdpZHRoIG9mIG1lYW5pbmdmdWwgaW1hZ2VcbiAgICAweGEwMDM6ICdQaXhlbFlEaW1lbnNpb24nLCAvLyBWYWxpZCBoZWlnaHQgb2YgbWVhbmluZ2Z1bCBpbWFnZVxuICAgIDB4YTUwMDogJ0dhbW1hJyxcbiAgICAweDkxMDE6ICdDb21wb25lbnRzQ29uZmlndXJhdGlvbicsIC8vIEluZm9ybWF0aW9uIGFib3V0IGNoYW5uZWxzXG4gICAgMHg5MTAyOiAnQ29tcHJlc3NlZEJpdHNQZXJQaXhlbCcsIC8vIENvbXByZXNzZWQgYml0cyBwZXIgcGl4ZWxcbiAgICAweDkyN2M6ICdNYWtlck5vdGUnLCAvLyBBbnkgZGVzaXJlZCBpbmZvcm1hdGlvbiB3cml0dGVuIGJ5IHRoZSBtYW51ZmFjdHVyZXJcbiAgICAweDkyODY6ICdVc2VyQ29tbWVudCcsIC8vIENvbW1lbnRzIGJ5IHVzZXJcbiAgICAweGEwMDQ6ICdSZWxhdGVkU291bmRGaWxlJywgLy8gTmFtZSBvZiByZWxhdGVkIHNvdW5kIGZpbGVcbiAgICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJywgLy8gRGF0ZSBhbmQgdGltZSB3aGVuIHRoZSBvcmlnaW5hbCBpbWFnZSB3YXMgZ2VuZXJhdGVkXG4gICAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLCAvLyBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIGltYWdlIHdhcyBzdG9yZWQgZGlnaXRhbGx5XG4gICAgMHg5MjkwOiAnU3ViU2VjVGltZScsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZVxuICAgIDB4OTI5MTogJ1N1YlNlY1RpbWVPcmlnaW5hbCcsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZU9yaWdpbmFsXG4gICAgMHg5MjkyOiAnU3ViU2VjVGltZURpZ2l0aXplZCcsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZURpZ2l0aXplZFxuICAgIDB4ODI5YTogJ0V4cG9zdXJlVGltZScsIC8vIEV4cG9zdXJlIHRpbWUgKGluIHNlY29uZHMpXG4gICAgMHg4MjlkOiAnRk51bWJlcicsXG4gICAgMHg4ODIyOiAnRXhwb3N1cmVQcm9ncmFtJywgLy8gRXhwb3N1cmUgcHJvZ3JhbVxuICAgIDB4ODgyNDogJ1NwZWN0cmFsU2Vuc2l0aXZpdHknLCAvLyBTcGVjdHJhbCBzZW5zaXRpdml0eVxuICAgIDB4ODgyNzogJ1Bob3RvZ3JhcGhpY1NlbnNpdGl2aXR5JywgLy8gRVhJRiAyLjMsIElTT1NwZWVkUmF0aW5ncyBpbiBFWElGIDIuMlxuICAgIDB4ODgyODogJ09FQ0YnLCAvLyBPcHRvZWxlY3RyaWMgY29udmVyc2lvbiBmYWN0b3JcbiAgICAweDg4MzA6ICdTZW5zaXRpdml0eVR5cGUnLFxuICAgIDB4ODgzMTogJ1N0YW5kYXJkT3V0cHV0U2Vuc2l0aXZpdHknLFxuICAgIDB4ODgzMjogJ1JlY29tbWVuZGVkRXhwb3N1cmVJbmRleCcsXG4gICAgMHg4ODMzOiAnSVNPU3BlZWQnLFxuICAgIDB4ODgzNDogJ0lTT1NwZWVkTGF0aXR1ZGV5eXknLFxuICAgIDB4ODgzNTogJ0lTT1NwZWVkTGF0aXR1ZGV6enonLFxuICAgIDB4OTIwMTogJ1NodXR0ZXJTcGVlZFZhbHVlJywgLy8gU2h1dHRlciBzcGVlZFxuICAgIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLCAvLyBMZW5zIGFwZXJ0dXJlXG4gICAgMHg5MjAzOiAnQnJpZ2h0bmVzc1ZhbHVlJywgLy8gVmFsdWUgb2YgYnJpZ2h0bmVzc1xuICAgIDB4OTIwNDogJ0V4cG9zdXJlQmlhcycsIC8vIEV4cG9zdXJlIGJpYXNcbiAgICAweDkyMDU6ICdNYXhBcGVydHVyZVZhbHVlJywgLy8gU21hbGxlc3QgRiBudW1iZXIgb2YgbGVuc1xuICAgIDB4OTIwNjogJ1N1YmplY3REaXN0YW5jZScsIC8vIERpc3RhbmNlIHRvIHN1YmplY3QgaW4gbWV0ZXJzXG4gICAgMHg5MjA3OiAnTWV0ZXJpbmdNb2RlJywgLy8gTWV0ZXJpbmcgbW9kZVxuICAgIDB4OTIwODogJ0xpZ2h0U291cmNlJywgLy8gS2luZCBvZiBsaWdodCBzb3VyY2VcbiAgICAweDkyMDk6ICdGbGFzaCcsIC8vIEZsYXNoIHN0YXR1c1xuICAgIDB4OTIxNDogJ1N1YmplY3RBcmVhJywgLy8gTG9jYXRpb24gYW5kIGFyZWEgb2YgbWFpbiBzdWJqZWN0XG4gICAgMHg5MjBhOiAnRm9jYWxMZW5ndGgnLCAvLyBGb2NhbCBsZW5ndGggb2YgdGhlIGxlbnMgaW4gbW1cbiAgICAweGEyMGI6ICdGbGFzaEVuZXJneScsIC8vIFN0cm9iZSBlbmVyZ3kgaW4gQkNQU1xuICAgIDB4YTIwYzogJ1NwYXRpYWxGcmVxdWVuY3lSZXNwb25zZScsXG4gICAgMHhhMjBlOiAnRm9jYWxQbGFuZVhSZXNvbHV0aW9uJywgLy8gTnVtYmVyIG9mIHBpeGVscyBpbiB3aWR0aCBkaXJlY3Rpb24gcGVyIEZQUlVuaXRcbiAgICAweGEyMGY6ICdGb2NhbFBsYW5lWVJlc29sdXRpb24nLCAvLyBOdW1iZXIgb2YgcGl4ZWxzIGluIGhlaWdodCBkaXJlY3Rpb24gcGVyIEZQUlVuaXRcbiAgICAweGEyMTA6ICdGb2NhbFBsYW5lUmVzb2x1dGlvblVuaXQnLCAvLyBVbml0IGZvciBtZWFzdXJpbmcgdGhlIGZvY2FsIHBsYW5lIHJlc29sdXRpb25cbiAgICAweGEyMTQ6ICdTdWJqZWN0TG9jYXRpb24nLCAvLyBMb2NhdGlvbiBvZiBzdWJqZWN0IGluIGltYWdlXG4gICAgMHhhMjE1OiAnRXhwb3N1cmVJbmRleCcsIC8vIEV4cG9zdXJlIGluZGV4IHNlbGVjdGVkIG9uIGNhbWVyYVxuICAgIDB4YTIxNzogJ1NlbnNpbmdNZXRob2QnLCAvLyBJbWFnZSBzZW5zb3IgdHlwZVxuICAgIDB4YTMwMDogJ0ZpbGVTb3VyY2UnLCAvLyBJbWFnZSBzb3VyY2UgKDMgPT0gRFNDKVxuICAgIDB4YTMwMTogJ1NjZW5lVHlwZScsIC8vIFNjZW5lIHR5cGUgKDEgPT0gZGlyZWN0bHkgcGhvdG9ncmFwaGVkKVxuICAgIDB4YTMwMjogJ0NGQVBhdHRlcm4nLCAvLyBDb2xvciBmaWx0ZXIgYXJyYXkgZ2VvbWV0cmljIHBhdHRlcm5cbiAgICAweGE0MDE6ICdDdXN0b21SZW5kZXJlZCcsIC8vIFNwZWNpYWwgcHJvY2Vzc2luZ1xuICAgIDB4YTQwMjogJ0V4cG9zdXJlTW9kZScsIC8vIEV4cG9zdXJlIG1vZGVcbiAgICAweGE0MDM6ICdXaGl0ZUJhbGFuY2UnLCAvLyAxID0gYXV0byB3aGl0ZSBiYWxhbmNlLCAyID0gbWFudWFsXG4gICAgMHhhNDA0OiAnRGlnaXRhbFpvb21SYXRpbycsIC8vIERpZ2l0YWwgem9vbSByYXRpb1xuICAgIDB4YTQwNTogJ0ZvY2FsTGVuZ3RoSW4zNW1tRmlsbScsXG4gICAgMHhhNDA2OiAnU2NlbmVDYXB0dXJlVHlwZScsIC8vIFR5cGUgb2Ygc2NlbmVcbiAgICAweGE0MDc6ICdHYWluQ29udHJvbCcsIC8vIERlZ3JlZSBvZiBvdmVyYWxsIGltYWdlIGdhaW4gYWRqdXN0bWVudFxuICAgIDB4YTQwODogJ0NvbnRyYXN0JywgLy8gRGlyZWN0aW9uIG9mIGNvbnRyYXN0IHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgICAweGE0MDk6ICdTYXR1cmF0aW9uJywgLy8gRGlyZWN0aW9uIG9mIHNhdHVyYXRpb24gcHJvY2Vzc2luZyBhcHBsaWVkIGJ5IGNhbWVyYVxuICAgIDB4YTQwYTogJ1NoYXJwbmVzcycsIC8vIERpcmVjdGlvbiBvZiBzaGFycG5lc3MgcHJvY2Vzc2luZyBhcHBsaWVkIGJ5IGNhbWVyYVxuICAgIDB4YTQwYjogJ0RldmljZVNldHRpbmdEZXNjcmlwdGlvbicsXG4gICAgMHhhNDBjOiAnU3ViamVjdERpc3RhbmNlUmFuZ2UnLCAvLyBEaXN0YW5jZSB0byBzdWJqZWN0XG4gICAgMHhhNDIwOiAnSW1hZ2VVbmlxdWVJRCcsIC8vIElkZW50aWZpZXIgYXNzaWduZWQgdW5pcXVlbHkgdG8gZWFjaCBpbWFnZVxuICAgIDB4YTQzMDogJ0NhbWVyYU93bmVyTmFtZScsXG4gICAgMHhhNDMxOiAnQm9keVNlcmlhbE51bWJlcicsXG4gICAgMHhhNDMyOiAnTGVuc1NwZWNpZmljYXRpb24nLFxuICAgIDB4YTQzMzogJ0xlbnNNYWtlJyxcbiAgICAweGE0MzQ6ICdMZW5zTW9kZWwnLFxuICAgIDB4YTQzNTogJ0xlbnNTZXJpYWxOdW1iZXInLFxuICAgIC8vID09PT09PT09PT09PT09XG4gICAgLy8gR1BTIEluZm8gdGFnczpcbiAgICAvLyA9PT09PT09PT09PT09PVxuICAgIDB4MDAwMDogJ0dQU1ZlcnNpb25JRCcsXG4gICAgMHgwMDAxOiAnR1BTTGF0aXR1ZGVSZWYnLFxuICAgIDB4MDAwMjogJ0dQU0xhdGl0dWRlJyxcbiAgICAweDAwMDM6ICdHUFNMb25naXR1ZGVSZWYnLFxuICAgIDB4MDAwNDogJ0dQU0xvbmdpdHVkZScsXG4gICAgMHgwMDA1OiAnR1BTQWx0aXR1ZGVSZWYnLFxuICAgIDB4MDAwNjogJ0dQU0FsdGl0dWRlJyxcbiAgICAweDAwMDc6ICdHUFNUaW1lU3RhbXAnLFxuICAgIDB4MDAwODogJ0dQU1NhdGVsbGl0ZXMnLFxuICAgIDB4MDAwOTogJ0dQU1N0YXR1cycsXG4gICAgMHgwMDBhOiAnR1BTTWVhc3VyZU1vZGUnLFxuICAgIDB4MDAwYjogJ0dQU0RPUCcsXG4gICAgMHgwMDBjOiAnR1BTU3BlZWRSZWYnLFxuICAgIDB4MDAwZDogJ0dQU1NwZWVkJyxcbiAgICAweDAwMGU6ICdHUFNUcmFja1JlZicsXG4gICAgMHgwMDBmOiAnR1BTVHJhY2snLFxuICAgIDB4MDAxMDogJ0dQU0ltZ0RpcmVjdGlvblJlZicsXG4gICAgMHgwMDExOiAnR1BTSW1nRGlyZWN0aW9uJyxcbiAgICAweDAwMTI6ICdHUFNNYXBEYXR1bScsXG4gICAgMHgwMDEzOiAnR1BTRGVzdExhdGl0dWRlUmVmJyxcbiAgICAweDAwMTQ6ICdHUFNEZXN0TGF0aXR1ZGUnLFxuICAgIDB4MDAxNTogJ0dQU0Rlc3RMb25naXR1ZGVSZWYnLFxuICAgIDB4MDAxNjogJ0dQU0Rlc3RMb25naXR1ZGUnLFxuICAgIDB4MDAxNzogJ0dQU0Rlc3RCZWFyaW5nUmVmJyxcbiAgICAweDAwMTg6ICdHUFNEZXN0QmVhcmluZycsXG4gICAgMHgwMDE5OiAnR1BTRGVzdERpc3RhbmNlUmVmJyxcbiAgICAweDAwMWE6ICdHUFNEZXN0RGlzdGFuY2UnLFxuICAgIDB4MDAxYjogJ0dQU1Byb2Nlc3NpbmdNZXRob2QnLFxuICAgIDB4MDAxYzogJ0dQU0FyZWFJbmZvcm1hdGlvbicsXG4gICAgMHgwMDFkOiAnR1BTRGF0ZVN0YW1wJyxcbiAgICAweDAwMWU6ICdHUFNEaWZmZXJlbnRpYWwnLFxuICAgIDB4MDAxZjogJ0dQU0hQb3NpdGlvbmluZ0Vycm9yJ1xuICB9XG5cbiAgbG9hZEltYWdlLkV4aWZNYXAucHJvdG90eXBlLnN0cmluZ1ZhbHVlcyA9IHtcbiAgICBFeHBvc3VyZVByb2dyYW06IHtcbiAgICAgIDA6ICdVbmRlZmluZWQnLFxuICAgICAgMTogJ01hbnVhbCcsXG4gICAgICAyOiAnTm9ybWFsIHByb2dyYW0nLFxuICAgICAgMzogJ0FwZXJ0dXJlIHByaW9yaXR5JyxcbiAgICAgIDQ6ICdTaHV0dGVyIHByaW9yaXR5JyxcbiAgICAgIDU6ICdDcmVhdGl2ZSBwcm9ncmFtJyxcbiAgICAgIDY6ICdBY3Rpb24gcHJvZ3JhbScsXG4gICAgICA3OiAnUG9ydHJhaXQgbW9kZScsXG4gICAgICA4OiAnTGFuZHNjYXBlIG1vZGUnXG4gICAgfSxcbiAgICBNZXRlcmluZ01vZGU6IHtcbiAgICAgIDA6ICdVbmtub3duJyxcbiAgICAgIDE6ICdBdmVyYWdlJyxcbiAgICAgIDI6ICdDZW50ZXJXZWlnaHRlZEF2ZXJhZ2UnLFxuICAgICAgMzogJ1Nwb3QnLFxuICAgICAgNDogJ011bHRpU3BvdCcsXG4gICAgICA1OiAnUGF0dGVybicsXG4gICAgICA2OiAnUGFydGlhbCcsXG4gICAgICAyNTU6ICdPdGhlcidcbiAgICB9LFxuICAgIExpZ2h0U291cmNlOiB7XG4gICAgICAwOiAnVW5rbm93bicsXG4gICAgICAxOiAnRGF5bGlnaHQnLFxuICAgICAgMjogJ0ZsdW9yZXNjZW50JyxcbiAgICAgIDM6ICdUdW5nc3RlbiAoaW5jYW5kZXNjZW50IGxpZ2h0KScsXG4gICAgICA0OiAnRmxhc2gnLFxuICAgICAgOTogJ0ZpbmUgd2VhdGhlcicsXG4gICAgICAxMDogJ0Nsb3VkeSB3ZWF0aGVyJyxcbiAgICAgIDExOiAnU2hhZGUnLFxuICAgICAgMTI6ICdEYXlsaWdodCBmbHVvcmVzY2VudCAoRCA1NzAwIC0gNzEwMEspJyxcbiAgICAgIDEzOiAnRGF5IHdoaXRlIGZsdW9yZXNjZW50IChOIDQ2MDAgLSA1NDAwSyknLFxuICAgICAgMTQ6ICdDb29sIHdoaXRlIGZsdW9yZXNjZW50IChXIDM5MDAgLSA0NTAwSyknLFxuICAgICAgMTU6ICdXaGl0ZSBmbHVvcmVzY2VudCAoV1cgMzIwMCAtIDM3MDBLKScsXG4gICAgICAxNzogJ1N0YW5kYXJkIGxpZ2h0IEEnLFxuICAgICAgMTg6ICdTdGFuZGFyZCBsaWdodCBCJyxcbiAgICAgIDE5OiAnU3RhbmRhcmQgbGlnaHQgQycsXG4gICAgICAyMDogJ0Q1NScsXG4gICAgICAyMTogJ0Q2NScsXG4gICAgICAyMjogJ0Q3NScsXG4gICAgICAyMzogJ0Q1MCcsXG4gICAgICAyNDogJ0lTTyBzdHVkaW8gdHVuZ3N0ZW4nLFxuICAgICAgMjU1OiAnT3RoZXInXG4gICAgfSxcbiAgICBGbGFzaDoge1xuICAgICAgMHgwMDAwOiAnRmxhc2ggZGlkIG5vdCBmaXJlJyxcbiAgICAgIDB4MDAwMTogJ0ZsYXNoIGZpcmVkJyxcbiAgICAgIDB4MDAwNTogJ1N0cm9iZSByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDAwNzogJ1N0cm9iZSByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDA5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgICAweDAwMGQ6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDAwZjogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwMTA6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgICAweDAwMTg6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGF1dG8gbW9kZScsXG4gICAgICAweDAwMTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlJyxcbiAgICAgIDB4MDAxZDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDFmOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDAyMDogJ05vIGZsYXNoIGZ1bmN0aW9uJyxcbiAgICAgIDB4MDA0MTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA0NTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDA0NzogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDQ5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgICAweDAwNGQ6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJyxcbiAgICAgIDB4MDA0ZjogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwNTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA1ZDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuICAgICAgMHgwMDVmOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJ1xuICAgIH0sXG4gICAgU2Vuc2luZ01ldGhvZDoge1xuICAgICAgMTogJ1VuZGVmaW5lZCcsXG4gICAgICAyOiAnT25lLWNoaXAgY29sb3IgYXJlYSBzZW5zb3InLFxuICAgICAgMzogJ1R3by1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICAgIDQ6ICdUaHJlZS1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICAgIDU6ICdDb2xvciBzZXF1ZW50aWFsIGFyZWEgc2Vuc29yJyxcbiAgICAgIDc6ICdUcmlsaW5lYXIgc2Vuc29yJyxcbiAgICAgIDg6ICdDb2xvciBzZXF1ZW50aWFsIGxpbmVhciBzZW5zb3InXG4gICAgfSxcbiAgICBTY2VuZUNhcHR1cmVUeXBlOiB7XG4gICAgICAwOiAnU3RhbmRhcmQnLFxuICAgICAgMTogJ0xhbmRzY2FwZScsXG4gICAgICAyOiAnUG9ydHJhaXQnLFxuICAgICAgMzogJ05pZ2h0IHNjZW5lJ1xuICAgIH0sXG4gICAgU2NlbmVUeXBlOiB7XG4gICAgICAxOiAnRGlyZWN0bHkgcGhvdG9ncmFwaGVkJ1xuICAgIH0sXG4gICAgQ3VzdG9tUmVuZGVyZWQ6IHtcbiAgICAgIDA6ICdOb3JtYWwgcHJvY2VzcycsXG4gICAgICAxOiAnQ3VzdG9tIHByb2Nlc3MnXG4gICAgfSxcbiAgICBXaGl0ZUJhbGFuY2U6IHtcbiAgICAgIDA6ICdBdXRvIHdoaXRlIGJhbGFuY2UnLFxuICAgICAgMTogJ01hbnVhbCB3aGl0ZSBiYWxhbmNlJ1xuICAgIH0sXG4gICAgR2FpbkNvbnRyb2w6IHtcbiAgICAgIDA6ICdOb25lJyxcbiAgICAgIDE6ICdMb3cgZ2FpbiB1cCcsXG4gICAgICAyOiAnSGlnaCBnYWluIHVwJyxcbiAgICAgIDM6ICdMb3cgZ2FpbiBkb3duJyxcbiAgICAgIDQ6ICdIaWdoIGdhaW4gZG93bidcbiAgICB9LFxuICAgIENvbnRyYXN0OiB7XG4gICAgICAwOiAnTm9ybWFsJyxcbiAgICAgIDE6ICdTb2Z0JyxcbiAgICAgIDI6ICdIYXJkJ1xuICAgIH0sXG4gICAgU2F0dXJhdGlvbjoge1xuICAgICAgMDogJ05vcm1hbCcsXG4gICAgICAxOiAnTG93IHNhdHVyYXRpb24nLFxuICAgICAgMjogJ0hpZ2ggc2F0dXJhdGlvbidcbiAgICB9LFxuICAgIFNoYXJwbmVzczoge1xuICAgICAgMDogJ05vcm1hbCcsXG4gICAgICAxOiAnU29mdCcsXG4gICAgICAyOiAnSGFyZCdcbiAgICB9LFxuICAgIFN1YmplY3REaXN0YW5jZVJhbmdlOiB7XG4gICAgICAwOiAnVW5rbm93bicsXG4gICAgICAxOiAnTWFjcm8nLFxuICAgICAgMjogJ0Nsb3NlIHZpZXcnLFxuICAgICAgMzogJ0Rpc3RhbnQgdmlldydcbiAgICB9LFxuICAgIEZpbGVTb3VyY2U6IHtcbiAgICAgIDM6ICdEU0MnXG4gICAgfSxcbiAgICBDb21wb25lbnRzQ29uZmlndXJhdGlvbjoge1xuICAgICAgMDogJycsXG4gICAgICAxOiAnWScsXG4gICAgICAyOiAnQ2InLFxuICAgICAgMzogJ0NyJyxcbiAgICAgIDQ6ICdSJyxcbiAgICAgIDU6ICdHJyxcbiAgICAgIDY6ICdCJ1xuICAgIH0sXG4gICAgT3JpZW50YXRpb246IHtcbiAgICAgIDE6ICd0b3AtbGVmdCcsXG4gICAgICAyOiAndG9wLXJpZ2h0JyxcbiAgICAgIDM6ICdib3R0b20tcmlnaHQnLFxuICAgICAgNDogJ2JvdHRvbS1sZWZ0JyxcbiAgICAgIDU6ICdsZWZ0LXRvcCcsXG4gICAgICA2OiAncmlnaHQtdG9wJyxcbiAgICAgIDc6ICdyaWdodC1ib3R0b20nLFxuICAgICAgODogJ2xlZnQtYm90dG9tJ1xuICAgIH1cbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaWQpXG4gICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnTGlnaHRTb3VyY2UnOlxuICAgICAgY2FzZSAnRmxhc2gnOlxuICAgICAgY2FzZSAnTWV0ZXJpbmdNb2RlJzpcbiAgICAgIGNhc2UgJ0V4cG9zdXJlUHJvZ3JhbSc6XG4gICAgICBjYXNlICdTZW5zaW5nTWV0aG9kJzpcbiAgICAgIGNhc2UgJ1NjZW5lQ2FwdHVyZVR5cGUnOlxuICAgICAgY2FzZSAnU2NlbmVUeXBlJzpcbiAgICAgIGNhc2UgJ0N1c3RvbVJlbmRlcmVkJzpcbiAgICAgIGNhc2UgJ1doaXRlQmFsYW5jZSc6XG4gICAgICBjYXNlICdHYWluQ29udHJvbCc6XG4gICAgICBjYXNlICdDb250cmFzdCc6XG4gICAgICBjYXNlICdTYXR1cmF0aW9uJzpcbiAgICAgIGNhc2UgJ1NoYXJwbmVzcyc6XG4gICAgICBjYXNlICdTdWJqZWN0RGlzdGFuY2VSYW5nZSc6XG4gICAgICBjYXNlICdGaWxlU291cmNlJzpcbiAgICAgIGNhc2UgJ09yaWVudGF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVmFsdWVzW2lkXVt2YWx1ZV1cbiAgICAgIGNhc2UgJ0V4aWZWZXJzaW9uJzpcbiAgICAgIGNhc2UgJ0ZsYXNocGl4VmVyc2lvbic6XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVyblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSlcbiAgICAgIGNhc2UgJ0NvbXBvbmVudHNDb25maWd1cmF0aW9uJzpcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzBdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzFdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzJdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbaWRdW3ZhbHVlWzNdXVxuICAgICAgICApXG4gICAgICBjYXNlICdHUFNWZXJzaW9uSUQnOlxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdICsgJy4nICsgdmFsdWVbMV0gKyAnLicgKyB2YWx1ZVsyXSArICcuJyArIHZhbHVlWzNdXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gIH1cbiAgOyhmdW5jdGlvbiAoZXhpZk1hcFByb3RvdHlwZSkge1xuICAgIHZhciB0YWdzID0gZXhpZk1hcFByb3RvdHlwZS50YWdzXG4gICAgdmFyIG1hcCA9IGV4aWZNYXBQcm90b3R5cGUubWFwXG4gICAgdmFyIHByb3BcbiAgICAvLyBNYXAgdGhlIHRhZyBuYW1lcyB0byB0YWdzOlxuICAgIGZvciAocHJvcCBpbiB0YWdzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhZ3MsIHByb3ApKSB7XG4gICAgICAgIG1hcFt0YWdzW3Byb3BdXSA9IHByb3BcbiAgICAgIH1cbiAgICB9XG4gIH0pKGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZSlcblxuICBsb2FkSW1hZ2UuRXhpZk1hcC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXAgPSB7fVxuICAgIHZhciBwcm9wXG4gICAgdmFyIGlkXG4gICAgZm9yIChwcm9wIGluIHRoaXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcHJvcCkpIHtcbiAgICAgICAgaWQgPSB0aGlzLnRhZ3NbcHJvcF1cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgbWFwW2lkXSA9IHRoaXMuZ2V0VGV4dChpZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n/* eslint-disable no-console */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  loadImage.ExifMap = function () {\n    return this\n  }\n\n  loadImage.ExifMap.prototype.map = {\n    Orientation: 0x0112\n  }\n\n  loadImage.ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  loadImage.getExifThumbnail = function (dataView, offset, length) {\n    if (!length || offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.')\n      return\n    }\n    return loadImage.createObjectURL(\n      new Blob([dataView.buffer.slice(offset, offset + length)])\n    )\n  }\n\n  loadImage.exifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function (dataView, dataOffset) {\n        return dataView.getUint8(dataOffset)\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function (dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset))\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian)\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getUint32(dataOffset, littleEndian) /\n          dataView.getUint32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getInt32(dataOffset, littleEndian) /\n          dataView.getInt32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    }\n  }\n  // undefined, 8-bit byte, value depending on field:\n  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]\n\n  loadImage.getExifValue = function (\n    dataView,\n    tiffOffset,\n    offset,\n    type,\n    length,\n    littleEndian\n  ) {\n    var tagType = loadImage.exifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.')\n      return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset =\n      tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : offset + 8\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.')\n      return\n    }\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(\n        dataView,\n        dataOffset + i * tagType.size,\n        littleEndian\n      )\n    }\n    if (tagType.ascii) {\n      str = ''\n      // Concatenate the chars:\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]\n        // Ignore the terminating NULL byte(s):\n        if (c === '\\u0000') {\n          break\n        }\n        str += c\n      }\n      return str\n    }\n    return values\n  }\n\n  loadImage.parseExifTag = function (\n    dataView,\n    tiffOffset,\n    offset,\n    littleEndian\n  ) {\n    return {\n      number: dataView.getUint16(offset, littleEndian),\n      value: loadImage.getExifValue(\n        dataView,\n        tiffOffset,\n        offset,\n        dataView.getUint16(offset + 2, littleEndian), // tag type\n        dataView.getUint32(offset + 4, littleEndian), // tag length\n        littleEndian\n      )\n    }\n  }\n\n  loadImage.parseExifTags = function (\n    dataView,\n    tiffOffset,\n    dirOffset,\n    littleEndian,\n    data\n  ) {\n    var tagsNumber, dirEndOffset, i, tagOffset, tag\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.')\n      return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.')\n      return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n      tagOffset = dirOffset + 2 + 12 * i\n      tag = this.parseExifTag(\n        dataView,\n        tiffOffset,\n        tagOffset,\n        littleEndian,\n        data\n      )\n      data.exif[tag.number] = tag.value\n      if (data.exifOffsets) {\n        data.exifOffsets[tag.number] = tagOffset\n      }\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n  }\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailData\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.')\n      return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.')\n      return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true\n        break\n      case 0x4d4d:\n        littleEndian = false\n        break\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\n        return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.')\n      return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new loadImage.ExifMap()\n    if (!options.disableExifOffsets) {\n      data.exifOffsets = new loadImage.ExifMap()\n      data.exifTiffOffset = tiffOffset\n      data.exifLittleEndian = littleEndian\n    }\n    // Parse the tags of the main image directory and retrieve the\n    // offset to the next directory, usually the thumbnail directory:\n    dirOffset = loadImage.parseExifTags(\n      dataView,\n      tiffOffset,\n      tiffOffset + dirOffset,\n      littleEndian,\n      data\n    )\n    if (dirOffset && !options.disableExifThumbnail) {\n      thumbnailData = { exif: {} }\n      dirOffset = loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        thumbnailData\n      )\n      // Check for JPEG Thumbnail offset:\n      if (thumbnailData.exif[0x0201]) {\n        data.exif.Thumbnail = loadImage.getExifThumbnail(\n          dataView,\n          tiffOffset + thumbnailData.exif[0x0201],\n          thumbnailData.exif[0x0202] // Thumbnail data length\n        )\n      }\n    }\n    // Check for Exif Sub IFD Pointer:\n    if (data.exif[0x8769] && !options.disableExifSub) {\n      loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + data.exif[0x8769], // directory offset\n        littleEndian,\n        data\n      )\n    }\n    // Check for GPS Info IFD Pointer:\n    if (data.exif[0x8825] && !options.disableExifGps) {\n      loadImage.parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + data.exif[0x8825], // directory offset\n        littleEndian,\n        data\n      )\n    }\n  }\n\n  // Registers the Exif parser for the APP1 JPEG meta data segment:\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\n  loadImage.exifWriters = {\n    // Orientation writer:\n    0x0112: function (buffer, data, value) {\n      var view = new DataView(buffer, data.exifOffsets[0x0112] + 8, 2)\n      view.setUint16(0, value, data.exifLittleEndian)\n      return buffer\n    }\n  }\n\n  loadImage.writeExifData = function (buffer, data, id, value) {\n    loadImage.exifWriters[data.exif.map[id]](buffer, data, value)\n  }\n\n  // Adds the following properties to the parseMetaData callback data:\n  // * exif: The parsed Exif tags\n  // * exifOffsets: The parsed Exif tag offsets\n  // * exifTiffOffset: TIFF header offset (used for offset pointers)\n  // * exifLittleEndian: little endian order if true, big endian if false\n\n  // Adds the following options to the parseMetaData method:\n  // * disableExif: Disables Exif parsing.\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\n  // * disableExifOffsets: Disables storing Exif tag offsets\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcz83N2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFELEdBQUcsTUFBTSxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgRXhpZiBQYXJzZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIERhdGFWaWV3ICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtbWV0YSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGxvYWRJbWFnZS5FeGlmTWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsb2FkSW1hZ2UuRXhpZk1hcC5wcm90b3R5cGUubWFwID0ge1xuICAgIE9yaWVudGF0aW9uOiAweDAxMTJcbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gdGhpc1tpZF0gfHwgdGhpc1t0aGlzLm1hcFtpZF1dXG4gIH1cblxuICBsb2FkSW1hZ2UuZ2V0RXhpZlRodW1ibmFpbCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIWxlbmd0aCB8fCBvZmZzZXQgKyBsZW5ndGggPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgdGh1bWJuYWlsIGRhdGEuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gbG9hZEltYWdlLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgIG5ldyBCbG9iKFtkYXRhVmlldy5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpXSlcbiAgICApXG4gIH1cblxuICBsb2FkSW1hZ2UuZXhpZlRhZ1R5cGVzID0ge1xuICAgIC8vIGJ5dGUsIDgtYml0IHVuc2lnbmVkIGludDpcbiAgICAxOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChkYXRhT2Zmc2V0KVxuICAgICAgfSxcbiAgICAgIHNpemU6IDFcbiAgICB9LFxuICAgIC8vIGFzY2lpLCA4LWJpdCBieXRlOlxuICAgIDI6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoZGF0YU9mZnNldCkpXG4gICAgICB9LFxuICAgICAgc2l6ZTogMSxcbiAgICAgIGFzY2lpOiB0cnVlXG4gICAgfSxcbiAgICAvLyBzaG9ydCwgMTYgYml0IGludDpcbiAgICAzOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgICB9LFxuICAgICAgc2l6ZTogMlxuICAgIH0sXG4gICAgLy8gbG9uZywgMzIgYml0IGludDpcbiAgICA0OiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgICB9LFxuICAgICAgc2l6ZTogNFxuICAgIH0sXG4gICAgLy8gcmF0aW9uYWwgPSB0d28gbG9uZyB2YWx1ZXMsIGZpcnN0IGlzIG51bWVyYXRvciwgc2Vjb25kIGlzIGRlbm9taW5hdG9yOlxuICAgIDU6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRhdGFWaWV3LmdldFVpbnQzMihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIC9cbiAgICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIoZGF0YU9mZnNldCArIDQsIGxpdHRsZUVuZGlhbilcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDhcbiAgICB9LFxuICAgIC8vIHNsb25nLCAzMiBiaXQgc2lnbmVkIGludDpcbiAgICA5OiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIH0sXG4gICAgICBzaXplOiA0XG4gICAgfSxcbiAgICAvLyBzcmF0aW9uYWwsIHR3byBzbG9uZ3MsIGZpcnN0IGlzIG51bWVyYXRvciwgc2Vjb25kIGlzIGRlbm9taW5hdG9yOlxuICAgIDEwOiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhVmlldy5nZXRJbnQzMihkYXRhT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIC9cbiAgICAgICAgICBkYXRhVmlldy5nZXRJbnQzMihkYXRhT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2l6ZTogOFxuICAgIH1cbiAgfVxuICAvLyB1bmRlZmluZWQsIDgtYml0IGJ5dGUsIHZhbHVlIGRlcGVuZGluZyBvbiBmaWVsZDpcbiAgbG9hZEltYWdlLmV4aWZUYWdUeXBlc1s3XSA9IGxvYWRJbWFnZS5leGlmVGFnVHlwZXNbMV1cblxuICBsb2FkSW1hZ2UuZ2V0RXhpZlZhbHVlID0gZnVuY3Rpb24gKFxuICAgIGRhdGFWaWV3LFxuICAgIHRpZmZPZmZzZXQsXG4gICAgb2Zmc2V0LFxuICAgIHR5cGUsXG4gICAgbGVuZ3RoLFxuICAgIGxpdHRsZUVuZGlhblxuICApIHtcbiAgICB2YXIgdGFnVHlwZSA9IGxvYWRJbWFnZS5leGlmVGFnVHlwZXNbdHlwZV1cbiAgICB2YXIgdGFnU2l6ZVxuICAgIHZhciBkYXRhT2Zmc2V0XG4gICAgdmFyIHZhbHVlc1xuICAgIHZhciBpXG4gICAgdmFyIHN0clxuICAgIHZhciBjXG4gICAgaWYgKCF0YWdUeXBlKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgdGFnIHR5cGUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0YWdTaXplID0gdGFnVHlwZS5zaXplICogbGVuZ3RoXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBpcyBjb250YWluZWQgaW4gdGhlIGRhdGFPZmZzZXQgYnl0ZXMsXG4gICAgLy8gb3IgaWYgdGhlIHZhbHVlIGF0IHRoZSBkYXRhT2Zmc2V0IGlzIGEgcG9pbnRlciB0byB0aGUgYWN0dWFsIGRhdGE6XG4gICAgZGF0YU9mZnNldCA9XG4gICAgICB0YWdTaXplID4gNFxuICAgICAgICA/IHRpZmZPZmZzZXQgKyBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgOCwgbGl0dGxlRW5kaWFuKVxuICAgICAgICA6IG9mZnNldCArIDhcbiAgICBpZiAoZGF0YU9mZnNldCArIHRhZ1NpemUgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGF0YSBvZmZzZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGFnVHlwZS5nZXRWYWx1ZShkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgIH1cbiAgICB2YWx1ZXMgPSBbXVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFsdWVzW2ldID0gdGFnVHlwZS5nZXRWYWx1ZShcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIGRhdGFPZmZzZXQgKyBpICogdGFnVHlwZS5zaXplLFxuICAgICAgICBsaXR0bGVFbmRpYW5cbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhZ1R5cGUuYXNjaWkpIHtcbiAgICAgIHN0ciA9ICcnXG4gICAgICAvLyBDb25jYXRlbmF0ZSB0aGUgY2hhcnM6XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGMgPSB2YWx1ZXNbaV1cbiAgICAgICAgLy8gSWdub3JlIHRoZSB0ZXJtaW5hdGluZyBOVUxMIGJ5dGUocyk6XG4gICAgICAgIGlmIChjID09PSAnXFx1MDAwMCcpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBjXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxuXG4gIGxvYWRJbWFnZS5wYXJzZUV4aWZUYWcgPSBmdW5jdGlvbiAoXG4gICAgZGF0YVZpZXcsXG4gICAgdGlmZk9mZnNldCxcbiAgICBvZmZzZXQsXG4gICAgbGl0dGxlRW5kaWFuXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbiksXG4gICAgICB2YWx1ZTogbG9hZEltYWdlLmdldEV4aWZWYWx1ZShcbiAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgIHRpZmZPZmZzZXQsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIsIGxpdHRsZUVuZGlhbiksIC8vIHRhZyB0eXBlXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pLCAvLyB0YWcgbGVuZ3RoXG4gICAgICAgIGxpdHRsZUVuZGlhblxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGxvYWRJbWFnZS5wYXJzZUV4aWZUYWdzID0gZnVuY3Rpb24gKFxuICAgIGRhdGFWaWV3LFxuICAgIHRpZmZPZmZzZXQsXG4gICAgZGlyT2Zmc2V0LFxuICAgIGxpdHRsZUVuZGlhbixcbiAgICBkYXRhXG4gICkge1xuICAgIHZhciB0YWdzTnVtYmVyLCBkaXJFbmRPZmZzZXQsIGksIHRhZ09mZnNldCwgdGFnXG4gICAgaWYgKGRpck9mZnNldCArIDYgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGlyZWN0b3J5IG9mZnNldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRhZ3NOdW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MTYoZGlyT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgZGlyRW5kT2Zmc2V0ID0gZGlyT2Zmc2V0ICsgMiArIDEyICogdGFnc051bWJlclxuICAgIGlmIChkaXJFbmRPZmZzZXQgKyA0ID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGRpcmVjdG9yeSBzaXplLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRhZ3NOdW1iZXI7IGkgKz0gMSkge1xuICAgICAgdGFnT2Zmc2V0ID0gZGlyT2Zmc2V0ICsgMiArIDEyICogaVxuICAgICAgdGFnID0gdGhpcy5wYXJzZUV4aWZUYWcoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0LFxuICAgICAgICB0YWdPZmZzZXQsXG4gICAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgICAgZGF0YVxuICAgICAgKVxuICAgICAgZGF0YS5leGlmW3RhZy5udW1iZXJdID0gdGFnLnZhbHVlXG4gICAgICBpZiAoZGF0YS5leGlmT2Zmc2V0cykge1xuICAgICAgICBkYXRhLmV4aWZPZmZzZXRzW3RhZy5udW1iZXJdID0gdGFnT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgb2Zmc2V0IHRvIHRoZSBuZXh0IGRpcmVjdG9yeTpcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKGRpckVuZE9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlRXhpZkRhdGEgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZUV4aWYpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdGlmZk9mZnNldCA9IG9mZnNldCArIDEwXG4gICAgdmFyIGxpdHRsZUVuZGlhblxuICAgIHZhciBkaXJPZmZzZXRcbiAgICB2YXIgdGh1bWJuYWlsRGF0YVxuICAgIC8vIENoZWNrIGZvciB0aGUgQVNDSUkgY29kZSBmb3IgXCJFeGlmXCIgKDB4NDU3ODY5NjYpOlxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCkgIT09IDB4NDU3ODY5NjYpIHtcbiAgICAgIC8vIE5vIEV4aWYgZGF0YSwgbWlnaHQgYmUgWE1QIGRhdGEgaW5zdGVhZFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aWZmT2Zmc2V0ICsgOCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgdGhlIHR3byBudWxsIGJ5dGVzOlxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgOCkgIT09IDB4MDAwMCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBNaXNzaW5nIGJ5dGUgYWxpZ25tZW50IG9mZnNldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBieXRlIGFsaWdubWVudDpcbiAgICBzd2l0Y2ggKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSkge1xuICAgICAgY2FzZSAweDQ5NDk6XG4gICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMHg0ZDRkOlxuICAgICAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGJ5dGUgYWxpZ25tZW50IG1hcmtlci4nKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBUSUZGIHRhZyBtYXJrZXIgKDB4MDAyQSk6XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSAhPT0gMHgwMDJhKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IE1pc3NpbmcgVElGRiBtYXJrZXIuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBSZXRyaWV2ZSB0aGUgZGlyZWN0b3J5IG9mZnNldCBieXRlcywgdXN1YWxseSAweDAwMDAwMDA4IG9yIDggZGVjaW1hbDpcbiAgICBkaXJPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsIGxpdHRsZUVuZGlhbilcbiAgICAvLyBDcmVhdGUgdGhlIGV4aWYgb2JqZWN0IHRvIHN0b3JlIHRoZSB0YWdzOlxuICAgIGRhdGEuZXhpZiA9IG5ldyBsb2FkSW1hZ2UuRXhpZk1hcCgpXG4gICAgaWYgKCFvcHRpb25zLmRpc2FibGVFeGlmT2Zmc2V0cykge1xuICAgICAgZGF0YS5leGlmT2Zmc2V0cyA9IG5ldyBsb2FkSW1hZ2UuRXhpZk1hcCgpXG4gICAgICBkYXRhLmV4aWZUaWZmT2Zmc2V0ID0gdGlmZk9mZnNldFxuICAgICAgZGF0YS5leGlmTGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuXG4gICAgfVxuICAgIC8vIFBhcnNlIHRoZSB0YWdzIG9mIHRoZSBtYWluIGltYWdlIGRpcmVjdG9yeSBhbmQgcmV0cmlldmUgdGhlXG4gICAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IGRpcmVjdG9yeSwgdXN1YWxseSB0aGUgdGh1bWJuYWlsIGRpcmVjdG9yeTpcbiAgICBkaXJPZmZzZXQgPSBsb2FkSW1hZ2UucGFyc2VFeGlmVGFncyhcbiAgICAgIGRhdGFWaWV3LFxuICAgICAgdGlmZk9mZnNldCxcbiAgICAgIHRpZmZPZmZzZXQgKyBkaXJPZmZzZXQsXG4gICAgICBsaXR0bGVFbmRpYW4sXG4gICAgICBkYXRhXG4gICAgKVxuICAgIGlmIChkaXJPZmZzZXQgJiYgIW9wdGlvbnMuZGlzYWJsZUV4aWZUaHVtYm5haWwpIHtcbiAgICAgIHRodW1ibmFpbERhdGEgPSB7IGV4aWY6IHt9IH1cbiAgICAgIGRpck9mZnNldCA9IGxvYWRJbWFnZS5wYXJzZUV4aWZUYWdzKFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCxcbiAgICAgICAgdGlmZk9mZnNldCArIGRpck9mZnNldCxcbiAgICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgICB0aHVtYm5haWxEYXRhXG4gICAgICApXG4gICAgICAvLyBDaGVjayBmb3IgSlBFRyBUaHVtYm5haWwgb2Zmc2V0OlxuICAgICAgaWYgKHRodW1ibmFpbERhdGEuZXhpZlsweDAyMDFdKSB7XG4gICAgICAgIGRhdGEuZXhpZi5UaHVtYm5haWwgPSBsb2FkSW1hZ2UuZ2V0RXhpZlRodW1ibmFpbChcbiAgICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgICB0aWZmT2Zmc2V0ICsgdGh1bWJuYWlsRGF0YS5leGlmWzB4MDIwMV0sXG4gICAgICAgICAgdGh1bWJuYWlsRGF0YS5leGlmWzB4MDIwMl0gLy8gVGh1bWJuYWlsIGRhdGEgbGVuZ3RoXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIEV4aWYgU3ViIElGRCBQb2ludGVyOlxuICAgIGlmIChkYXRhLmV4aWZbMHg4NzY5XSAmJiAhb3B0aW9ucy5kaXNhYmxlRXhpZlN1Yikge1xuICAgICAgbG9hZEltYWdlLnBhcnNlRXhpZlRhZ3MoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0LFxuICAgICAgICB0aWZmT2Zmc2V0ICsgZGF0YS5leGlmWzB4ODc2OV0sIC8vIGRpcmVjdG9yeSBvZmZzZXRcbiAgICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgICBkYXRhXG4gICAgICApXG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBHUFMgSW5mbyBJRkQgUG9pbnRlcjpcbiAgICBpZiAoZGF0YS5leGlmWzB4ODgyNV0gJiYgIW9wdGlvbnMuZGlzYWJsZUV4aWZHcHMpIHtcbiAgICAgIGxvYWRJbWFnZS5wYXJzZUV4aWZUYWdzKFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCxcbiAgICAgICAgdGlmZk9mZnNldCArIGRhdGEuZXhpZlsweDg4MjVdLCAvLyBkaXJlY3Rvcnkgb2Zmc2V0XG4gICAgICAgIGxpdHRsZUVuZGlhbixcbiAgICAgICAgZGF0YVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVycyB0aGUgRXhpZiBwYXJzZXIgZm9yIHRoZSBBUFAxIEpQRUcgbWV0YSBkYXRhIHNlZ21lbnQ6XG4gIGxvYWRJbWFnZS5tZXRhRGF0YVBhcnNlcnMuanBlZ1sweGZmZTFdLnB1c2gobG9hZEltYWdlLnBhcnNlRXhpZkRhdGEpXG5cbiAgbG9hZEltYWdlLmV4aWZXcml0ZXJzID0ge1xuICAgIC8vIE9yaWVudGF0aW9uIHdyaXRlcjpcbiAgICAweDAxMTI6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEsIHZhbHVlKSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIsIGRhdGEuZXhpZk9mZnNldHNbMHgwMTEyXSArIDgsIDIpXG4gICAgICB2aWV3LnNldFVpbnQxNigwLCB2YWx1ZSwgZGF0YS5leGlmTGl0dGxlRW5kaWFuKVxuICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGxvYWRJbWFnZS53cml0ZUV4aWZEYXRhID0gZnVuY3Rpb24gKGJ1ZmZlciwgZGF0YSwgaWQsIHZhbHVlKSB7XG4gICAgbG9hZEltYWdlLmV4aWZXcml0ZXJzW2RhdGEuZXhpZi5tYXBbaWRdXShidWZmZXIsIGRhdGEsIHZhbHVlKVxuICB9XG5cbiAgLy8gQWRkcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgdG8gdGhlIHBhcnNlTWV0YURhdGEgY2FsbGJhY2sgZGF0YTpcbiAgLy8gKiBleGlmOiBUaGUgcGFyc2VkIEV4aWYgdGFnc1xuICAvLyAqIGV4aWZPZmZzZXRzOiBUaGUgcGFyc2VkIEV4aWYgdGFnIG9mZnNldHNcbiAgLy8gKiBleGlmVGlmZk9mZnNldDogVElGRiBoZWFkZXIgb2Zmc2V0ICh1c2VkIGZvciBvZmZzZXQgcG9pbnRlcnMpXG4gIC8vICogZXhpZkxpdHRsZUVuZGlhbjogbGl0dGxlIGVuZGlhbiBvcmRlciBpZiB0cnVlLCBiaWcgZW5kaWFuIGlmIGZhbHNlXG5cbiAgLy8gQWRkcyB0aGUgZm9sbG93aW5nIG9wdGlvbnMgdG8gdGhlIHBhcnNlTWV0YURhdGEgbWV0aG9kOlxuICAvLyAqIGRpc2FibGVFeGlmOiBEaXNhYmxlcyBFeGlmIHBhcnNpbmcuXG4gIC8vICogZGlzYWJsZUV4aWZUaHVtYm5haWw6IERpc2FibGVzIHBhcnNpbmcgb2YgdGhlIEV4aWYgVGh1bWJuYWlsLlxuICAvLyAqIGRpc2FibGVFeGlmU3ViOiBEaXNhYmxlcyBwYXJzaW5nIG9mIHRoZSBFeGlmIFN1YiBJRkQuXG4gIC8vICogZGlzYWJsZUV4aWZHcHM6IERpc2FibGVzIHBhcnNpbmcgb2YgdGhlIEV4aWYgR1BTIEluZm8gSUZELlxuICAvLyAqIGRpc2FibGVFeGlmT2Zmc2V0czogRGlzYWJsZXMgc3RvcmluZyBFeGlmIHRhZyBvZmZzZXRzXG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-fetch.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  if (typeof fetch !== 'undefined' && typeof Request !== 'undefined') {\n    loadImage.fetchBlob = function (url, callback, options) {\n      if (loadImage.hasMetaOption(options)) {\n        fetch(new Request(url, options))\n          .then(function (response) {\n            return response.blob()\n          })\n          .then(callback)\n          .catch(function (err) {\n            console.log(err) // eslint-disable-line no-console\n            callback()\n          })\n      } else {\n        callback()\n      }\n    }\n  } else if (\n    // Check for XHR2 support:\n    typeof XMLHttpRequest !== 'undefined' &&\n    typeof ProgressEvent !== 'undefined'\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      if (loadImage.hasMetaOption(options)) {\n        // eslint-disable-next-line no-param-reassign\n        options = options || {}\n        var req = new XMLHttpRequest()\n        req.open(options.method || 'GET', url)\n        if (options.headers) {\n          Object.keys(options.headers).forEach(function (key) {\n            req.setRequestHeader(key, options.headers[key])\n          })\n        }\n        req.withCredentials = options.credentials === 'include'\n        req.responseType = 'blob'\n        req.onload = function () {\n          callback(req.response)\n        }\n        req.onerror = req.onabort = req.ontimeout = function (e) {\n          console.log(e) // eslint-disable-line no-console\n          callback()\n        }\n        req.send(options.body)\n      } else {\n        callback()\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZmV0Y2guanM/YWQyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRCxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1mZXRjaC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgRmV0Y2hcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDE3LCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtbWV0YSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvYWRJbWFnZS5mZXRjaEJsb2IgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKGxvYWRJbWFnZS5oYXNNZXRhT3B0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGZldGNoKG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9ucykpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAvLyBDaGVjayBmb3IgWEhSMiBzdXBwb3J0OlxuICAgIHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgUHJvZ3Jlc3NFdmVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgbG9hZEltYWdlLmZldGNoQmxvYiA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAobG9hZEltYWdlLmhhc01ldGFPcHRpb24ob3B0aW9ucykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKVxuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0aW9ucy5oZWFkZXJzW2tleV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnXG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXEucmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgICAgcmVxLm9uZXJyb3IgPSByZXEub25hYm9ydCA9IHJlcS5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChvcHRpb25zLmJvZHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-fetch.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://github.com/jseidelin/exif-js\n * https://iptc.org/standards/photo-metadata\n * http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  loadImage.IptcMap.prototype.tags = {\n    // ==========\n    // IPTC tags:\n    // ==========\n    0x03: 'ObjectType',\n    0x04: 'ObjectAttribute',\n    0x05: 'ObjectName',\n    0x07: 'EditStatus',\n    0x08: 'EditorialUpdate',\n    0x0a: 'Urgency',\n    0x0c: 'SubjectRef',\n    0x0f: 'Category',\n    0x14: 'SupplCategory',\n    0x16: 'FixtureID',\n    0x19: 'Keywords',\n    0x1a: 'ContentLocCode',\n    0x1b: 'ContentLocName',\n    0x1e: 'ReleaseDate',\n    0x23: 'ReleaseTime',\n    0x25: 'ExpirationDate',\n    0x26: 'ExpirationTime',\n    0x28: 'SpecialInstructions',\n    0x2a: 'ActionAdvised',\n    0x2d: 'RefService',\n    0x2f: 'RefDate',\n    0x32: 'RefNumber',\n    0x37: 'DateCreated',\n    0x3c: 'TimeCreated',\n    0x3e: 'DigitalCreationDate',\n    0x3f: 'DigitalCreationTime',\n    0x41: 'OriginatingProgram',\n    0x46: 'ProgramVersion',\n    0x4b: 'ObjectCycle',\n    0x50: 'Byline',\n    0x55: 'BylineTitle',\n    0x5a: 'City',\n    0x5c: 'Sublocation',\n    0x5f: 'State',\n    0x64: 'CountryCode',\n    0x65: 'CountryName',\n    0x67: 'OrigTransRef',\n    0x69: 'Headline',\n    0x6e: 'Credit',\n    0x73: 'Source',\n    0x74: 'CopyrightNotice',\n    0x76: 'Contact',\n    0x78: 'Caption',\n    0x7a: 'WriterEditor',\n    0x82: 'ImageType',\n    0x83: 'ImageOrientation',\n    0x87: 'LanguageID'\n\n    // We don't record these tags:\n    //\n    // 0x00: 'RecordVersion',\n    // 0x7d: 'RasterizedCaption',\n    // 0x96: 'AudioType',\n    // 0x97: 'AudioSamplingRate',\n    // 0x98: 'AudioSamplingRes',\n    // 0x99: 'AudioDuration',\n    // 0x9a: 'AudioOutcue',\n    // 0xc8: 'PreviewFileFormat',\n    // 0xc9: 'PreviewFileFormatVer',\n    // 0xca: 'PreviewData'\n  }\n\n  loadImage.IptcMap.prototype.getText = function (id) {\n    var value = this.get(id)\n    return String(value)\n  }\n  ;(function (iptcMapPrototype) {\n    var tags = iptcMapPrototype.tags\n    var map = iptcMapPrototype.map || {}\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = prop\n      }\n    }\n  })(loadImage.IptcMap.prototype)\n\n  loadImage.IptcMap.prototype.getAll = function () {\n    var map = {}\n    var prop\n    var id\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        id = this.tags[prop]\n        if (id) {\n          map[id] = this.getText(id)\n        }\n      }\n    }\n    return map\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanM/ZTkxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUQsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIElQVEMgTWFwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogQ29weXJpZ2h0IDIwMTgsIERhdmUgQmV2YW5cbiAqXG4gKiBJUFRDIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZWlkZWxpbi9leGlmLWpzXG4gKiBodHRwczovL2lwdGMub3JnL3N0YW5kYXJkcy9waG90by1tZXRhZGF0YVxuICogaHR0cDovL3d3dy5pcHRjLm9yZy9zdGQvSUlNLzQuMS9zcGVjaWZpY2F0aW9uL0lJTVY0LjEucGRmXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2UtaXB0YyddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSwgcmVxdWlyZSgnLi9sb2FkLWltYWdlLWlwdGMnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGxvYWRJbWFnZS5JcHRjTWFwLnByb3RvdHlwZS50YWdzID0ge1xuICAgIC8vID09PT09PT09PT1cbiAgICAvLyBJUFRDIHRhZ3M6XG4gICAgLy8gPT09PT09PT09PVxuICAgIDB4MDM6ICdPYmplY3RUeXBlJyxcbiAgICAweDA0OiAnT2JqZWN0QXR0cmlidXRlJyxcbiAgICAweDA1OiAnT2JqZWN0TmFtZScsXG4gICAgMHgwNzogJ0VkaXRTdGF0dXMnLFxuICAgIDB4MDg6ICdFZGl0b3JpYWxVcGRhdGUnLFxuICAgIDB4MGE6ICdVcmdlbmN5JyxcbiAgICAweDBjOiAnU3ViamVjdFJlZicsXG4gICAgMHgwZjogJ0NhdGVnb3J5JyxcbiAgICAweDE0OiAnU3VwcGxDYXRlZ29yeScsXG4gICAgMHgxNjogJ0ZpeHR1cmVJRCcsXG4gICAgMHgxOTogJ0tleXdvcmRzJyxcbiAgICAweDFhOiAnQ29udGVudExvY0NvZGUnLFxuICAgIDB4MWI6ICdDb250ZW50TG9jTmFtZScsXG4gICAgMHgxZTogJ1JlbGVhc2VEYXRlJyxcbiAgICAweDIzOiAnUmVsZWFzZVRpbWUnLFxuICAgIDB4MjU6ICdFeHBpcmF0aW9uRGF0ZScsXG4gICAgMHgyNjogJ0V4cGlyYXRpb25UaW1lJyxcbiAgICAweDI4OiAnU3BlY2lhbEluc3RydWN0aW9ucycsXG4gICAgMHgyYTogJ0FjdGlvbkFkdmlzZWQnLFxuICAgIDB4MmQ6ICdSZWZTZXJ2aWNlJyxcbiAgICAweDJmOiAnUmVmRGF0ZScsXG4gICAgMHgzMjogJ1JlZk51bWJlcicsXG4gICAgMHgzNzogJ0RhdGVDcmVhdGVkJyxcbiAgICAweDNjOiAnVGltZUNyZWF0ZWQnLFxuICAgIDB4M2U6ICdEaWdpdGFsQ3JlYXRpb25EYXRlJyxcbiAgICAweDNmOiAnRGlnaXRhbENyZWF0aW9uVGltZScsXG4gICAgMHg0MTogJ09yaWdpbmF0aW5nUHJvZ3JhbScsXG4gICAgMHg0NjogJ1Byb2dyYW1WZXJzaW9uJyxcbiAgICAweDRiOiAnT2JqZWN0Q3ljbGUnLFxuICAgIDB4NTA6ICdCeWxpbmUnLFxuICAgIDB4NTU6ICdCeWxpbmVUaXRsZScsXG4gICAgMHg1YTogJ0NpdHknLFxuICAgIDB4NWM6ICdTdWJsb2NhdGlvbicsXG4gICAgMHg1ZjogJ1N0YXRlJyxcbiAgICAweDY0OiAnQ291bnRyeUNvZGUnLFxuICAgIDB4NjU6ICdDb3VudHJ5TmFtZScsXG4gICAgMHg2NzogJ09yaWdUcmFuc1JlZicsXG4gICAgMHg2OTogJ0hlYWRsaW5lJyxcbiAgICAweDZlOiAnQ3JlZGl0JyxcbiAgICAweDczOiAnU291cmNlJyxcbiAgICAweDc0OiAnQ29weXJpZ2h0Tm90aWNlJyxcbiAgICAweDc2OiAnQ29udGFjdCcsXG4gICAgMHg3ODogJ0NhcHRpb24nLFxuICAgIDB4N2E6ICdXcml0ZXJFZGl0b3InLFxuICAgIDB4ODI6ICdJbWFnZVR5cGUnLFxuICAgIDB4ODM6ICdJbWFnZU9yaWVudGF0aW9uJyxcbiAgICAweDg3OiAnTGFuZ3VhZ2VJRCdcblxuICAgIC8vIFdlIGRvbid0IHJlY29yZCB0aGVzZSB0YWdzOlxuICAgIC8vXG4gICAgLy8gMHgwMDogJ1JlY29yZFZlcnNpb24nLFxuICAgIC8vIDB4N2Q6ICdSYXN0ZXJpemVkQ2FwdGlvbicsXG4gICAgLy8gMHg5NjogJ0F1ZGlvVHlwZScsXG4gICAgLy8gMHg5NzogJ0F1ZGlvU2FtcGxpbmdSYXRlJyxcbiAgICAvLyAweDk4OiAnQXVkaW9TYW1wbGluZ1JlcycsXG4gICAgLy8gMHg5OTogJ0F1ZGlvRHVyYXRpb24nLFxuICAgIC8vIDB4OWE6ICdBdWRpb091dGN1ZScsXG4gICAgLy8gMHhjODogJ1ByZXZpZXdGaWxlRm9ybWF0JyxcbiAgICAvLyAweGM5OiAnUHJldmlld0ZpbGVGb3JtYXRWZXInLFxuICAgIC8vIDB4Y2E6ICdQcmV2aWV3RGF0YSdcbiAgfVxuXG4gIGxvYWRJbWFnZS5JcHRjTWFwLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaWQpXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgfVxuICA7KGZ1bmN0aW9uIChpcHRjTWFwUHJvdG90eXBlKSB7XG4gICAgdmFyIHRhZ3MgPSBpcHRjTWFwUHJvdG90eXBlLnRhZ3NcbiAgICB2YXIgbWFwID0gaXB0Y01hcFByb3RvdHlwZS5tYXAgfHwge31cbiAgICB2YXIgcHJvcFxuICAgIC8vIE1hcCB0aGUgdGFnIG5hbWVzIHRvIHRhZ3M6XG4gICAgZm9yIChwcm9wIGluIHRhZ3MpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFncywgcHJvcCkpIHtcbiAgICAgICAgbWFwW3RhZ3NbcHJvcF1dID0gcHJvcFxuICAgICAgfVxuICAgIH1cbiAgfSkobG9hZEltYWdlLklwdGNNYXAucHJvdG90eXBlKVxuXG4gIGxvYWRJbWFnZS5JcHRjTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IHt9XG4gICAgdmFyIHByb3BcbiAgICB2YXIgaWRcbiAgICBmb3IgKHByb3AgaW4gdGhpcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wKSkge1xuICAgICAgICBpZCA9IHRoaXMudGFnc1twcm9wXVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBtYXBbaWRdID0gdGhpcy5nZXRUZXh0KGlkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Buffer */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  loadImage.IptcMap = function () {\n    return this\n  }\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  }\n\n  loadImage.IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  loadImage.parseIptcTags = function (\n    dataView,\n    startOffset,\n    sectionLength,\n    data\n  ) {\n    /**\n     * Retrieves string for the given Buffer and range\n     *\n     * @param {Buffer} buffer IPTC buffer\n     * @param {number} start Range start\n     * @param {number} length Range length\n     * @returns {string} String value\n     */\n    function getStringFromDB(buffer, start, length) {\n      var outstr = ''\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n))\n      }\n      return outstr\n    }\n    var fieldValue, dataSize, segmentType\n    var segmentStartPos = startOffset\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (\n        dataView.getUint8(segmentStartPos) === 0x1c &&\n        dataView.getUint8(segmentStartPos + 1) === 0x02\n      ) {\n        segmentType = dataView.getUint8(segmentStartPos + 2)\n        // only store data for known tags\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3)\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize)\n          // Check if we already stored a value with this name\n          if (Object.prototype.hasOwnProperty.call(data.iptc, segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue)\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue]\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue\n          }\n        }\n      }\n      segmentStartPos++\n    }\n  }\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    // Found '8BIM<EOT><EOT>' ?\n    var isFieldSegmentStart = function (dataView, offset) {\n      return (\n        dataView.getUint32(offset) === 0x3842494d &&\n        dataView.getUint16(offset + 4) === 0x0404\n      )\n    }\n    // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7)\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1\n        // Check for pre photoshop 6 format\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4\n        }\n        var startOffset = offset + 8 + nameHeaderLength\n        if (startOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength)\n        if (offset + sectionLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new loadImage.IptcMap()\n        // Parse the tags\n        return loadImage.parseIptcTags(\n          dataView,\n          startOffset,\n          sectionLength,\n          data\n        )\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset++\n    }\n    // eslint-disable-next-line no-console\n    console.log('No IPTC data at this offset - could be XMP')\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG meta data segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy5qcz85ZmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUQsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1pcHRjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBJUFRDIFBhcnNlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIENvcHlyaWdodCAyMDE4LCBEYXZlIEJldmFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIEJ1ZmZlciAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJywgJy4vbG9hZC1pbWFnZS1tZXRhJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpLCByZXF1aXJlKCcuL2xvYWQtaW1hZ2UtbWV0YScpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgbG9hZEltYWdlLklwdGNNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxvYWRJbWFnZS5JcHRjTWFwLnByb3RvdHlwZS5tYXAgPSB7XG4gICAgT2JqZWN0TmFtZTogMHg1XG4gIH1cblxuICBsb2FkSW1hZ2UuSXB0Y01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8IHRoaXNbdGhpcy5tYXBbaWRdXVxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlSXB0Y1RhZ3MgPSBmdW5jdGlvbiAoXG4gICAgZGF0YVZpZXcsXG4gICAgc3RhcnRPZmZzZXQsXG4gICAgc2VjdGlvbkxlbmd0aCxcbiAgICBkYXRhXG4gICkge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBzdHJpbmcgZm9yIHRoZSBnaXZlbiBCdWZmZXIgYW5kIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIElQVEMgYnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFJhbmdlIHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBSYW5nZSBsZW5ndGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdHJpbmdGcm9tREIoYnVmZmVyLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgb3V0c3RyID0gJydcbiAgICAgIGZvciAodmFyIG4gPSBzdGFydDsgbiA8IHN0YXJ0ICsgbGVuZ3RoOyBuKyspIHtcbiAgICAgICAgb3V0c3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyLmdldFVpbnQ4KG4pKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHN0clxuICAgIH1cbiAgICB2YXIgZmllbGRWYWx1ZSwgZGF0YVNpemUsIHNlZ21lbnRUeXBlXG4gICAgdmFyIHNlZ21lbnRTdGFydFBvcyA9IHN0YXJ0T2Zmc2V0XG4gICAgd2hpbGUgKHNlZ21lbnRTdGFydFBvcyA8IHN0YXJ0T2Zmc2V0ICsgc2VjdGlvbkxlbmd0aCkge1xuICAgICAgLy8gd2UgY3VycmVudGx5IGhhbmRsZSB0aGUgMjogY2xhc3Mgb2YgaXB0YyB0YWdcbiAgICAgIGlmIChcbiAgICAgICAgZGF0YVZpZXcuZ2V0VWludDgoc2VnbWVudFN0YXJ0UG9zKSA9PT0gMHgxYyAmJlxuICAgICAgICBkYXRhVmlldy5nZXRVaW50OChzZWdtZW50U3RhcnRQb3MgKyAxKSA9PT0gMHgwMlxuICAgICAgKSB7XG4gICAgICAgIHNlZ21lbnRUeXBlID0gZGF0YVZpZXcuZ2V0VWludDgoc2VnbWVudFN0YXJ0UG9zICsgMilcbiAgICAgICAgLy8gb25seSBzdG9yZSBkYXRhIGZvciBrbm93biB0YWdzXG4gICAgICAgIGlmIChzZWdtZW50VHlwZSBpbiBkYXRhLmlwdGMudGFncykge1xuICAgICAgICAgIGRhdGFTaXplID0gZGF0YVZpZXcuZ2V0SW50MTYoc2VnbWVudFN0YXJ0UG9zICsgMylcbiAgICAgICAgICBmaWVsZFZhbHVlID0gZ2V0U3RyaW5nRnJvbURCKGRhdGFWaWV3LCBzZWdtZW50U3RhcnRQb3MgKyA1LCBkYXRhU2l6ZSlcbiAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IHN0b3JlZCBhIHZhbHVlIHdpdGggdGhpcyBuYW1lXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmlwdGMsIHNlZ21lbnRUeXBlKSkge1xuICAgICAgICAgICAgLy8gVmFsdWUgYWxyZWFkeSBzdG9yZWQgd2l0aCB0aGlzIG5hbWUsIGNyZWF0ZSBtdWx0aXZhbHVlIGZpZWxkXG4gICAgICAgICAgICBpZiAoZGF0YS5pcHRjW3NlZ21lbnRUeXBlXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGRhdGEuaXB0Y1tzZWdtZW50VHlwZV0ucHVzaChmaWVsZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YS5pcHRjW3NlZ21lbnRUeXBlXSA9IFtkYXRhLmlwdGNbc2VnbWVudFR5cGVdLCBmaWVsZFZhbHVlXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmlwdGNbc2VnbWVudFR5cGVdID0gZmllbGRWYWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VnbWVudFN0YXJ0UG9zKytcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2UucGFyc2VJcHRjRGF0YSA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlSXB0Yykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBtYXJrZXJMZW5ndGggPSBvZmZzZXQgKyBsZW5ndGhcbiAgICAvLyBGb3VuZCAnOEJJTTxFT1Q+PEVPVD4nID9cbiAgICB2YXIgaXNGaWVsZFNlZ21lbnRTdGFydCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KSA9PT0gMHgzODQyNDk0ZCAmJlxuICAgICAgICBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgNCkgPT09IDB4MDQwNFxuICAgICAgKVxuICAgIH1cbiAgICAvLyBIdW50IGZvcndhcmQsIGxvb2tpbmcgZm9yIHRoZSBjb3JyZWN0IElQVEMgYmxvY2sgc2lnbmF0dXJlOlxuICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9tZXRhY3Bhbi5vcmcvcG9kL2Rpc3RyaWJ1dGlvbi9JbWFnZS1NZXRhRGF0YS1KUEVHL2xpYi9JbWFnZS9NZXRhRGF0YS9KUEVHL1N0cnVjdHVyZXMucG9kI1N0cnVjdHVyZS1vZi1hLVBob3Rvc2hvcC1zdHlsZS1BUFAxMy1zZWdtZW50XG4gICAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXhpZi1qcy9leGlmLWpzL2Jsb2IvbWFzdGVyL2V4aWYuanMgfiBsaW5lIDQ3NCBvblxuICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgbWFya2VyTGVuZ3RoKSB7XG4gICAgICBpZiAoaXNGaWVsZFNlZ21lbnRTdGFydChkYXRhVmlldywgb2Zmc2V0KSkge1xuICAgICAgICB2YXIgbmFtZUhlYWRlckxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDcpXG4gICAgICAgIGlmIChuYW1lSGVhZGVyTGVuZ3RoICUgMiAhPT0gMCkgbmFtZUhlYWRlckxlbmd0aCArPSAxXG4gICAgICAgIC8vIENoZWNrIGZvciBwcmUgcGhvdG9zaG9wIDYgZm9ybWF0XG4gICAgICAgIGlmIChuYW1lSGVhZGVyTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gQWx3YXlzIDRcbiAgICAgICAgICBuYW1lSGVhZGVyTGVuZ3RoID0gNFxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldCArIDggKyBuYW1lSGVhZGVyTGVuZ3RoXG4gICAgICAgIGlmIChzdGFydE9mZnNldCA+IG1hcmtlckxlbmd0aCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSVBUQyBkYXRhOiBJbnZhbGlkIHNlZ21lbnQgb2Zmc2V0LicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VjdGlvbkxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA2ICsgbmFtZUhlYWRlckxlbmd0aClcbiAgICAgICAgaWYgKG9mZnNldCArIHNlY3Rpb25MZW5ndGggPiBtYXJrZXJMZW5ndGgpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIElQVEMgZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaXB0YyBvYmplY3QgdG8gc3RvcmUgdGhlIHRhZ3M6XG4gICAgICAgIGRhdGEuaXB0YyA9IG5ldyBsb2FkSW1hZ2UuSXB0Y01hcCgpXG4gICAgICAgIC8vIFBhcnNlIHRoZSB0YWdzXG4gICAgICAgIHJldHVybiBsb2FkSW1hZ2UucGFyc2VJcHRjVGFncyhcbiAgICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgICBzdGFydE9mZnNldCxcbiAgICAgICAgICBzZWN0aW9uTGVuZ3RoLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBvZmZzZXQrK1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKCdObyBJUFRDIGRhdGEgYXQgdGhpcyBvZmZzZXQgLSBjb3VsZCBiZSBYTVAnKVxuICB9XG5cbiAgLy8gUmVnaXN0ZXJzIHRoaXMgSVBUQyBwYXJzZXIgZm9yIHRoZSBBUFAxMyBKUEVHIG1ldGEgZGF0YSBzZWdtZW50OlxuICBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzLmpwZWdbMHhmZmVkXS5wdXNoKGxvYWRJbWFnZS5wYXJzZUlwdGNEYXRhKVxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBwYXJzZU1ldGFEYXRhIGNhbGxiYWNrIGRhdGE6XG4gIC8vICogaXB0YzogVGhlIGlwdGMgdGFncywgcGFyc2VkIGJ5IHRoZSBwYXJzZUlwdGNEYXRhIG1ldGhvZFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIHRoZSBwYXJzZU1ldGFEYXRhIG1ldGhvZDpcbiAgLy8gKiBkaXNhYmxlSXB0YzogRGlzYWJsZXMgSVBUQyBwYXJzaW5nLlxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-meta.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var hasblobSlice =\n    typeof Blob !== 'undefined' &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  loadImage.blobSlice =\n    hasblobSlice &&\n    function () {\n      var slice = this.slice || this.webkitSlice || this.mozSlice\n      return slice.apply(this, arguments)\n    }\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var that = this\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\n    var noMetaData = !(\n      typeof DataView !== 'undefined' &&\n      file &&\n      file.size >= 12 &&\n      file.type === 'image/jpeg' &&\n      loadImage.blobSlice\n    )\n    if (\n      noMetaData ||\n      !loadImage.readFile(\n        loadImage.blobSlice.call(file, 0, maxMetaDataSize),\n        function (e) {\n          if (e.target.error) {\n            // FileReader error\n            // eslint-disable-next-line no-console\n            console.log(e.target.error)\n            callback(data)\n            return\n          }\n          // Note on endianness:\n          // Since the marker and length bytes in JPEG files are always\n          // stored in big endian order, we can leave the endian parameter\n          // of the DataView methods undefined, defaulting to big endian.\n          var buffer = e.target.result\n          var dataView = new DataView(buffer)\n          var offset = 2\n          var maxOffset = dataView.byteLength - 4\n          var headLength = offset\n          var markerBytes\n          var markerLength\n          var parsers\n          var i\n          // Check for the JPEG marker (0xffd8):\n          if (dataView.getUint16(0) === 0xffd8) {\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific meta-data like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid meta data: Invalid segment size.')\n                  break\n                }\n                parsers = loadImage.metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the meta data\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              if (buffer.slice) {\n                data.imageHead = buffer.slice(0, headLength)\n              } else {\n                // Workaround for IE10, which does not yet\n                // support ArrayBuffer.slice:\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\n              }\n            }\n          } else {\n            // eslint-disable-next-line no-console\n            console.log('Invalid JPEG file: Missing JPEG marker.')\n          }\n          callback(data)\n        },\n        'readAsArrayBuffer'\n      )\n    ) {\n      callback(data)\n    }\n  }\n\n  // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(\n      blob,\n      function (data) {\n        callback(\n          new Blob(\n            [head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)],\n            { type: 'image/jpeg' }\n          )\n        )\n      },\n      { maxMetaDataSize: 256, disableMetaDataParsers: true }\n    )\n  }\n\n  // Determines if meta data should be loaded automatically:\n  loadImage.hasMetaOption = function (options) {\n    return options && options.meta\n  }\n\n  var originalTransform = loadImage.transform\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(\n        file,\n        function (data) {\n          originalTransform.call(loadImage, img, options, callback, file, data)\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcz8wNzhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDckMsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgTWV0YVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBJbWFnZSBtZXRhIGRhdGEgaGFuZGxpbmcgaW1wbGVtZW50YXRpb25cbiAqIGJhc2VkIG9uIHRoZSBoZWxwIGFuZCBjb250cmlidXRpb24gb2ZcbiAqIEFjaGltIFN0w7Zoci5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSwgRGF0YVZpZXcsIFVpbnQ4QXJyYXkgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBoYXNibG9iU2xpY2UgPVxuICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIChCbG9iLnByb3RvdHlwZS5zbGljZSB8fFxuICAgICAgQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2UgfHxcbiAgICAgIEJsb2IucHJvdG90eXBlLm1velNsaWNlKVxuXG4gIGxvYWRJbWFnZS5ibG9iU2xpY2UgPVxuICAgIGhhc2Jsb2JTbGljZSAmJlxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2UgfHwgdGhpcy53ZWJraXRTbGljZSB8fCB0aGlzLm1velNsaWNlXG4gICAgICByZXR1cm4gc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH1cblxuICBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzID0ge1xuICAgIGpwZWc6IHtcbiAgICAgIDB4ZmZlMTogW10sIC8vIEFQUDEgbWFya2VyXG4gICAgICAweGZmZWQ6IFtdIC8vIEFQUDEzIG1hcmtlclxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlcyBpbWFnZSBtZXRhIGRhdGEgYW5kIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIGFuIG9iamVjdCBhcmd1bWVudFxuICAvLyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgLy8gKiBpbWFnZUhlYWQ6IFRoZSBjb21wbGV0ZSBpbWFnZSBoZWFkIGFzIEFycmF5QnVmZmVyIChVaW50OEFycmF5IGZvciBJRTEwKVxuICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBhY2NlcHRzIGFuIG9iamVjdCBhbmQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZ1xuICAvLyBwcm9wZXJ0aWVzOlxuICAvLyAqIG1heE1ldGFEYXRhU2l6ZTogRGVmaW5lcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFyc2UuXG4gIC8vICogZGlzYWJsZUltYWdlSGVhZDogRGlzYWJsZXMgY3JlYXRpbmcgdGhlIGltYWdlSGVhZCBwcm9wZXJ0eS5cbiAgbG9hZEltYWdlLnBhcnNlTWV0YURhdGEgPSBmdW5jdGlvbiAoZmlsZSwgY2FsbGJhY2ssIG9wdGlvbnMsIGRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGRhdGEgPSBkYXRhIHx8IHt9XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLy8gMjU2IEtpQiBzaG91bGQgY29udGFpbiBhbGwgRVhJRi9JQ0MvSVBUQyBzZWdtZW50czpcbiAgICB2YXIgbWF4TWV0YURhdGFTaXplID0gb3B0aW9ucy5tYXhNZXRhRGF0YVNpemUgfHwgMjYyMTQ0XG4gICAgdmFyIG5vTWV0YURhdGEgPSAhKFxuICAgICAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZmlsZSAmJlxuICAgICAgZmlsZS5zaXplID49IDEyICYmXG4gICAgICBmaWxlLnR5cGUgPT09ICdpbWFnZS9qcGVnJyAmJlxuICAgICAgbG9hZEltYWdlLmJsb2JTbGljZVxuICAgIClcbiAgICBpZiAoXG4gICAgICBub01ldGFEYXRhIHx8XG4gICAgICAhbG9hZEltYWdlLnJlYWRGaWxlKFxuICAgICAgICBsb2FkSW1hZ2UuYmxvYlNsaWNlLmNhbGwoZmlsZSwgMCwgbWF4TWV0YURhdGFTaXplKSxcbiAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEZpbGVSZWFkZXIgZXJyb3JcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC5lcnJvcilcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90ZSBvbiBlbmRpYW5uZXNzOlxuICAgICAgICAgIC8vIFNpbmNlIHRoZSBtYXJrZXIgYW5kIGxlbmd0aCBieXRlcyBpbiBKUEVHIGZpbGVzIGFyZSBhbHdheXNcbiAgICAgICAgICAvLyBzdG9yZWQgaW4gYmlnIGVuZGlhbiBvcmRlciwgd2UgY2FuIGxlYXZlIHRoZSBlbmRpYW4gcGFyYW1ldGVyXG4gICAgICAgICAgLy8gb2YgdGhlIERhdGFWaWV3IG1ldGhvZHMgdW5kZWZpbmVkLCBkZWZhdWx0aW5nIHRvIGJpZyBlbmRpYW4uXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGUudGFyZ2V0LnJlc3VsdFxuICAgICAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDJcbiAgICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gZGF0YVZpZXcuYnl0ZUxlbmd0aCAtIDRcbiAgICAgICAgICB2YXIgaGVhZExlbmd0aCA9IG9mZnNldFxuICAgICAgICAgIHZhciBtYXJrZXJCeXRlc1xuICAgICAgICAgIHZhciBtYXJrZXJMZW5ndGhcbiAgICAgICAgICB2YXIgcGFyc2Vyc1xuICAgICAgICAgIHZhciBpXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBKUEVHIG1hcmtlciAoMHhmZmQ4KTpcbiAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KDApID09PSAweGZmZDgpIHtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgbWFya2VyQnl0ZXMgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KVxuICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIEFQUG4gKDB4ZmZlTikgYW5kIENPTSAoMHhmZmZlKSBtYXJrZXJzLFxuICAgICAgICAgICAgICAvLyB3aGljaCBjb250YWluIGFwcGxpY2F0aW9uLXNwZWNpZmljIG1ldGEtZGF0YSBsaWtlXG4gICAgICAgICAgICAgIC8vIEV4aWYsIElDQyBhbmQgSVBUQyBkYXRhIGFuZCB0ZXh0IGNvbW1lbnRzOlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKG1hcmtlckJ5dGVzID49IDB4ZmZlMCAmJiBtYXJrZXJCeXRlcyA8PSAweGZmZWYpIHx8XG4gICAgICAgICAgICAgICAgbWFya2VyQnl0ZXMgPT09IDB4ZmZmZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWFya2VyIGJ5dGVzICgyKSBhcmUgYWx3YXlzIGZvbGxvd2VkIGJ5XG4gICAgICAgICAgICAgICAgLy8gdGhlIGxlbmd0aCBieXRlcyAoMiksIGluZGljYXRpbmcgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBtYXJrZXIgc2VnbWVudCwgd2hpY2ggaW5jbHVkZXMgdGhlIGxlbmd0aCBieXRlcyxcbiAgICAgICAgICAgICAgICAvLyBidXQgbm90IHRoZSBtYXJrZXIgYnl0ZXMsIHNvIHdlIGFkZCAyOlxuICAgICAgICAgICAgICAgIG1hcmtlckxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKSArIDJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgbWFya2VyTGVuZ3RoID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIG1ldGEgZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJylcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlcnMgPSBsb2FkSW1hZ2UubWV0YURhdGFQYXJzZXJzLmpwZWdbbWFya2VyQnl0ZXNdXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlcnMgJiYgIW9wdGlvbnMuZGlzYWJsZU1ldGFEYXRhUGFyc2Vycykge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnNlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Vyc1tpXS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gbWFya2VyTGVuZ3RoXG4gICAgICAgICAgICAgICAgaGVhZExlbmd0aCA9IG9mZnNldFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhbiBBUFBuIG9yIENPTSBtYXJrZXIsIHByb2JhYmx5IHNhZmUgdG9cbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUgdGhhdCB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIG1ldGEgZGF0YVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ldGEgbGVuZ3RoIG11c3QgYmUgbG9uZ2VyIHRoYW4gSlBFRyBtYXJrZXIgKDIpXG4gICAgICAgICAgICAvLyBwbHVzIEFQUG4gbWFya2VyICgyKSwgZm9sbG93ZWQgYnkgbGVuZ3RoIGJ5dGVzICgyKTpcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlSW1hZ2VIZWFkICYmIGhlYWRMZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgIGlmIChidWZmZXIuc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmltYWdlSGVhZCA9IGJ1ZmZlci5zbGljZSgwLCBoZWFkTGVuZ3RoKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIElFMTAsIHdoaWNoIGRvZXMgbm90IHlldFxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgQXJyYXlCdWZmZXIuc2xpY2U6XG4gICAgICAgICAgICAgICAgZGF0YS5pbWFnZUhlYWQgPSBuZXcgVWludDhBcnJheShidWZmZXIpLnN1YmFycmF5KDAsIGhlYWRMZW5ndGgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEpQRUcgZmlsZTogTWlzc2luZyBKUEVHIG1hcmtlci4nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhkYXRhKVxuICAgICAgICB9LFxuICAgICAgICAncmVhZEFzQXJyYXlCdWZmZXInXG4gICAgICApXG4gICAgKSB7XG4gICAgICBjYWxsYmFjayhkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlcGxhY2VzIHRoZSBpbWFnZSBoZWFkIG9mIGEgSlBFRyBibG9iIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgLy8gQ2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIG5ldyBCbG9iOlxuICBsb2FkSW1hZ2UucmVwbGFjZUhlYWQgPSBmdW5jdGlvbiAoYmxvYiwgaGVhZCwgY2FsbGJhY2spIHtcbiAgICBsb2FkSW1hZ2UucGFyc2VNZXRhRGF0YShcbiAgICAgIGJsb2IsXG4gICAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgQmxvYihcbiAgICAgICAgICAgIFtoZWFkLCBsb2FkSW1hZ2UuYmxvYlNsaWNlLmNhbGwoYmxvYiwgZGF0YS5pbWFnZUhlYWQuYnl0ZUxlbmd0aCldLFxuICAgICAgICAgICAgeyB0eXBlOiAnaW1hZ2UvanBlZycgfVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHsgbWF4TWV0YURhdGFTaXplOiAyNTYsIGRpc2FibGVNZXRhRGF0YVBhcnNlcnM6IHRydWUgfVxuICAgIClcbiAgfVxuXG4gIC8vIERldGVybWluZXMgaWYgbWV0YSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgYXV0b21hdGljYWxseTpcbiAgbG9hZEltYWdlLmhhc01ldGFPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubWV0YVxuICB9XG5cbiAgdmFyIG9yaWdpbmFsVHJhbnNmb3JtID0gbG9hZEltYWdlLnRyYW5zZm9ybVxuICBsb2FkSW1hZ2UudHJhbnNmb3JtID0gZnVuY3Rpb24gKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBpZiAobG9hZEltYWdlLmhhc01ldGFPcHRpb24ob3B0aW9ucykpIHtcbiAgICAgIGxvYWRJbWFnZS5wYXJzZU1ldGFEYXRhKFxuICAgICAgICBmaWxlLFxuICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIG9yaWdpbmFsVHJhbnNmb3JtLmNhbGwobG9hZEltYWdlLCBpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCBkYXRhKVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkYXRhXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsVHJhbnNmb3JtLmFwcGx5KGxvYWRJbWFnZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-meta.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-orientation.js":
/*!**********************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-orientation.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalHasCanvasOption = loadImage.hasCanvasOption\n  var originalHasMetaOption = loadImage.hasMetaOption\n  var originalTransformCoordinates = loadImage.transformCoordinates\n  var originalGetTransformedOptions = loadImage.getTransformedOptions\n\n  ;(function () {\n    // black 2x1 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90° CCW)\n    var testImageURL =\n      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\n      'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\n      'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q=='\n    var img = document.createElement('img')\n    img.onload = function () {\n      // Check if browser supports automatic image orientation:\n      loadImage.orientation = img.width === 1 && img.height === 2\n    }\n    img.src = testImageURL\n  })()\n\n  // Determines if the target image should be a canvas element:\n  loadImage.hasCanvasOption = function (options) {\n    return (\n      (!!options.orientation === true && !loadImage.orientation) ||\n      (options.orientation > 1 && options.orientation < 9) ||\n      originalHasCanvasOption.call(loadImage, options)\n    )\n  }\n\n  // Determines if meta data should be loaded automatically:\n  loadImage.hasMetaOption = function (options) {\n    return (\n      (options && options.orientation === true && !loadImage.orientation) ||\n      originalHasMetaOption.call(loadImage, options)\n    )\n  }\n\n  // Transform image orientation based on\n  // the given EXIF orientation option:\n  loadImage.transformCoordinates = function (canvas, options) {\n    originalTransformCoordinates.call(loadImage, canvas, options)\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var styleWidth = canvas.style.width\n    var styleHeight = canvas.style.height\n    var orientation = options.orientation\n    if (!(orientation > 1 && orientation < 9)) {\n      return\n    }\n    if (orientation > 4) {\n      canvas.width = height\n      canvas.height = width\n      canvas.style.width = styleHeight\n      canvas.style.height = styleWidth\n    }\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        ctx.translate(width, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180° rotate left\n        ctx.translate(width, height)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // vertical flip\n        ctx.translate(0, height)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // vertical flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.scale(1, -1)\n        break\n      case 6:\n        // 90° rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -height)\n        break\n      case 7:\n        // horizontal flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(width, -height)\n        ctx.scale(-1, 1)\n        break\n      case 8:\n        // 90° rotate left\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-width, 0)\n        break\n    }\n  }\n\n  // Transforms coordinate and dimension options\n  // based on the given orientation option:\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var orientation = options.orientation\n    var newOptions\n    var i\n    if (orientation === true) {\n      if (loadImage.orientation) {\n        // Browser supports automatic image orientation\n        return options\n      }\n      orientation = data && data.exif && data.exif.get('Orientation')\n    }\n    if (!(orientation > 1 && orientation < 9)) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.orientation = orientation\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        newOptions.left = options.right\n        newOptions.right = options.left\n        break\n      case 3:\n        // 180° rotate left\n        newOptions.left = options.right\n        newOptions.top = options.bottom\n        newOptions.right = options.left\n        newOptions.bottom = options.top\n        break\n      case 4:\n        // vertical flip\n        newOptions.top = options.bottom\n        newOptions.bottom = options.top\n        break\n      case 5:\n        // vertical flip + 90 rotate right\n        newOptions.left = options.top\n        newOptions.top = options.left\n        newOptions.right = options.bottom\n        newOptions.bottom = options.right\n        break\n      case 6:\n        // 90° rotate right\n        newOptions.left = options.top\n        newOptions.top = options.right\n        newOptions.right = options.bottom\n        newOptions.bottom = options.left\n        break\n      case 7:\n        // horizontal flip + 90 rotate right\n        newOptions.left = options.bottom\n        newOptions.top = options.right\n        newOptions.right = options.top\n        newOptions.bottom = options.left\n        break\n      case 8:\n        // 90° rotate left\n        newOptions.left = options.bottom\n        newOptions.top = options.left\n        newOptions.right = options.top\n        newOptions.bottom = options.right\n        break\n    }\n    if (newOptions.orientation > 4) {\n      newOptions.maxWidth = options.maxHeight\n      newOptions.maxHeight = options.maxWidth\n      newOptions.minWidth = options.minHeight\n      newOptions.minHeight = options.minWidth\n      newOptions.sourceWidth = options.sourceHeight\n      newOptions.sourceHeight = options.sourceWidth\n    }\n    return newOptions\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanM/NzliYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUseUdBQW9CLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNoRixHQUFHLE1BQU0sRUFTTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1vcmllbnRhdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgT3JpZW50YXRpb25cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2Utc2NhbGUnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSxcbiAgICAgIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1zY2FsZScpLFxuICAgICAgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBvcmlnaW5hbEhhc0NhbnZhc09wdGlvbiA9IGxvYWRJbWFnZS5oYXNDYW52YXNPcHRpb25cbiAgdmFyIG9yaWdpbmFsSGFzTWV0YU9wdGlvbiA9IGxvYWRJbWFnZS5oYXNNZXRhT3B0aW9uXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybUNvb3JkaW5hdGVzID0gbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzXG4gIHZhciBvcmlnaW5hbEdldFRyYW5zZm9ybWVkT3B0aW9ucyA9IGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnNcblxuICA7KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBibGFjayAyeDEgSlBFRywgd2l0aCB0aGUgZm9sbG93aW5nIG1ldGEgaW5mb3JtYXRpb24gc2V0OlxuICAgIC8vIC0gRVhJRiBPcmllbnRhdGlvbjogNiAoUm90YXRlZCA5MMKwIENDVylcbiAgICB2YXIgdGVzdEltYWdlVVJMID1cbiAgICAgICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80UUFpUlhocFpnQUFUVTBBS2dBQUFBZ0FBUUVTQUFNQUFBQUJBQVlBQUFBJyArXG4gICAgICAnQUFBRC8yd0NFQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQScgK1xuICAgICAgJ1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUUnICtcbiAgICAgICdCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFmL0FBQkVJQUFFQUFnTUJFUUFDRVFFREVRSC94JyArXG4gICAgICAnQUJLQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFMRUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQUFBQUFBQUFBQUFBQUFBQScgK1xuICAgICAgJ0FBQUFBRVFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBLzlvQURBTUJBQUlSQXhFQVB3QS84SC8vMlE9PSdcbiAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyBhdXRvbWF0aWMgaW1hZ2Ugb3JpZW50YXRpb246XG4gICAgICBsb2FkSW1hZ2Uub3JpZW50YXRpb24gPSBpbWcud2lkdGggPT09IDEgJiYgaW1nLmhlaWdodCA9PT0gMlxuICAgIH1cbiAgICBpbWcuc3JjID0gdGVzdEltYWdlVVJMXG4gIH0pKClcblxuICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB0YXJnZXQgaW1hZ2Ugc2hvdWxkIGJlIGEgY2FudmFzIGVsZW1lbnQ6XG4gIGxvYWRJbWFnZS5oYXNDYW52YXNPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiAoXG4gICAgICAoISFvcHRpb25zLm9yaWVudGF0aW9uID09PSB0cnVlICYmICFsb2FkSW1hZ2Uub3JpZW50YXRpb24pIHx8XG4gICAgICAob3B0aW9ucy5vcmllbnRhdGlvbiA+IDEgJiYgb3B0aW9ucy5vcmllbnRhdGlvbiA8IDkpIHx8XG4gICAgICBvcmlnaW5hbEhhc0NhbnZhc09wdGlvbi5jYWxsKGxvYWRJbWFnZSwgb3B0aW9ucylcbiAgICApXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIG1ldGEgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGF1dG9tYXRpY2FsbHk6XG4gIGxvYWRJbWFnZS5oYXNNZXRhT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gdHJ1ZSAmJiAhbG9hZEltYWdlLm9yaWVudGF0aW9uKSB8fFxuICAgICAgb3JpZ2luYWxIYXNNZXRhT3B0aW9uLmNhbGwobG9hZEltYWdlLCBvcHRpb25zKVxuICAgIClcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBpbWFnZSBvcmllbnRhdGlvbiBiYXNlZCBvblxuICAvLyB0aGUgZ2l2ZW4gRVhJRiBvcmllbnRhdGlvbiBvcHRpb246XG4gIGxvYWRJbWFnZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBvcmlnaW5hbFRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwobG9hZEltYWdlLCBjYW52YXMsIG9wdGlvbnMpXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGNhbnZhcy5zdHlsZS53aWR0aFxuICAgIHZhciBzdHlsZUhlaWdodCA9IGNhbnZhcy5zdHlsZS5oZWlnaHRcbiAgICB2YXIgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgaWYgKCEob3JpZW50YXRpb24gPiAxICYmIG9yaWVudGF0aW9uIDwgOSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPiA0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSBoZWlnaHRcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aWR0aFxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gc3R5bGVIZWlnaHRcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBzdHlsZVdpZHRoXG4gICAgfVxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwXG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApXG4gICAgICAgIGN0eC5zY2FsZSgtMSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gMTgwwrAgcm90YXRlIGxlZnRcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQpXG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgLy8gdmVydGljYWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgLy8gOTDCsCByb3RhdGUgcmlnaHRcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC1oZWlnaHQpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIGhvcml6b250YWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIC1oZWlnaHQpXG4gICAgICAgIGN0eC5zY2FsZSgtMSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgLy8gOTDCsCByb3RhdGUgbGVmdFxuICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKC13aWR0aCwgMClcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBUcmFuc2Zvcm1zIGNvb3JkaW5hdGUgYW5kIGRpbWVuc2lvbiBvcHRpb25zXG4gIC8vIGJhc2VkIG9uIHRoZSBnaXZlbiBvcmllbnRhdGlvbiBvcHRpb246XG4gIGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnMgPSBmdW5jdGlvbiAoaW1nLCBvcHRzLCBkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcmlnaW5hbEdldFRyYW5zZm9ybWVkT3B0aW9ucy5jYWxsKGxvYWRJbWFnZSwgaW1nLCBvcHRzKVxuICAgIHZhciBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICB2YXIgbmV3T3B0aW9uc1xuICAgIHZhciBpXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBpZiAobG9hZEltYWdlLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIC8vIEJyb3dzZXIgc3VwcG9ydHMgYXV0b21hdGljIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICAgIHJldHVybiBvcHRpb25zXG4gICAgICB9XG4gICAgICBvcmllbnRhdGlvbiA9IGRhdGEgJiYgZGF0YS5leGlmICYmIGRhdGEuZXhpZi5nZXQoJ09yaWVudGF0aW9uJylcbiAgICB9XG4gICAgaWYgKCEob3JpZW50YXRpb24gPiAxICYmIG9yaWVudGF0aW9uIDwgOSkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuICAgIG5ld09wdGlvbnMgPSB7fVxuICAgIGZvciAoaSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgIG5ld09wdGlvbnNbaV0gPSBvcHRpb25zW2ldXG4gICAgICB9XG4gICAgfVxuICAgIG5ld09wdGlvbnMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwXG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMubGVmdFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyAxODDCsCByb3RhdGUgbGVmdFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMubGVmdFxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IG9wdGlvbnMudG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXBcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IG9wdGlvbnMudG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy50b3BcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA2OlxuICAgICAgICAvLyA5MMKwIHJvdGF0ZSByaWdodFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLnRvcFxuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIGhvcml6b250YWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IG9wdGlvbnMucmlnaHRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMudG9wXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8vIDkwwrAgcm90YXRlIGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IG9wdGlvbnMudG9wXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobmV3T3B0aW9ucy5vcmllbnRhdGlvbiA+IDQpIHtcbiAgICAgIG5ld09wdGlvbnMubWF4V2lkdGggPSBvcHRpb25zLm1heEhlaWdodFxuICAgICAgbmV3T3B0aW9ucy5tYXhIZWlnaHQgPSBvcHRpb25zLm1heFdpZHRoXG4gICAgICBuZXdPcHRpb25zLm1pbldpZHRoID0gb3B0aW9ucy5taW5IZWlnaHRcbiAgICAgIG5ld09wdGlvbnMubWluSGVpZ2h0ID0gb3B0aW9ucy5taW5XaWR0aFxuICAgICAgbmV3T3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0XG4gICAgICBuZXdPcHRpb25zLnNvdXJjZUhlaWdodCA9IG9wdGlvbnMuc291cmNlV2lkdGhcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnNcbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-orientation.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-scale.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-scale.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      loadImage.scale(img, options, data),\n      options,\n      callback,\n      file,\n      data\n    )\n  }\n\n  // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options passed as arguments:\n  loadImage.transformCoordinates = function () {}\n\n  // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options passed as arguments:\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio\n      newOptions.maxHeight = height\n    } else {\n      newOptions.maxWidth = width\n      newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n  }\n\n  // Canvas render method, allows to implement a different rendering algorithm:\n  loadImage.renderImageToCanvas = function (\n    canvas,\n    img,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destX,\n    destY,\n    destWidth,\n    destHeight,\n    options\n  ) {\n    var ctx = canvas.getContext('2d')\n    if (options.imageSmoothingEnabled === false) {\n      ctx.imageSmoothingEnabled = false\n    } else if (options.imageSmoothingQuality) {\n      ctx.imageSmoothingQuality = options.imageSmoothingQuality\n    }\n    ctx.drawImage(\n      img,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destX,\n      destY,\n      destWidth,\n      destHeight\n    )\n    return canvas\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.hasCanvasOption = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n  }\n\n  // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options.\n  // Returns a canvas object if the browser supports canvas\n  // and the hasCanvasOption method returns true or a canvas\n  // object is passed as image, else the scaled image:\n  loadImage.scale = function (img, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    var canvas = document.createElement('canvas')\n    var useCanvas =\n      img.getContext ||\n      (loadImage.hasCanvasOption(options) && canvas.getContext)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    /**\n     * Scales up image dimensions\n     */\n    function scaleUp() {\n      var scale = Math.max(\n        (minWidth || destWidth) / destWidth,\n        (minHeight || destHeight) / destHeight\n      )\n      if (scale > 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    /**\n     * Scales down image dimensions\n     */\n    function scaleDown() {\n      var scale = Math.min(\n        (maxWidth || destWidth) / destWidth,\n        (maxHeight || destHeight) / destHeight\n      )\n      if (scale < 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    if (useCanvas) {\n      // eslint-disable-next-line no-param-reassign\n      options = loadImage.getTransformedOptions(img, options, data)\n      sourceX = options.left || 0\n      sourceY = options.top || 0\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0)\n      }\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0)\n      }\n      destWidth = sourceWidth\n      destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth\n      destHeight = maxHeight\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n      if (tmp < 0) {\n        sourceHeight = (maxHeight * sourceWidth) / maxWidth\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2\n        }\n      } else if (tmp > 0) {\n        sourceWidth = (maxWidth * sourceHeight) / maxHeight\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth\n        minHeight = maxHeight = maxHeight || minHeight\n      }\n      if (options.cover) {\n        scaleDown()\n        scaleUp()\n      } else {\n        scaleUp()\n        scaleDown()\n      }\n    }\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio\n      if (pixelRatio > 1) {\n        canvas.style.width = destWidth + 'px'\n        canvas.style.height = destHeight + 'px'\n        destWidth *= pixelRatio\n        destHeight *= pixelRatio\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio)\n      }\n      downsamplingRatio = options.downsamplingRatio\n      if (\n        downsamplingRatio > 0 &&\n        downsamplingRatio < 1 &&\n        destWidth < sourceWidth &&\n        destHeight < sourceHeight\n      ) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas.width = sourceWidth * downsamplingRatio\n          canvas.height = sourceHeight * downsamplingRatio\n          loadImage.renderImageToCanvas(\n            canvas,\n            img,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            0,\n            0,\n            canvas.width,\n            canvas.height,\n            options\n          )\n          sourceX = 0\n          sourceY = 0\n          sourceWidth = canvas.width\n          sourceHeight = canvas.height\n          // eslint-disable-next-line no-param-reassign\n          img = document.createElement('canvas')\n          img.width = sourceWidth\n          img.height = sourceHeight\n          loadImage.renderImageToCanvas(\n            img,\n            canvas,\n            0,\n            0,\n            sourceWidth,\n            sourceHeight,\n            0,\n            0,\n            sourceWidth,\n            sourceHeight,\n            options\n          )\n        }\n      }\n      canvas.width = destWidth\n      canvas.height = destHeight\n      loadImage.transformCoordinates(canvas, options)\n      return loadImage.renderImageToCanvas(\n        canvas,\n        img,\n        sourceX,\n        sourceY,\n        sourceWidth,\n        sourceHeight,\n        0,\n        0,\n        destWidth,\n        destHeight,\n        options\n      )\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanM/YTcyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNyQyxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIFNjYWxpbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybSA9IGxvYWRJbWFnZS50cmFuc2Zvcm1cblxuICBsb2FkSW1hZ2UudHJhbnNmb3JtID0gZnVuY3Rpb24gKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBvcmlnaW5hbFRyYW5zZm9ybS5jYWxsKFxuICAgICAgbG9hZEltYWdlLFxuICAgICAgbG9hZEltYWdlLnNjYWxlKGltZywgb3B0aW9ucywgZGF0YSksXG4gICAgICBvcHRpb25zLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBmaWxlLFxuICAgICAgZGF0YVxuICAgIClcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBpbWFnZSBjb29yZGluYXRlcywgYWxsb3dzIHRvIG92ZXJyaWRlIGUuZy5cbiAgLy8gdGhlIGNhbnZhcyBvcmllbnRhdGlvbiBiYXNlZCBvbiB0aGUgb3JpZW50YXRpb24gb3B0aW9uLFxuICAvLyBnZXRzIGNhbnZhcywgb3B0aW9ucyBwYXNzZWQgYXMgYXJndW1lbnRzOlxuICBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7fVxuXG4gIC8vIFJldHVybnMgdHJhbnNmb3JtZWQgb3B0aW9ucywgYWxsb3dzIHRvIG92ZXJyaWRlIGUuZy5cbiAgLy8gbWF4V2lkdGgsIG1heEhlaWdodCBhbmQgY3JvcCBvcHRpb25zIGJhc2VkIG9uIHRoZSBhc3BlY3RSYXRpby5cbiAgLy8gZ2V0cyBpbWcsIG9wdGlvbnMgcGFzc2VkIGFzIGFyZ3VtZW50czpcbiAgbG9hZEltYWdlLmdldFRyYW5zZm9ybWVkT3B0aW9ucyA9IGZ1bmN0aW9uIChpbWcsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvXG4gICAgdmFyIG5ld09wdGlvbnNcbiAgICB2YXIgaVxuICAgIHZhciB3aWR0aFxuICAgIHZhciBoZWlnaHRcbiAgICBpZiAoIWFzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1xuICAgIH1cbiAgICBuZXdPcHRpb25zID0ge31cbiAgICBmb3IgKGkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBpKSkge1xuICAgICAgICBuZXdPcHRpb25zW2ldID0gb3B0aW9uc1tpXVxuICAgICAgfVxuICAgIH1cbiAgICBuZXdPcHRpb25zLmNyb3AgPSB0cnVlXG4gICAgd2lkdGggPSBpbWcubmF0dXJhbFdpZHRoIHx8IGltZy53aWR0aFxuICAgIGhlaWdodCA9IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHRcbiAgICBpZiAod2lkdGggLyBoZWlnaHQgPiBhc3BlY3RSYXRpbykge1xuICAgICAgbmV3T3B0aW9ucy5tYXhXaWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvXG4gICAgICBuZXdPcHRpb25zLm1heEhlaWdodCA9IGhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdPcHRpb25zLm1heFdpZHRoID0gd2lkdGhcbiAgICAgIG5ld09wdGlvbnMubWF4SGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpb1xuICAgIH1cbiAgICByZXR1cm4gbmV3T3B0aW9uc1xuICB9XG5cbiAgLy8gQ2FudmFzIHJlbmRlciBtZXRob2QsIGFsbG93cyB0byBpbXBsZW1lbnQgYSBkaWZmZXJlbnQgcmVuZGVyaW5nIGFsZ29yaXRobTpcbiAgbG9hZEltYWdlLnJlbmRlckltYWdlVG9DYW52YXMgPSBmdW5jdGlvbiAoXG4gICAgY2FudmFzLFxuICAgIGltZyxcbiAgICBzb3VyY2VYLFxuICAgIHNvdXJjZVksXG4gICAgc291cmNlV2lkdGgsXG4gICAgc291cmNlSGVpZ2h0LFxuICAgIGRlc3RYLFxuICAgIGRlc3RZLFxuICAgIGRlc3RXaWR0aCxcbiAgICBkZXN0SGVpZ2h0LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgaWYgKG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmltYWdlU21vb3RoaW5nUXVhbGl0eSkge1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdRdWFsaXR5XG4gICAgfVxuICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICBpbWcsXG4gICAgICBzb3VyY2VYLFxuICAgICAgc291cmNlWSxcbiAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgZGVzdFgsXG4gICAgICBkZXN0WSxcbiAgICAgIGRlc3RXaWR0aCxcbiAgICAgIGRlc3RIZWlnaHRcbiAgICApXG4gICAgcmV0dXJuIGNhbnZhc1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdGFyZ2V0IGltYWdlIHNob3VsZCBiZSBhIGNhbnZhcyBlbGVtZW50OlxuICBsb2FkSW1hZ2UuaGFzQ2FudmFzT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5jYW52YXMgfHwgb3B0aW9ucy5jcm9wIHx8ICEhb3B0aW9ucy5hc3BlY3RSYXRpb1xuICB9XG5cbiAgLy8gU2NhbGVzIGFuZC9vciBjcm9wcyB0aGUgZ2l2ZW4gaW1hZ2UgKGltZyBvciBjYW52YXMgSFRNTCBlbGVtZW50KVxuICAvLyB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgLy8gUmV0dXJucyBhIGNhbnZhcyBvYmplY3QgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgY2FudmFzXG4gIC8vIGFuZCB0aGUgaGFzQ2FudmFzT3B0aW9uIG1ldGhvZCByZXR1cm5zIHRydWUgb3IgYSBjYW52YXNcbiAgLy8gb2JqZWN0IGlzIHBhc3NlZCBhcyBpbWFnZSwgZWxzZSB0aGUgc2NhbGVkIGltYWdlOlxuICBsb2FkSW1hZ2Uuc2NhbGUgPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICB2YXIgdXNlQ2FudmFzID1cbiAgICAgIGltZy5nZXRDb250ZXh0IHx8XG4gICAgICAobG9hZEltYWdlLmhhc0NhbnZhc09wdGlvbihvcHRpb25zKSAmJiBjYW52YXMuZ2V0Q29udGV4dClcbiAgICB2YXIgd2lkdGggPSBpbWcubmF0dXJhbFdpZHRoIHx8IGltZy53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodCB8fCBpbWcuaGVpZ2h0XG4gICAgdmFyIGRlc3RXaWR0aCA9IHdpZHRoXG4gICAgdmFyIGRlc3RIZWlnaHQgPSBoZWlnaHRcbiAgICB2YXIgbWF4V2lkdGhcbiAgICB2YXIgbWF4SGVpZ2h0XG4gICAgdmFyIG1pbldpZHRoXG4gICAgdmFyIG1pbkhlaWdodFxuICAgIHZhciBzb3VyY2VXaWR0aFxuICAgIHZhciBzb3VyY2VIZWlnaHRcbiAgICB2YXIgc291cmNlWFxuICAgIHZhciBzb3VyY2VZXG4gICAgdmFyIHBpeGVsUmF0aW9cbiAgICB2YXIgZG93bnNhbXBsaW5nUmF0aW9cbiAgICB2YXIgdG1wXG4gICAgLyoqXG4gICAgICogU2NhbGVzIHVwIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsZVVwKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoXG4gICAgICAgIChtaW5XaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWluSGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlID4gMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgZG93biBpbWFnZSBkaW1lbnNpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGVEb3duKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4oXG4gICAgICAgIChtYXhXaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWF4SGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlIDwgMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlQ2FudmFzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG9wdGlvbnMgPSBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zKGltZywgb3B0aW9ucywgZGF0YSlcbiAgICAgIHNvdXJjZVggPSBvcHRpb25zLmxlZnQgfHwgMFxuICAgICAgc291cmNlWSA9IG9wdGlvbnMudG9wIHx8IDBcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9IHdpZHRoIC0gc291cmNlV2lkdGggLSBvcHRpb25zLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gd2lkdGggLSBzb3VyY2VYIC0gKG9wdGlvbnMucmlnaHQgfHwgMClcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZUhlaWdodCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5ib3R0b20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWSA9IGhlaWdodCAtIHNvdXJjZUhlaWdodCAtIG9wdGlvbnMuYm90dG9tXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUhlaWdodCA9IGhlaWdodCAtIHNvdXJjZVkgLSAob3B0aW9ucy5ib3R0b20gfHwgMClcbiAgICAgIH1cbiAgICAgIGRlc3RXaWR0aCA9IHNvdXJjZVdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gc291cmNlSGVpZ2h0XG4gICAgfVxuICAgIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aFxuICAgIG1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0XG4gICAgbWluV2lkdGggPSBvcHRpb25zLm1pbldpZHRoXG4gICAgbWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHRcbiAgICBpZiAodXNlQ2FudmFzICYmIG1heFdpZHRoICYmIG1heEhlaWdodCAmJiBvcHRpb25zLmNyb3ApIHtcbiAgICAgIGRlc3RXaWR0aCA9IG1heFdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gbWF4SGVpZ2h0XG4gICAgICB0bXAgPSBzb3VyY2VXaWR0aCAvIHNvdXJjZUhlaWdodCAtIG1heFdpZHRoIC8gbWF4SGVpZ2h0XG4gICAgICBpZiAodG1wIDwgMCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSAobWF4SGVpZ2h0ICogc291cmNlV2lkdGgpIC8gbWF4V2lkdGhcbiAgICAgICAgaWYgKG9wdGlvbnMudG9wID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5ib3R0b20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNvdXJjZVkgPSAoaGVpZ2h0IC0gc291cmNlSGVpZ2h0KSAvIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0bXAgPiAwKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gKG1heFdpZHRoICogc291cmNlSGVpZ2h0KSAvIG1heEhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9ICh3aWR0aCAtIHNvdXJjZVdpZHRoKSAvIDJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluIHx8IG9wdGlvbnMuY292ZXIpIHtcbiAgICAgICAgbWluV2lkdGggPSBtYXhXaWR0aCA9IG1heFdpZHRoIHx8IG1pbldpZHRoXG4gICAgICAgIG1pbkhlaWdodCA9IG1heEhlaWdodCA9IG1heEhlaWdodCB8fCBtaW5IZWlnaHRcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICAgIHNjYWxlVXAoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVVcCgpXG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VDYW52YXMpIHtcbiAgICAgIHBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW9cbiAgICAgIGlmIChwaXhlbFJhdGlvID4gMSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBkZXN0V2lkdGggKyAncHgnXG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBkZXN0SGVpZ2h0ICsgJ3B4J1xuICAgICAgICBkZXN0V2lkdGggKj0gcGl4ZWxSYXRpb1xuICAgICAgICBkZXN0SGVpZ2h0ICo9IHBpeGVsUmF0aW9cbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbylcbiAgICAgIH1cbiAgICAgIGRvd25zYW1wbGluZ1JhdGlvID0gb3B0aW9ucy5kb3duc2FtcGxpbmdSYXRpb1xuICAgICAgaWYgKFxuICAgICAgICBkb3duc2FtcGxpbmdSYXRpbyA+IDAgJiZcbiAgICAgICAgZG93bnNhbXBsaW5nUmF0aW8gPCAxICYmXG4gICAgICAgIGRlc3RXaWR0aCA8IHNvdXJjZVdpZHRoICYmXG4gICAgICAgIGRlc3RIZWlnaHQgPCBzb3VyY2VIZWlnaHRcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAoc291cmNlV2lkdGggKiBkb3duc2FtcGxpbmdSYXRpbyA+IGRlc3RXaWR0aCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNvdXJjZVdpZHRoICogZG93bnNhbXBsaW5nUmF0aW9cbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gc291cmNlSGVpZ2h0ICogZG93bnNhbXBsaW5nUmF0aW9cbiAgICAgICAgICBsb2FkSW1hZ2UucmVuZGVySW1hZ2VUb0NhbnZhcyhcbiAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICAgIHNvdXJjZVggPSAwXG4gICAgICAgICAgc291cmNlWSA9IDBcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGNhbnZhcy53aWR0aFxuICAgICAgICAgIHNvdXJjZUhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgIGltZy53aWR0aCA9IHNvdXJjZVdpZHRoXG4gICAgICAgICAgaW1nLmhlaWdodCA9IHNvdXJjZUhlaWdodFxuICAgICAgICAgIGxvYWRJbWFnZS5yZW5kZXJJbWFnZVRvQ2FudmFzKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzb3VyY2VXaWR0aCxcbiAgICAgICAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYW52YXMud2lkdGggPSBkZXN0V2lkdGhcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBkZXN0SGVpZ2h0XG4gICAgICBsb2FkSW1hZ2UudHJhbnNmb3JtQ29vcmRpbmF0ZXMoY2FudmFzLCBvcHRpb25zKVxuICAgICAgcmV0dXJuIGxvYWRJbWFnZS5yZW5kZXJJbWFnZVRvQ2FudmFzKFxuICAgICAgICBjYW52YXMsXG4gICAgICAgIGltZyxcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZGVzdFdpZHRoLFxuICAgICAgICBkZXN0SGVpZ2h0LFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgfVxuICAgIGltZy53aWR0aCA9IGRlc3RXaWR0aFxuICAgIGltZy5oZWlnaHQgPSBkZXN0SGVpZ2h0XG4gICAgcmV0dXJuIGltZ1xuICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-scale.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image.js":
/*!**********************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, webkitURL, module */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Loads an image for a given File object.\n   * Invokes the callback with an img or optional canvas element\n   * (if supported by the browser) as parameter:.\n   *\n   * @param {File|Blob|string} file File or Blob object or image URL\n   * @param {Function} [callback] Image load event callback\n   * @param {object} [options] Options object\n   * @returns {HTMLImageElement|HTMLCanvasElement|FileReader} image object\n   */\n  function loadImage(file, callback, options) {\n    var img = document.createElement('img')\n    var url\n    img.onerror = function (event) {\n      return loadImage.onerror(img, event, file, callback, options)\n    }\n    img.onload = function (event) {\n      return loadImage.onload(img, event, file, callback, options)\n    }\n    if (typeof file === 'string') {\n      loadImage.fetchBlob(\n        file,\n        function (blob) {\n          if (blob && loadImage.isInstanceOf('Blob', blob)) {\n            // eslint-disable-next-line no-param-reassign\n            file = blob\n            url = loadImage.createObjectURL(file)\n          } else {\n            url = file\n            if (options && options.crossOrigin) {\n              img.crossOrigin = options.crossOrigin\n            }\n          }\n          img.src = url\n        },\n        options\n      )\n      return img\n    } else if (\n      loadImage.isInstanceOf('Blob', file) ||\n      // Files are also Blob instances, but some browsers\n      // (Firefox 3.6) support the File API but not Blobs:\n      loadImage.isInstanceOf('File', file)\n    ) {\n      url = img._objectURL = loadImage.createObjectURL(file)\n      if (url) {\n        img.src = url\n        return img\n      }\n      return loadImage.readFile(file, function (e) {\n        var target = e.target\n        if (target && target.result) {\n          img.src = target.result\n        } else if (callback) {\n          callback(e)\n        }\n      })\n    }\n  }\n  // The check for URL.revokeObjectURL fixes an issue with Opera 12,\n  // which provides URL.createObjectURL but doesn't properly implement it:\n  var urlAPI =\n    ($.createObjectURL && $) ||\n    ($.URL && URL.revokeObjectURL && URL) ||\n    ($.webkitURL && webkitURL)\n\n  /**\n   * Helper function to revoke an object URL\n   *\n   * @param {HTMLImageElement} img Image element\n   * @param {object} [options] Options object\n   */\n  function revokeHelper(img, options) {\n    if (img._objectURL && !(options && options.noRevoke)) {\n      loadImage.revokeObjectURL(img._objectURL)\n      delete img._objectURL\n    }\n  }\n\n  // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n  loadImage.fetchBlob = function (url, callback) {\n    callback()\n  }\n\n  loadImage.isInstanceOf = function (type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data)\n  }\n\n  loadImage.onerror = function (img, event, file, callback, options) {\n    revokeHelper(img, options)\n    if (callback) {\n      callback.call(img, event)\n    }\n  }\n\n  loadImage.onload = function (img, event, file, callback, options) {\n    revokeHelper(img, options)\n    if (callback) {\n      loadImage.transform(img, options, callback, file, {\n        originalWidth: img.naturalWidth || img.width,\n        originalHeight: img.naturalHeight || img.height\n      })\n    }\n  }\n\n  loadImage.createObjectURL = function (file) {\n    return urlAPI ? urlAPI.createObjectURL(file) : false\n  }\n\n  loadImage.revokeObjectURL = function (url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n  }\n\n  // Loads a given File object via FileReader interface,\n  // invokes the callback with the event object (load or error).\n  // The result can be read via event.target.result:\n  loadImage.readFile = function (file, callback, method) {\n    if ($.FileReader) {\n      var fileReader = new FileReader()\n      fileReader.onload = fileReader.onerror = callback\n      // eslint-disable-next-line no-param-reassign\n      method = method || 'readAsDataURL'\n      if (fileReader[method]) {\n        fileReader[method](file)\n        return fileReader\n      }\n    }\n    return false\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return loadImage\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})((typeof window !== 'undefined' && window) || this)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanM/MDliNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTixHQUFHLE1BQU0sRUFJTjtBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgd2Via2l0VVJMLCBtb2R1bGUgKi9cblxuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCdcblxuICAvKipcbiAgICogTG9hZHMgYW4gaW1hZ2UgZm9yIGEgZ2l2ZW4gRmlsZSBvYmplY3QuXG4gICAqIEludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggYW4gaW1nIG9yIG9wdGlvbmFsIGNhbnZhcyBlbGVtZW50XG4gICAqIChpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIpIGFzIHBhcmFtZXRlcjouXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZXxCbG9ifHN0cmluZ30gZmlsZSBGaWxlIG9yIEJsb2Igb2JqZWN0IG9yIGltYWdlIFVSTFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIEltYWdlIGxvYWQgZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxGaWxlUmVhZGVyfSBpbWFnZSBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRJbWFnZShmaWxlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgIHZhciB1cmxcbiAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGxvYWRJbWFnZS5vbmVycm9yKGltZywgZXZlbnQsIGZpbGUsIGNhbGxiYWNrLCBvcHRpb25zKVxuICAgIH1cbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlLm9ubG9hZChpbWcsIGV2ZW50LCBmaWxlLCBjYWxsYmFjaywgb3B0aW9ucylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgbG9hZEltYWdlLmZldGNoQmxvYihcbiAgICAgICAgZmlsZSxcbiAgICAgICAgZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICBpZiAoYmxvYiAmJiBsb2FkSW1hZ2UuaXNJbnN0YW5jZU9mKCdCbG9iJywgYmxvYikpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmlsZSA9IGJsb2JcbiAgICAgICAgICAgIHVybCA9IGxvYWRJbWFnZS5jcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gZmlsZVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGltZy5zcmMgPSB1cmxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICAgcmV0dXJuIGltZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBsb2FkSW1hZ2UuaXNJbnN0YW5jZU9mKCdCbG9iJywgZmlsZSkgfHxcbiAgICAgIC8vIEZpbGVzIGFyZSBhbHNvIEJsb2IgaW5zdGFuY2VzLCBidXQgc29tZSBicm93c2Vyc1xuICAgICAgLy8gKEZpcmVmb3ggMy42KSBzdXBwb3J0IHRoZSBGaWxlIEFQSSBidXQgbm90IEJsb2JzOlxuICAgICAgbG9hZEltYWdlLmlzSW5zdGFuY2VPZignRmlsZScsIGZpbGUpXG4gICAgKSB7XG4gICAgICB1cmwgPSBpbWcuX29iamVjdFVSTCA9IGxvYWRJbWFnZS5jcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgaW1nLnNyYyA9IHVybFxuICAgICAgICByZXR1cm4gaW1nXG4gICAgICB9XG4gICAgICByZXR1cm4gbG9hZEltYWdlLnJlYWRGaWxlKGZpbGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldFxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5yZXN1bHQpIHtcbiAgICAgICAgICBpbWcuc3JjID0gdGFyZ2V0LnJlc3VsdFxuICAgICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgLy8gVGhlIGNoZWNrIGZvciBVUkwucmV2b2tlT2JqZWN0VVJMIGZpeGVzIGFuIGlzc3VlIHdpdGggT3BlcmEgMTIsXG4gIC8vIHdoaWNoIHByb3ZpZGVzIFVSTC5jcmVhdGVPYmplY3RVUkwgYnV0IGRvZXNuJ3QgcHJvcGVybHkgaW1wbGVtZW50IGl0OlxuICB2YXIgdXJsQVBJID1cbiAgICAoJC5jcmVhdGVPYmplY3RVUkwgJiYgJCkgfHxcbiAgICAoJC5VUkwgJiYgVVJMLnJldm9rZU9iamVjdFVSTCAmJiBVUkwpIHx8XG4gICAgKCQud2Via2l0VVJMICYmIHdlYmtpdFVSTClcblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldm9rZSBhbiBvYmplY3QgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nIEltYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gcmV2b2tlSGVscGVyKGltZywgb3B0aW9ucykge1xuICAgIGlmIChpbWcuX29iamVjdFVSTCAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Jldm9rZSkpIHtcbiAgICAgIGxvYWRJbWFnZS5yZXZva2VPYmplY3RVUkwoaW1nLl9vYmplY3RVUkwpXG4gICAgICBkZWxldGUgaW1nLl9vYmplY3RVUkxcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2FsbGJhY2sgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYmxvYiwgaXQgaXMgdXNlZCBhcyBpbWFnZVxuICAvLyBzb3VyY2UgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdXJsIGFuZCBvdmVycmlkZXMgdGhlIGZpbGUgYXJndW1lbnQgdXNlZCBpblxuICAvLyB0aGUgb25sb2FkIGFuZCBvbmVycm9yIGV2ZW50IGNhbGxiYWNrczpcbiAgbG9hZEltYWdlLmZldGNoQmxvYiA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgbG9hZEltYWdlLmlzSW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcbiAgICAvLyBDcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGNoZWNrXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJ1xuICB9XG5cbiAgbG9hZEltYWdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCBkYXRhKSB7XG4gICAgY2FsbGJhY2soaW1nLCBkYXRhKVxuICB9XG5cbiAgbG9hZEltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoaW1nLCBldmVudCwgZmlsZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICByZXZva2VIZWxwZXIoaW1nLCBvcHRpb25zKVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChpbWcsIGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGxvYWRJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoaW1nLCBldmVudCwgZmlsZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICByZXZva2VIZWxwZXIoaW1nLCBvcHRpb25zKVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgbG9hZEltYWdlLnRyYW5zZm9ybShpbWcsIG9wdGlvbnMsIGNhbGxiYWNrLCBmaWxlLCB7XG4gICAgICAgIG9yaWdpbmFsV2lkdGg6IGltZy5uYXR1cmFsV2lkdGggfHwgaW1nLndpZHRoLFxuICAgICAgICBvcmlnaW5hbEhlaWdodDogaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLmhlaWdodFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2UuY3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gdXJsQVBJID8gdXJsQVBJLmNyZWF0ZU9iamVjdFVSTChmaWxlKSA6IGZhbHNlXG4gIH1cblxuICBsb2FkSW1hZ2UucmV2b2tlT2JqZWN0VVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB1cmxBUEkgPyB1cmxBUEkucmV2b2tlT2JqZWN0VVJMKHVybCkgOiBmYWxzZVxuICB9XG5cbiAgLy8gTG9hZHMgYSBnaXZlbiBGaWxlIG9iamVjdCB2aWEgRmlsZVJlYWRlciBpbnRlcmZhY2UsXG4gIC8vIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGV2ZW50IG9iamVjdCAobG9hZCBvciBlcnJvcikuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIHJlYWQgdmlhIGV2ZW50LnRhcmdldC5yZXN1bHQ6XG4gIGxvYWRJbWFnZS5yZWFkRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBjYWxsYmFjaywgbWV0aG9kKSB7XG4gICAgaWYgKCQuRmlsZVJlYWRlcikge1xuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZpbGVSZWFkZXIub25lcnJvciA9IGNhbGxiYWNrXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1ldGhvZCA9IG1ldGhvZCB8fCAncmVhZEFzRGF0YVVSTCdcbiAgICAgIGlmIChmaWxlUmVhZGVyW21ldGhvZF0pIHtcbiAgICAgICAgZmlsZVJlYWRlclttZXRob2RdKGZpbGUpXG4gICAgICAgIHJldHVybiBmaWxlUmVhZGVyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbG9hZEltYWdlXG4gIH0gZWxzZSB7XG4gICAgJC5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2VcbiAgfVxufSkoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHwgdGhpcylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image.js\n");

/***/ }),

/***/ "./node_modules/croppr/dist/croppr.js":
/*!********************************************!*\
  !*** ./node_modules/croppr/dist/croppr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Croppr.js\n * https://github.com/jamesssooi/Croppr.js\n * \n * A JavaScript image cropper that's lightweight, awesome, and has\n * zero dependencies.\n * \n * (C) 2017 James Ooi. Released under the MIT License.\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n(function () {\n  if (typeof window.CustomEvent === \"function\") return false;\n  function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n})();\n(function (window) {\n  try {\n    new CustomEvent('test');\n    return false;\n  } catch (e) {}\n  function MouseEvent(eventType, params) {\n    params = params || { bubbles: false, cancelable: false };\n    var mouseEvent = document.createEvent('MouseEvent');\n    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    return mouseEvent;\n  }\n  MouseEvent.prototype = Event.prototype;\n  window.MouseEvent = MouseEvent;\n})(window);\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar Handle =\n/**\n * Creates a new Handle instance.\n * @constructor\n * @param {Array} position The x and y ratio position of the handle\n *      within the crop region. Accepts a value between 0 to 1 in the order\n *      of [X, Y].\n * @param {Array} constraints Define the side of the crop region that\n *      is to be affected by this handle. Accepts a value of 0 or 1 in the\n *      order of [TOP, RIGHT, BOTTOM, LEFT].\n * @param {String} cursor The CSS cursor of this handle.\n * @param {Element} eventBus The element to dispatch events to.\n */\nfunction Handle(position, constraints, cursor, eventBus) {\n  classCallCheck(this, Handle);\n  var self = this;\n  this.position = position;\n  this.constraints = constraints;\n  this.cursor = cursor;\n  this.eventBus = eventBus;\n  this.el = document.createElement('div');\n  this.el.className = 'croppr-handle';\n  this.el.style.cursor = cursor;\n  this.el.addEventListener('mousedown', onMouseDown);\n  function onMouseDown(e) {\n    e.stopPropagation();\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseUp(e) {\n    e.stopPropagation();\n    document.removeEventListener('mouseup', onMouseUp);\n    document.removeEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseMove(e) {\n    e.stopPropagation();\n    self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n      detail: { mouseX: e.clientX, mouseY: e.clientY }\n    }));\n  }\n};\n\nvar Box = function () {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  function Box(x1, y1, x2, y2) {\n    classCallCheck(this, Box);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  /**\n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  createClass(Box, [{\n    key: 'set',\n    value: function set$$1() {\n      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      this.x1 = x1 == null ? this.x1 : x1;\n      this.y1 = y1 == null ? this.y1 : y1;\n      this.x2 = x2 == null ? this.x2 : x2;\n      this.y2 = y2 == null ? this.y2 : y2;\n      return this;\n    }\n    /**\n     * Calculates the width of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'width',\n    value: function width() {\n      return Math.abs(this.x2 - this.x1);\n    }\n    /**\n     * Calculates the height of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'height',\n    value: function height() {\n      return Math.abs(this.y2 - this.y1);\n    }\n    /**\n     * Resizes the box to a new size.\n     * @param {Number} newWidth\n     * @param {Number} newHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'resize',\n    value: function resize(newWidth, newHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var fromX = this.x1 + this.width() * origin[0];\n      var fromY = this.y1 + this.height() * origin[1];\n      this.x1 = fromX - newWidth * origin[0];\n      this.y1 = fromY - newHeight * origin[1];\n      this.x2 = this.x1 + newWidth;\n      this.y2 = this.y1 + newHeight;\n      return this;\n    }\n    /**\n     * Scale the box by a factor.\n     * @param {Number} factor\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'scale',\n    value: function scale(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var newWidth = this.width() * factor;\n      var newHeight = this.height() * factor;\n      this.resize(newWidth, newHeight, origin);\n      return this;\n    }\n  }, {\n    key: 'move',\n    value: function move() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var width = this.width();\n      var height = this.height();\n      x = x === null ? this.x1 : x;\n      y = y === null ? this.y1 : y;\n      this.x1 = x;\n      this.y1 = y;\n      this.x2 = x + width;\n      this.y2 = y + height;\n      return this;\n    }\n    /**\n     * Get relative x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getRelativePoint',\n    value: function getRelativePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.width() * point[0];\n      var y = this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Get absolute x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getAbsolutePoint',\n    value: function getAbsolutePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.x1 + this.width() * point[0];\n      var y = this.y1 + this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Constrain the box to a fixed ratio.\n     * @param {Number} ratio\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {String} [grow] The axis to grow to maintain the ratio.\n     *     Defaults to 'height'.\n     */\n  }, {\n    key: 'constrainToRatio',\n    value: function constrainToRatio(ratio) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var grow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'height';\n      if (ratio === null) {\n        return;\n      }\n      var width = this.width();\n      var height = this.height();\n      switch (grow) {\n        case 'height':\n          this.resize(this.width(), this.width() * ratio, origin);\n          break;\n        case 'width':\n          this.resize(this.height() * 1 / ratio, this.height(), origin);\n          break;\n        default:\n          this.resize(this.width(), this.width() * ratio, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box within a boundary.\n     * @param {Number} boundaryWidth\n     * @param {Number} boundaryHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'constrainToBoundary',\n    value: function constrainToBoundary(boundaryWidth, boundaryHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var _getAbsolutePoint = this.getAbsolutePoint(origin),\n          _getAbsolutePoint2 = slicedToArray(_getAbsolutePoint, 2),\n          originX = _getAbsolutePoint2[0],\n          originY = _getAbsolutePoint2[1];\n      var maxIfLeft = originX;\n      var maxIfTop = originY;\n      var maxIfRight = boundaryWidth - originX;\n      var maxIfBottom = boundaryHeight - originY;\n      var directionX = -2 * origin[0] + 1;\n      var directionY = -2 * origin[1] + 1;\n      var maxWidth = null,\n          maxHeight = null;\n      switch (directionX) {\n        case -1:\n          maxWidth = maxIfLeft;break;\n        case 0:\n          maxWidth = Math.min(maxIfLeft, maxIfRight) * 2;break;\n        case +1:\n          maxWidth = maxIfRight;break;\n      }\n      switch (directionY) {\n        case -1:\n          maxHeight = maxIfTop;break;\n        case 0:\n          maxHeight = Math.min(maxIfTop, maxIfBottom) * 2;break;\n        case +1:\n          maxHeight = maxIfBottom;break;\n      }\n      if (this.width() > maxWidth) {\n        var factor = maxWidth / this.width();\n        this.scale(factor, origin);\n      }\n      if (this.height() > maxHeight) {\n        var _factor = maxHeight / this.height();\n        this.scale(_factor, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box to a maximum/minimum size.\n     * @param {Number} [maxWidth]\n     * @param {Number} [maxHeight]\n     * @param {Number} [minWidth]\n     * @param {Number} [minHeight]\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {Number} [ratio] Ratio to maintain.\n     */\n  }, {\n    key: 'constrainToSize',\n    value: function constrainToSize() {\n      var maxWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var maxHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var minWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var minHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n      var ratio = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      if (ratio) {\n        if (ratio > 1) {\n          maxWidth = maxHeight * 1 / ratio;\n          minHeight = minHeight * ratio;\n        } else if (ratio < 1) {\n          maxHeight = maxWidth * ratio;\n          minWidth = minHeight * 1 / ratio;\n        }\n      }\n      if (maxWidth && this.width() > maxWidth) {\n        var newWidth = maxWidth,\n            newHeight = ratio === null ? this.height() : maxHeight;\n        this.resize(newWidth, newHeight, origin);\n      }\n      if (maxHeight && this.height() > maxHeight) {\n        var _newWidth = ratio === null ? this.width() : maxWidth,\n            _newHeight = maxHeight;\n        this.resize(_newWidth, _newHeight, origin);\n      }\n      if (minWidth && this.width() < minWidth) {\n        var _newWidth2 = minWidth,\n            _newHeight2 = ratio === null ? this.height() : minHeight;\n        this.resize(_newWidth2, _newHeight2, origin);\n      }\n      if (minHeight && this.height() < minHeight) {\n        var _newWidth3 = ratio === null ? this.width() : minWidth,\n            _newHeight3 = minHeight;\n        this.resize(_newWidth3, _newHeight3, origin);\n      }\n      return this;\n    }\n  }]);\n  return Box;\n}();\n\n/**\n * Binds an element's touch events to be simulated as mouse events.\n * @param {Element} element\n */\nfunction enableTouch(element) {\n  element.addEventListener('touchstart', simulateMouseEvent);\n  element.addEventListener('touchend', simulateMouseEvent);\n  element.addEventListener('touchmove', simulateMouseEvent);\n}\n/**\n * Translates a touch event to a mouse event.\n * @param {Event} e\n */\nfunction simulateMouseEvent(e) {\n  e.preventDefault();\n  var touch = e.changedTouches[0];\n  var eventMap = {\n    'touchstart': 'mousedown',\n    'touchmove': 'mousemove',\n    'touchend': 'mouseup'\n  };\n  touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {\n    bubbles: true,\n    cancelable: true,\n    view: window,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    screenX: touch.screenX,\n    screenY: touch.screenY\n  }));\n}\n\n/**\n * Define a list of handles to create.\n *\n * @property {Array} position - The x and y ratio position of the handle within\n *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].\n * @property {Array} constraints - Define the side of the crop region that is to\n *      be affected by this handle. Accepts a value of 0 or 1 in the order of\n *      [TOP, RIGHT, BOTTOM, LEFT].\n * @property {String} cursor - The CSS cursor of this handle.\n */\nvar HANDLES = [{ position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: 'nw-resize' }, { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: 'n-resize' }, { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: 'ne-resize' }, { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: 'e-resize' }, { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: 'se-resize' }, { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: 's-resize' }, { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: 'sw-resize' }, { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: 'w-resize' }];\nvar CropprCore = function () {\n  function CropprCore(element, options) {\n    var _this = this;\n    var deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, CropprCore);\n    this.options = CropprCore.parseOptions(options || {});\n    if (!element.nodeName) {\n      element = document.querySelector(element);\n      if (element == null) {\n        throw 'Unable to find element.';\n      }\n    }\n    if (!element.getAttribute('src')) {\n      throw 'Image src not provided.';\n    }\n    this._initialized = false;\n    this._restore = {\n      parent: element.parentNode,\n      element: element\n    };\n    if (!deferred) {\n      if (element.width === 0 || element.height === 0) {\n        element.onload = function () {\n          _this.initialize(element);\n        };\n      } else {\n        this.initialize(element);\n      }\n    }\n  }\n  createClass(CropprCore, [{\n    key: 'initialize',\n    value: function initialize(element) {\n      this.createDOM(element);\n      this.options.convertToPixels(this.cropperEl);\n      this.attachHandlerEvents();\n      this.attachRegionEvents();\n      this.attachOverlayEvents();\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      this._initialized = true;\n      if (this.options.onInitialize !== null) {\n        this.options.onInitialize(this);\n      }\n    }\n  }, {\n    key: 'createDOM',\n    value: function createDOM(targetEl) {\n      this.containerEl = document.createElement('div');\n      this.containerEl.className = 'croppr-container';\n      this.eventBus = this.containerEl;\n      enableTouch(this.containerEl);\n      this.cropperEl = document.createElement('div');\n      this.cropperEl.className = 'croppr';\n      this.imageEl = document.createElement('img');\n      this.imageEl.setAttribute('src', targetEl.getAttribute('src'));\n      this.imageEl.setAttribute('alt', targetEl.getAttribute('alt'));\n      this.imageEl.className = 'croppr-image';\n      this.imageClippedEl = this.imageEl.cloneNode();\n      this.imageClippedEl.className = 'croppr-imageClipped';\n      this.regionEl = document.createElement('div');\n      this.regionEl.className = 'croppr-region';\n      this.overlayEl = document.createElement('div');\n      this.overlayEl.className = 'croppr-overlay';\n      var handleContainerEl = document.createElement('div');\n      handleContainerEl.className = 'croppr-handleContainer';\n      this.handles = [];\n      for (var i = 0; i < HANDLES.length; i++) {\n        var handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);\n        this.handles.push(handle);\n        handleContainerEl.appendChild(handle.el);\n      }\n      this.cropperEl.appendChild(this.imageEl);\n      this.cropperEl.appendChild(this.imageClippedEl);\n      this.cropperEl.appendChild(this.regionEl);\n      this.cropperEl.appendChild(this.overlayEl);\n      this.cropperEl.appendChild(handleContainerEl);\n      this.containerEl.appendChild(this.cropperEl);\n      targetEl.parentElement.replaceChild(this.containerEl, targetEl);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      var _this2 = this;\n      this.imageEl.onload = function () {\n        _this2.box = _this2.initializeBox(_this2.options);\n        _this2.redraw();\n      };\n      this.imageEl.src = src;\n      this.imageClippedEl.src = src;\n      return this;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._restore.parent.replaceChild(this._restore.element, this.containerEl);\n    }\n    /**\n     * Create a new box region with a set of options.\n     * @param {Object} opts The options.\n     * @returns {Box}\n     */\n  }, {\n    key: 'initializeBox',\n    value: function initializeBox(opts) {\n      var width = opts.startSize.width;\n      var height = opts.startSize.height;\n      var box = new Box(0, 0, width, height);\n      box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);\n      var min = opts.minSize;\n      var max = opts.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);\n      var x = this.cropperEl.offsetWidth / 2 - box.width() / 2;\n      var y = this.cropperEl.offsetHeight / 2 - box.height() / 2;\n      box.move(x, y);\n      return box;\n    }\n  }, {\n    key: 'redraw',\n    value: function redraw() {\n      var _this3 = this;\n      var width = Math.round(this.box.width()),\n          height = Math.round(this.box.height()),\n          x1 = Math.round(this.box.x1),\n          y1 = Math.round(this.box.y1),\n          x2 = Math.round(this.box.x2),\n          y2 = Math.round(this.box.y2);\n      window.requestAnimationFrame(function () {\n        _this3.regionEl.style.transform = 'translate(' + x1 + 'px, ' + y1 + 'px)';\n        _this3.regionEl.style.width = width + 'px';\n        _this3.regionEl.style.height = height + 'px';\n        _this3.imageClippedEl.style.clip = 'rect(' + y1 + 'px, ' + x2 + 'px, ' + y2 + 'px, ' + x1 + 'px)';\n        var center = _this3.box.getAbsolutePoint([.5, .5]);\n        var xSign = center[0] - _this3.cropperEl.offsetWidth / 2 >> 31;\n        var ySign = center[1] - _this3.cropperEl.offsetHeight / 2 >> 31;\n        var quadrant = (xSign ^ ySign) + ySign + ySign + 4;\n        var foregroundHandleIndex = -2 * quadrant + 8;\n        for (var i = 0; i < _this3.handles.length; i++) {\n          var handle = _this3.handles[i];\n          var handleWidth = handle.el.offsetWidth;\n          var handleHeight = handle.el.offsetHeight;\n          var left = x1 + width * handle.position[0] - handleWidth / 2;\n          var top = y1 + height * handle.position[1] - handleHeight / 2;\n          handle.el.style.transform = 'translate(' + Math.round(left) + 'px, ' + Math.round(top) + 'px)';\n          handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;\n        }\n      });\n    }\n  }, {\n    key: 'attachHandlerEvents',\n    value: function attachHandlerEvents() {\n      var eventBus = this.eventBus;\n      eventBus.addEventListener('handlestart', this.onHandleMoveStart.bind(this));\n      eventBus.addEventListener('handlemove', this.onHandleMoveMoving.bind(this));\n      eventBus.addEventListener('handleend', this.onHandleMoveEnd.bind(this));\n    }\n  }, {\n    key: 'attachRegionEvents',\n    value: function attachRegionEvents() {\n      var eventBus = this.eventBus;\n      var self = this;\n      this.regionEl.addEventListener('mousedown', onMouseDown);\n      eventBus.addEventListener('regionstart', this.onRegionMoveStart.bind(this));\n      eventBus.addEventListener('regionmove', this.onRegionMoveMoving.bind(this));\n      eventBus.addEventListener('regionend', this.onRegionMoveEnd.bind(this));\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionstart', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        eventBus.dispatchEvent(new CustomEvent('regionmove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'attachOverlayEvents',\n    value: function attachOverlayEvents() {\n      var SOUTHEAST_HANDLE_IDX = 4;\n      var self = this;\n      var tmpBox = null;\n      this.overlayEl.addEventListener('mousedown', onMouseDown);\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        var container = self.cropperEl.getBoundingClientRect();\n        var mouseX = e.clientX - container.left;\n        var mouseY = e.clientY - container.top;\n        tmpBox = self.box;\n        self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);\n        self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n          detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        if (self.box.width() === 1 && self.box.height() === 1) {\n          self.box = tmpBox;\n          return;\n        }\n        self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'onHandleMoveStart',\n    value: function onHandleMoveStart(e) {\n      var handle = e.detail.handle;\n      var originPoint = [1 - handle.position[0], 1 - handle.position[1]];\n      var _box$getAbsolutePoint = this.box.getAbsolutePoint(originPoint),\n          _box$getAbsolutePoint2 = slicedToArray(_box$getAbsolutePoint, 2),\n          originX = _box$getAbsolutePoint2[0],\n          originY = _box$getAbsolutePoint2[1];\n      this.activeHandle = { handle: handle, originPoint: originPoint, originX: originX, originY: originY };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveMoving',\n    value: function onHandleMoveMoving(e) {\n      var _e$detail = e.detail,\n          mouseX = _e$detail.mouseX,\n          mouseY = _e$detail.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      if (mouseX < 0) {\n        mouseX = 0;\n      } else if (mouseX > container.width) {\n        mouseX = container.width;\n      }\n      if (mouseY < 0) {\n        mouseY = 0;\n      } else if (mouseY > container.height) {\n        mouseY = container.height;\n      }\n      var origin = this.activeHandle.originPoint.slice();\n      var originX = this.activeHandle.originX;\n      var originY = this.activeHandle.originY;\n      var handle = this.activeHandle.handle;\n      var TOP_MOVABLE = handle.constraints[0] === 1;\n      var RIGHT_MOVABLE = handle.constraints[1] === 1;\n      var BOTTOM_MOVABLE = handle.constraints[2] === 1;\n      var LEFT_MOVABLE = handle.constraints[3] === 1;\n      var MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);\n      var x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;\n      var x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;\n      var y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;\n      var y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;\n      x1 = LEFT_MOVABLE ? mouseX : x1;\n      x2 = RIGHT_MOVABLE ? mouseX : x2;\n      y1 = TOP_MOVABLE ? mouseY : y1;\n      y2 = BOTTOM_MOVABLE ? mouseY : y2;\n      var isFlippedX = false,\n          isFlippedY = false;\n      if (LEFT_MOVABLE || RIGHT_MOVABLE) {\n        isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;\n      }\n      if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n        isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;\n      }\n      if (isFlippedX) {\n        var tmp = x1;x1 = x2;x2 = tmp;\n        origin[0] = 1 - origin[0];\n      }\n      if (isFlippedY) {\n        var _tmp = y1;y1 = y2;y2 = _tmp;\n        origin[1] = 1 - origin[1];\n      }\n      var box = new Box(x1, y1, x2, y2);\n      if (this.options.aspectRatio) {\n        var ratio = this.options.aspectRatio;\n        var isVerticalMovement = false;\n        if (MULTI_AXIS) {\n          isVerticalMovement = mouseY > box.y1 + ratio * box.width() || mouseY < box.y2 - ratio * box.width();\n        } else if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n          isVerticalMovement = true;\n        }\n        var ratioMode = isVerticalMovement ? 'width' : 'height';\n        box.constrainToRatio(ratio, origin, ratioMode);\n      }\n      var min = this.options.minSize;\n      var max = this.options.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, origin);\n      this.box = box;\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveEnd',\n    value: function onHandleMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveStart',\n    value: function onRegionMoveStart(e) {\n      var _e$detail2 = e.detail,\n          mouseX = _e$detail2.mouseX,\n          mouseY = _e$detail2.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.currentMove = {\n        offsetX: mouseX - this.box.x1,\n        offsetY: mouseY - this.box.y1\n      };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveMoving',\n    value: function onRegionMoveMoving(e) {\n      var _e$detail3 = e.detail,\n          mouseX = _e$detail3.mouseX,\n          mouseY = _e$detail3.mouseY;\n      var _currentMove = this.currentMove,\n          offsetX = _currentMove.offsetX,\n          offsetY = _currentMove.offsetY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.box.move(mouseX - offsetX, mouseY - offsetY);\n      if (this.box.x1 < 0) {\n        this.box.move(0, null);\n      }\n      if (this.box.x2 > container.width) {\n        this.box.move(container.width - this.box.width(), null);\n      }\n      if (this.box.y1 < 0) {\n        this.box.move(null, 0);\n      }\n      if (this.box.y2 > container.height) {\n        this.box.move(null, container.height - this.box.height());\n      }\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveEnd',\n    value: function onRegionMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (mode === null) {\n        mode = this.options.returnMode;\n      }\n      if (mode == 'real') {\n        var actualWidth = this.imageEl.naturalWidth;\n        var actualHeight = this.imageEl.naturalHeight;\n        var _imageEl$getBoundingC = this.imageEl.getBoundingClientRect(),\n            elementWidth = _imageEl$getBoundingC.width,\n            elementHeight = _imageEl$getBoundingC.height;\n        var factorX = actualWidth / elementWidth;\n        var factorY = actualHeight / elementHeight;\n        return {\n          x: Math.round(this.box.x1 * factorX),\n          y: Math.round(this.box.y1 * factorY),\n          width: Math.round(this.box.width() * factorX),\n          height: Math.round(this.box.height() * factorY)\n        };\n      } else if (mode == 'ratio') {\n        var _imageEl$getBoundingC2 = this.imageEl.getBoundingClientRect(),\n            _elementWidth = _imageEl$getBoundingC2.width,\n            _elementHeight = _imageEl$getBoundingC2.height;\n        return {\n          x: round(this.box.x1 / _elementWidth, 3),\n          y: round(this.box.y1 / _elementHeight, 3),\n          width: round(this.box.width() / _elementWidth, 3),\n          height: round(this.box.height() / _elementHeight, 3)\n        };\n      } else if (mode == 'raw') {\n        return {\n          x: Math.round(this.box.x1),\n          y: Math.round(this.box.y1),\n          width: Math.round(this.box.width()),\n          height: Math.round(this.box.height())\n        };\n      }\n    }\n  }], [{\n    key: 'parseOptions',\n    value: function parseOptions(opts) {\n      var defaults$$1 = {\n        aspectRatio: null,\n        maxSize: { width: null, height: null },\n        minSize: { width: null, height: null },\n        startSize: { width: 100, height: 100, unit: '%' },\n        returnMode: 'real',\n        onInitialize: null,\n        onCropStart: null,\n        onCropMove: null,\n        onCropEnd: null\n      };\n      var aspectRatio = null;\n      if (opts.aspectRatio !== undefined) {\n        if (typeof opts.aspectRatio === 'number') {\n          aspectRatio = opts.aspectRatio;\n        } else if (opts.aspectRatio instanceof Array) {\n          aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];\n        }\n      }\n      var maxSize = null;\n      if (opts.maxSize !== undefined && opts.maxSize !== null) {\n        maxSize = {\n          width: opts.maxSize[0] || null,\n          height: opts.maxSize[1] || null,\n          unit: opts.maxSize[2] || 'px'\n        };\n      }\n      var minSize = null;\n      if (opts.minSize !== undefined && opts.minSize !== null) {\n        minSize = {\n          width: opts.minSize[0] || null,\n          height: opts.minSize[1] || null,\n          unit: opts.minSize[2] || 'px'\n        };\n      }\n      var startSize = null;\n      if (opts.startSize !== undefined && opts.startSize !== null) {\n        startSize = {\n          width: opts.startSize[0] || null,\n          height: opts.startSize[1] || null,\n          unit: opts.startSize[2] || '%'\n        };\n      }\n      var onInitialize = null;\n      if (typeof opts.onInitialize === 'function') {\n        onInitialize = opts.onInitialize;\n      }\n      var onCropStart = null;\n      if (typeof opts.onCropStart === 'function') {\n        onCropStart = opts.onCropStart;\n      }\n      var onCropEnd = null;\n      if (typeof opts.onCropEnd === 'function') {\n        onCropEnd = opts.onCropEnd;\n      }\n      var onCropMove = null;\n      if (typeof opts.onUpdate === 'function') {\n        console.warn('Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.');\n        onCropMove = opts.onUpdate;\n      }\n      if (typeof opts.onCropMove === 'function') {\n        onCropMove = opts.onCropMove;\n      }\n      var returnMode = null;\n      if (opts.returnMode !== undefined) {\n        var s = opts.returnMode.toLowerCase();\n        if (['real', 'ratio', 'raw'].indexOf(s) === -1) {\n          throw \"Invalid return mode.\";\n        }\n        returnMode = s;\n      }\n      var convertToPixels = function convertToPixels(container) {\n        var width = container.offsetWidth;\n        var height = container.offsetHeight;\n        var sizeKeys = ['maxSize', 'minSize', 'startSize'];\n        for (var i = 0; i < sizeKeys.length; i++) {\n          var key = sizeKeys[i];\n          if (this[key] !== null) {\n            if (this[key].unit == '%') {\n              if (this[key].width !== null) {\n                this[key].width = this[key].width / 100 * width;\n              }\n              if (this[key].height !== null) {\n                this[key].height = this[key].height / 100 * height;\n              }\n            }\n            delete this[key].unit;\n          }\n        }\n      };\n      var defaultValue = function defaultValue(v, d) {\n        return v !== null ? v : d;\n      };\n      return {\n        aspectRatio: defaultValue(aspectRatio, defaults$$1.aspectRatio),\n        maxSize: defaultValue(maxSize, defaults$$1.maxSize),\n        minSize: defaultValue(minSize, defaults$$1.minSize),\n        startSize: defaultValue(startSize, defaults$$1.startSize),\n        returnMode: defaultValue(returnMode, defaults$$1.returnMode),\n        onInitialize: defaultValue(onInitialize, defaults$$1.onInitialize),\n        onCropStart: defaultValue(onCropStart, defaults$$1.onCropStart),\n        onCropMove: defaultValue(onCropMove, defaults$$1.onCropMove),\n        onCropEnd: defaultValue(onCropEnd, defaults$$1.onCropEnd),\n        convertToPixels: convertToPixels\n      };\n    }\n  }]);\n  return CropprCore;\n}();\nfunction round(value, decimals) {\n  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);\n}\n\nvar Croppr$1 = function (_CropprCore) {\n  inherits(Croppr, _CropprCore);\n  /**\n   * @constructor\n   * Calls the CropprCore's constructor.\n   */\n  function Croppr(element, options) {\n    var _deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Croppr);\n    return possibleConstructorReturn(this, (Croppr.__proto__ || Object.getPrototypeOf(Croppr)).call(this, element, options, _deferred));\n  }\n  /**\n   * Gets the value of the crop region.\n   * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or\n   *      'raw'.\n   */\n  createClass(Croppr, [{\n    key: 'getValue',\n    value: function getValue(mode) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'getValue', this).call(this, mode);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'setImage', this).call(this, src);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'destroy', this).call(this);\n    }\n    /**\n     * Moves the crop region to a specified coordinate.\n     * @param {Number} x\n     * @param {Number} y\n     */\n  }, {\n    key: 'moveTo',\n    value: function moveTo(x, y) {\n      this.box.move(x, y);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Resizes the crop region to a specified width and height.\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'resizeTo',\n    value: function resizeTo(width, height) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [.5, .5];\n      this.box.resize(width, height, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Scale the crop region by a factor.\n     * @param {Number} factor\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'scaleBy',\n    value: function scaleBy(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [.5, .5];\n      this.box.scale(factor, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }]);\n  return Croppr;\n}(CropprCore);\n\nreturn Croppr$1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL2Rpc3QvY3JvcHByLmpzPzc1ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQzJCO0FBQzVCLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQXFEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRTtBQUN6bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QyxrQkFBa0IsNEJBQTRCO0FBQzlDLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3Bwci9kaXN0L2Nyb3Bwci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JvcHByLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFtZXNzc29vaS9Dcm9wcHIuanNcbiAqIFxuICogQSBKYXZhU2NyaXB0IGltYWdlIGNyb3BwZXIgdGhhdCdzIGxpZ2h0d2VpZ2h0LCBhd2Vzb21lLCBhbmQgaGFzXG4gKiB6ZXJvIGRlcGVuZGVuY2llcy5cbiAqIFxuICogKEMpIDIwMTcgSmFtZXMgT29pLiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkNyb3BwciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RUaW1lID0gMDtcbiAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG59KSgpO1xuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VzdG9tRXZlbnQoJ3Rlc3QnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGZ1bmN0aW9uIE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfTtcbiAgICB2YXIgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgbW91c2VFdmVudC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cbiAgTW91c2VFdmVudC5wcm90b3R5cGUgPSBFdmVudC5wcm90b3R5cGU7XG4gIHdpbmRvdy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcbn0pKHdpbmRvdyk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgSGFuZGxlID1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBIYW5kbGUgaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9uIFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGVcbiAqICAgICAgd2l0aGluIHRoZSBjcm9wIHJlZ2lvbi4gQWNjZXB0cyBhIHZhbHVlIGJldHdlZW4gMCB0byAxIGluIHRoZSBvcmRlclxuICogICAgICBvZiBbWCwgWV0uXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50cyBEZWZpbmUgdGhlIHNpZGUgb2YgdGhlIGNyb3AgcmVnaW9uIHRoYXRcbiAqICAgICAgaXMgdG8gYmUgYWZmZWN0ZWQgYnkgdGhpcyBoYW5kbGUuIEFjY2VwdHMgYSB2YWx1ZSBvZiAwIG9yIDEgaW4gdGhlXG4gKiAgICAgIG9yZGVyIG9mIFtUT1AsIFJJR0hULCBCT1RUT00sIExFRlRdLlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnNvciBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZXZlbnRCdXMgVGhlIGVsZW1lbnQgdG8gZGlzcGF0Y2ggZXZlbnRzIHRvLlxuICovXG5mdW5jdGlvbiBIYW5kbGUocG9zaXRpb24sIGNvbnN0cmFpbnRzLCBjdXJzb3IsIGV2ZW50QnVzKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSAnY3JvcHByLWhhbmRsZSc7XG4gIHRoaXMuZWwuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZXN0YXJ0Jywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZW1vdmUnLCB7XG4gICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICB9KSk7XG4gIH1cbn07XG5cbnZhciBCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEJveCBpbnN0YW5jZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgZnVuY3Rpb24gQm94KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5ldyBkaW1lbnNpb25zIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCQkMSgpIHtcbiAgICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRoaXMueDEgPSB4MSA9PSBudWxsID8gdGhpcy54MSA6IHgxO1xuICAgICAgdGhpcy55MSA9IHkxID09IG51bGwgPyB0aGlzLnkxIDogeTE7XG4gICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gdGhpcy55MiA6IHkyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBib3guXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3dpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgYm94IHRvIGEgbmV3IHNpemUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbMCwgMF07XG4gICAgICB2YXIgZnJvbVggPSB0aGlzLngxICsgdGhpcy53aWR0aCgpICogb3JpZ2luWzBdO1xuICAgICAgdmFyIGZyb21ZID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBvcmlnaW5bMV07XG4gICAgICB0aGlzLngxID0gZnJvbVggLSBuZXdXaWR0aCAqIG9yaWdpblswXTtcbiAgICAgIHRoaXMueTEgPSBmcm9tWSAtIG5ld0hlaWdodCAqIG9yaWdpblsxXTtcbiAgICAgIHRoaXMueDIgPSB0aGlzLngxICsgbmV3V2lkdGg7XG4gICAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgYm94IGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlKGZhY3Rvcikge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzAsIDBdO1xuICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy53aWR0aCgpICogZmFjdG9yO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0KCkgKiBmYWN0b3I7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICB4ID0geCA9PT0gbnVsbCA/IHRoaXMueDEgOiB4O1xuICAgICAgeSA9IHkgPT09IG51bGwgPyB0aGlzLnkxIDogeTtcbiAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgdGhpcy55MSA9IHk7XG4gICAgICB0aGlzLngyID0geCArIHdpZHRoO1xuICAgICAgdGhpcy55MiA9IHkgKyBoZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlbGF0aXZlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgYSBnaXZlbiBwb2ludCB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIFt4LCB5XS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldFJlbGF0aXZlUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvaW50KCkge1xuICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbMCwgMF07XG4gICAgICB2YXIgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50IFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgW3gsIHldLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0QWJzb2x1dGVQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFic29sdXRlUG9pbnQoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFswLCAwXTtcbiAgICAgIHZhciB4ID0gdGhpcy54MSArIHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLnkxICsgdGhpcy5oZWlnaHQoKSAqIHBvaW50WzFdO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBmaXhlZCByYXRpby5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3ddIFRoZSBheGlzIHRvIGdyb3cgdG8gbWFpbnRhaW4gdGhlIHJhdGlvLlxuICAgICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbnN0cmFpblRvUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1JhdGlvKHJhdGlvKSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMCwgMF07XG4gICAgICB2YXIgZ3JvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2hlaWdodCc7XG4gICAgICBpZiAocmF0aW8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICBzd2l0Y2ggKGdyb3cpIHtcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbiB0aGUgYm94IHdpdGhpbiBhIGJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJvdW5kYXJ5SGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub0JvdW5kYXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3RyYWluVG9Cb3VuZGFyeShib3VuZGFyeVdpZHRoLCBib3VuZGFyeUhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWzAsIDBdO1xuICAgICAgdmFyIF9nZXRBYnNvbHV0ZVBvaW50ID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbiksXG4gICAgICAgICAgX2dldEFic29sdXRlUG9pbnQyID0gc2xpY2VkVG9BcnJheShfZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9nZXRBYnNvbHV0ZVBvaW50MlswXSxcbiAgICAgICAgICBvcmlnaW5ZID0gX2dldEFic29sdXRlUG9pbnQyWzFdO1xuICAgICAgdmFyIG1heElmTGVmdCA9IG9yaWdpblg7XG4gICAgICB2YXIgbWF4SWZUb3AgPSBvcmlnaW5ZO1xuICAgICAgdmFyIG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWDtcbiAgICAgIHZhciBtYXhJZkJvdHRvbSA9IGJvdW5kYXJ5SGVpZ2h0IC0gb3JpZ2luWTtcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gLTIgKiBvcmlnaW5bMF0gKyAxO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSAtMiAqIG9yaWdpblsxXSArIDE7XG4gICAgICB2YXIgbWF4V2lkdGggPSBudWxsLFxuICAgICAgICAgIG1heEhlaWdodCA9IG51bGw7XG4gICAgICBzd2l0Y2ggKGRpcmVjdGlvblgpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBtYXhXaWR0aCA9IG1heElmTGVmdDticmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4SWZMZWZ0LCBtYXhJZlJpZ2h0KSAqIDI7YnJlYWs7XG4gICAgICAgIGNhc2UgKzE6XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhJZlJpZ2h0O2JyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkaXJlY3Rpb25ZKSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4SWZUb3A7YnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjticmVhaztcbiAgICAgICAgY2FzZSArMTpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTticmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICAgIHRoaXMuc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgdmFyIF9mYWN0b3IgPSBtYXhIZWlnaHQgLyB0aGlzLmhlaWdodCgpO1xuICAgICAgICB0aGlzLnNjYWxlKF9mYWN0b3IsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBtYXhpbXVtL21pbmltdW0gc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4SGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluV2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub1NpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1NpemUoKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIG1pbldpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbkhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFswLCAwXTtcbiAgICAgIHZhciByYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAgIGlmIChyYXRpbykge1xuICAgICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhIZWlnaHQgKiAxIC8gcmF0aW87XG4gICAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAocmF0aW8gPCAxKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4V2lkdGggKiByYXRpbztcbiAgICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFdpZHRoICYmIHRoaXMud2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IG1heFdpZHRoLFxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmF0aW8gPT09IG51bGwgPyB0aGlzLmhlaWdodCgpIDogbWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1heFdpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoLCBfbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGgyID0gbWluV2lkdGgsXG4gICAgICAgICAgICBfbmV3SGVpZ2h0MiA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1pbkhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoMiwgX25ld0hlaWdodDIsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICBpZiAobWluSGVpZ2h0ICYmIHRoaXMuaGVpZ2h0KCkgPCBtaW5IZWlnaHQpIHtcbiAgICAgICAgdmFyIF9uZXdXaWR0aDMgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodDMgPSBtaW5IZWlnaHQ7XG4gICAgICAgIHRoaXMucmVzaXplKF9uZXdXaWR0aDMsIF9uZXdIZWlnaHQzLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbi8qKlxuICogQmluZHMgYW4gZWxlbWVudCdzIHRvdWNoIGV2ZW50cyB0byBiZSBzaW11bGF0ZWQgYXMgbW91c2UgZXZlbnRzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZVRvdWNoKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHNpbXVsYXRlTW91c2VFdmVudCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbn1cbi8qKlxuICogVHJhbnNsYXRlcyBhIHRvdWNoIGV2ZW50IHRvIGEgbW91c2UgZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBlXG4gKi9cbmZ1bmN0aW9uIHNpbXVsYXRlTW91c2VFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgdmFyIGV2ZW50TWFwID0ge1xuICAgICd0b3VjaHN0YXJ0JzogJ21vdXNlZG93bicsXG4gICAgJ3RvdWNobW92ZSc6ICdtb3VzZW1vdmUnLFxuICAgICd0b3VjaGVuZCc6ICdtb3VzZXVwJ1xuICB9O1xuICB0b3VjaC50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldmVudE1hcFtlLnR5cGVdLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIHZpZXc6IHdpbmRvdyxcbiAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgc2NyZWVuWDogdG91Y2guc2NyZWVuWCxcbiAgICBzY3JlZW5ZOiB0b3VjaC5zY3JlZW5ZXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBsaXN0IG9mIGhhbmRsZXMgdG8gY3JlYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBvc2l0aW9uIC0gVGhlIHggYW5kIHkgcmF0aW8gcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW5cbiAqICAgICAgdGhlIGNyb3AgcmVnaW9uLiBBY2NlcHRzIGEgdmFsdWUgYmV0d2VlbiAwIHRvIDEgaW4gdGhlIG9yZGVyIG9mIFtYLCBZXS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnN0cmFpbnRzIC0gRGVmaW5lIHRoZSBzaWRlIG9mIHRoZSBjcm9wIHJlZ2lvbiB0aGF0IGlzIHRvXG4gKiAgICAgIGJlIGFmZmVjdGVkIGJ5IHRoaXMgaGFuZGxlLiBBY2NlcHRzIGEgdmFsdWUgb2YgMCBvciAxIGluIHRoZSBvcmRlciBvZlxuICogICAgICBbVE9QLCBSSUdIVCwgQk9UVE9NLCBMRUZUXS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjdXJzb3IgLSBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqL1xudmFyIEhBTkRMRVMgPSBbeyBwb3NpdGlvbjogWzAuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAwLCAwLCAxXSwgY3Vyc29yOiAnbnctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAwLjBdLCBjb25zdHJhaW50czogWzEsIDAsIDAsIDBdLCBjdXJzb3I6ICduLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAxLCAwLCAwXSwgY3Vyc29yOiAnbmUtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMS4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDEsIDAsIDBdLCBjdXJzb3I6ICdlLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAxLCAxLCAwXSwgY3Vyc29yOiAnc2UtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAxLjBdLCBjb25zdHJhaW50czogWzAsIDAsIDEsIDBdLCBjdXJzb3I6ICdzLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzAuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAwLCAxLCAxXSwgY3Vyc29yOiAnc3ctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDAsIDAsIDFdLCBjdXJzb3I6ICd3LXJlc2l6ZScgfV07XG52YXIgQ3JvcHByQ29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3JvcHByQ29yZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwckNvcmUpO1xuICAgIHRoaXMub3B0aW9ucyA9IENyb3BwckNvcmUucGFyc2VPcHRpb25zKG9wdGlvbnMgfHwge30pO1xuICAgIGlmICghZWxlbWVudC5ub2RlTmFtZSkge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICdVbmFibGUgdG8gZmluZCBlbGVtZW50Lic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICB0aHJvdyAnSW1hZ2Ugc3JjIG5vdCBwcm92aWRlZC4nO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc3RvcmUgPSB7XG4gICAgICBwYXJlbnQ6IGVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICB9O1xuICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgIGlmIChlbGVtZW50LndpZHRoID09PSAwIHx8IGVsZW1lbnQuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNsYXNzKENyb3BwckNvcmUsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jcmVhdGVET00oZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMuY29udmVydFRvUGl4ZWxzKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRoaXMuYXR0YWNoSGFuZGxlckV2ZW50cygpO1xuICAgICAgdGhpcy5hdHRhY2hSZWdpb25FdmVudHMoKTtcbiAgICAgIHRoaXMuYXR0YWNoT3ZlcmxheUV2ZW50cygpO1xuICAgICAgdGhpcy5ib3ggPSB0aGlzLmluaXRpYWxpemVCb3godGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5pdGlhbGl6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Jbml0aWFsaXplKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZURPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURPTSh0YXJnZXRFbCkge1xuICAgICAgdGhpcy5jb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc05hbWUgPSAnY3JvcHByLWNvbnRhaW5lcic7XG4gICAgICB0aGlzLmV2ZW50QnVzID0gdGhpcy5jb250YWluZXJFbDtcbiAgICAgIGVuYWJsZVRvdWNoKHRoaXMuY29udGFpbmVyRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmNsYXNzTmFtZSA9ICdjcm9wcHInO1xuICAgICAgdGhpcy5pbWFnZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB0aGlzLmltYWdlRWwuc2V0QXR0cmlidXRlKCdzcmMnLCB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpKTtcbiAgICAgIHRoaXMuaW1hZ2VFbC5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRhcmdldEVsLmdldEF0dHJpYnV0ZSgnYWx0JykpO1xuICAgICAgdGhpcy5pbWFnZUVsLmNsYXNzTmFtZSA9ICdjcm9wcHItaW1hZ2UnO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbCA9IHRoaXMuaW1hZ2VFbC5jbG9uZU5vZGUoKTtcbiAgICAgIHRoaXMuaW1hZ2VDbGlwcGVkRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1pbWFnZUNsaXBwZWQnO1xuICAgICAgdGhpcy5yZWdpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5yZWdpb25FbC5jbGFzc05hbWUgPSAnY3JvcHByLXJlZ2lvbic7XG4gICAgICB0aGlzLm92ZXJsYXlFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vdmVybGF5RWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1vdmVybGF5JztcbiAgICAgIHZhciBoYW5kbGVDb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaGFuZGxlQ29udGFpbmVyRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1oYW5kbGVDb250YWluZXInO1xuICAgICAgdGhpcy5oYW5kbGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhBTkRMRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyBIYW5kbGUoSEFORExFU1tpXS5wb3NpdGlvbiwgSEFORExFU1tpXS5jb25zdHJhaW50cywgSEFORExFU1tpXS5jdXJzb3IsIHRoaXMuZXZlbnRCdXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgICAgICBoYW5kbGVDb250YWluZXJFbC5hcHBlbmRDaGlsZChoYW5kbGUuZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VDbGlwcGVkRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5yZWdpb25FbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlFbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZChoYW5kbGVDb250YWluZXJFbCk7XG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRhcmdldEVsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHRoaXMuY29udGFpbmVyRWwsIHRhcmdldEVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuaW1hZ2VFbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5ib3ggPSBfdGhpczIuaW5pdGlhbGl6ZUJveChfdGhpczIub3B0aW9ucyk7XG4gICAgICAgIF90aGlzMi5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmltYWdlRWwuc3JjID0gc3JjO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbC5zcmMgPSBzcmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmUucGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLl9yZXN0b3JlLmVsZW1lbnQsIHRoaXMuY29udGFpbmVyRWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYm94IHJlZ2lvbiB3aXRoIGEgc2V0IG9mIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge0JveH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQm94KG9wdHMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdHMuc3RhcnRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IG9wdHMuc3RhcnRTaXplLmhlaWdodDtcbiAgICAgIHZhciBib3ggPSBuZXcgQm94KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYm94LmNvbnN0cmFpblRvUmF0aW8ob3B0cy5hc3BlY3RSYXRpbywgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgbWluID0gb3B0cy5taW5TaXplO1xuICAgICAgdmFyIG1heCA9IG9wdHMubWF4U2l6ZTtcbiAgICAgIGJveC5jb25zdHJhaW5Ub1NpemUobWF4LndpZHRoLCBtYXguaGVpZ2h0LCBtaW4ud2lkdGgsIG1pbi5oZWlnaHQsIFswLjUsIDAuNV0sIG9wdHMuYXNwZWN0UmF0aW8pO1xuICAgICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgcGFyZW50SGVpZ2h0ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgYm94LmNvbnN0cmFpblRvQm91bmRhcnkocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgeCA9IHRoaXMuY3JvcHBlckVsLm9mZnNldFdpZHRoIC8gMiAtIGJveC53aWR0aCgpIC8gMjtcbiAgICAgIHZhciB5ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0IC8gMiAtIGJveC5oZWlnaHQoKSAvIDI7XG4gICAgICBib3gubW92ZSh4LCB5KTtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuYm94LndpZHRoKCkpLFxuICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpLFxuICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh0aGlzLmJveC54MSksXG4gICAgICAgICAgeTEgPSBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB4MiA9IE1hdGgucm91bmQodGhpcy5ib3gueDIpLFxuICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh0aGlzLmJveC55Mik7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHgxICsgJ3B4LCAnICsgeTEgKyAncHgpJztcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBfdGhpczMucmVnaW9uRWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgX3RoaXMzLmltYWdlQ2xpcHBlZEVsLnN0eWxlLmNsaXAgPSAncmVjdCgnICsgeTEgKyAncHgsICcgKyB4MiArICdweCwgJyArIHkyICsgJ3B4LCAnICsgeDEgKyAncHgpJztcbiAgICAgICAgdmFyIGNlbnRlciA9IF90aGlzMy5ib3guZ2V0QWJzb2x1dGVQb2ludChbLjUsIC41XSk7XG4gICAgICAgIHZhciB4U2lnbiA9IGNlbnRlclswXSAtIF90aGlzMy5jcm9wcGVyRWwub2Zmc2V0V2lkdGggLyAyID4+IDMxO1xuICAgICAgICB2YXIgeVNpZ24gPSBjZW50ZXJbMV0gLSBfdGhpczMuY3JvcHBlckVsLm9mZnNldEhlaWdodCAvIDIgPj4gMzE7XG4gICAgICAgIHZhciBxdWFkcmFudCA9ICh4U2lnbiBeIHlTaWduKSArIHlTaWduICsgeVNpZ24gKyA0O1xuICAgICAgICB2YXIgZm9yZWdyb3VuZEhhbmRsZUluZGV4ID0gLTIgKiBxdWFkcmFudCArIDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaGFuZGxlID0gX3RoaXMzLmhhbmRsZXNbaV07XG4gICAgICAgICAgdmFyIGhhbmRsZVdpZHRoID0gaGFuZGxlLmVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIHZhciBoYW5kbGVIZWlnaHQgPSBoYW5kbGUuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHZhciBsZWZ0ID0geDEgKyB3aWR0aCAqIGhhbmRsZS5wb3NpdGlvblswXSAtIGhhbmRsZVdpZHRoIC8gMjtcbiAgICAgICAgICB2YXIgdG9wID0geTEgKyBoZWlnaHQgKiBoYW5kbGUucG9zaXRpb25bMV0gLSBoYW5kbGVIZWlnaHQgLyAyO1xuICAgICAgICAgIGhhbmRsZS5lbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBNYXRoLnJvdW5kKGxlZnQpICsgJ3B4LCAnICsgTWF0aC5yb3VuZCh0b3ApICsgJ3B4KSc7XG4gICAgICAgICAgaGFuZGxlLmVsLnN0eWxlLnpJbmRleCA9IGZvcmVncm91bmRIYW5kbGVJbmRleCA9PSBpID8gNSA6IDQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaEhhbmRsZXJFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hIYW5kbGVyRXZlbnRzKCkge1xuICAgICAgdmFyIGV2ZW50QnVzID0gdGhpcy5ldmVudEJ1cztcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZXN0YXJ0JywgdGhpcy5vbkhhbmRsZU1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZW1vdmUnLCB0aGlzLm9uSGFuZGxlTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZWVuZCcsIHRoaXMub25IYW5kbGVNb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaFJlZ2lvbkV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaFJlZ2lvbkV2ZW50cygpIHtcbiAgICAgIHZhciBldmVudEJ1cyA9IHRoaXMuZXZlbnRCdXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlZ2lvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbnN0YXJ0JywgdGhpcy5vblJlZ2lvbk1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbm1vdmUnLCB0aGlzLm9uUmVnaW9uTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbmVuZCcsIHRoaXMub25SZWdpb25Nb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgICBldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVnaW9uc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZ2lvbm1vdmUnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIGV2ZW50QnVzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyZWdpb25lbmQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2hPdmVybGF5RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoT3ZlcmxheUV2ZW50cygpIHtcbiAgICAgIHZhciBTT1VUSEVBU1RfSEFORExFX0lEWCA9IDQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG1wQm94ID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuY3JvcHBlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgbW91c2VYID0gZS5jbGllbnRYIC0gY29udGFpbmVyLmxlZnQ7XG4gICAgICAgIHZhciBtb3VzZVkgPSBlLmNsaWVudFkgLSBjb250YWluZXIudG9wO1xuICAgICAgICB0bXBCb3ggPSBzZWxmLmJveDtcbiAgICAgICAgc2VsZi5ib3ggPSBuZXcgQm94KG1vdXNlWCwgbW91c2VZLCBtb3VzZVggKyAxLCBtb3VzZVkgKyAxKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZi5oYW5kbGVzW1NPVVRIRUFTVF9IQU5ETEVfSURYXSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlbW92ZScsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgaWYgKHNlbGYuYm94LndpZHRoKCkgPT09IDEgJiYgc2VsZi5ib3guaGVpZ2h0KCkgPT09IDEpIHtcbiAgICAgICAgICBzZWxmLmJveCA9IHRtcEJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgICAgIGRldGFpbDogeyBtb3VzZVg6IGUuY2xpZW50WCwgbW91c2VZOiBlLmNsaWVudFkgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVTdGFydChlKSB7XG4gICAgICB2YXIgaGFuZGxlID0gZS5kZXRhaWwuaGFuZGxlO1xuICAgICAgdmFyIG9yaWdpblBvaW50ID0gWzEgLSBoYW5kbGUucG9zaXRpb25bMF0sIDEgLSBoYW5kbGUucG9zaXRpb25bMV1dO1xuICAgICAgdmFyIF9ib3gkZ2V0QWJzb2x1dGVQb2ludCA9IHRoaXMuYm94LmdldEFic29sdXRlUG9pbnQob3JpZ2luUG9pbnQpLFxuICAgICAgICAgIF9ib3gkZ2V0QWJzb2x1dGVQb2ludDIgPSBzbGljZWRUb0FycmF5KF9ib3gkZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMF0sXG4gICAgICAgICAgb3JpZ2luWSA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMV07XG4gICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IHsgaGFuZGxlOiBoYW5kbGUsIG9yaWdpblBvaW50OiBvcmlnaW5Qb2ludCwgb3JpZ2luWDogb3JpZ2luWCwgb3JpZ2luWTogb3JpZ2luWSB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wU3RhcnQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkhhbmRsZU1vdmVNb3ZpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVNb3ZpbmcoZSkge1xuICAgICAgdmFyIF9lJGRldGFpbCA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbC5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsLm1vdXNlWTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIGlmIChtb3VzZVggPCAwKSB7XG4gICAgICAgIG1vdXNlWCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlWCA+IGNvbnRhaW5lci53aWR0aCkge1xuICAgICAgICBtb3VzZVggPSBjb250YWluZXIud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VZIDwgMCkge1xuICAgICAgICBtb3VzZVkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZVkgPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgIG1vdXNlWSA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luUG9pbnQuc2xpY2UoKTtcbiAgICAgIHZhciBvcmlnaW5YID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWDtcbiAgICAgIHZhciBvcmlnaW5ZID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWTtcbiAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmFjdGl2ZUhhbmRsZS5oYW5kbGU7XG4gICAgICB2YXIgVE9QX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbMF0gPT09IDE7XG4gICAgICB2YXIgUklHSFRfTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1sxXSA9PT0gMTtcbiAgICAgIHZhciBCT1RUT01fTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1syXSA9PT0gMTtcbiAgICAgIHZhciBMRUZUX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbM10gPT09IDE7XG4gICAgICB2YXIgTVVMVElfQVhJUyA9IChMRUZUX01PVkFCTEUgfHwgUklHSFRfTU9WQUJMRSkgJiYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKTtcbiAgICAgIHZhciB4MSA9IExFRlRfTU9WQUJMRSB8fCBSSUdIVF9NT1ZBQkxFID8gb3JpZ2luWCA6IHRoaXMuYm94LngxO1xuICAgICAgdmFyIHgyID0gTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUgPyBvcmlnaW5YIDogdGhpcy5ib3gueDI7XG4gICAgICB2YXIgeTEgPSBUT1BfTU9WQUJMRSB8fCBCT1RUT01fTU9WQUJMRSA/IG9yaWdpblkgOiB0aGlzLmJveC55MTtcbiAgICAgIHZhciB5MiA9IFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFID8gb3JpZ2luWSA6IHRoaXMuYm94LnkyO1xuICAgICAgeDEgPSBMRUZUX01PVkFCTEUgPyBtb3VzZVggOiB4MTtcbiAgICAgIHgyID0gUklHSFRfTU9WQUJMRSA/IG1vdXNlWCA6IHgyO1xuICAgICAgeTEgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA6IHkxO1xuICAgICAgeTIgPSBCT1RUT01fTU9WQUJMRSA/IG1vdXNlWSA6IHkyO1xuICAgICAgdmFyIGlzRmxpcHBlZFggPSBmYWxzZSxcbiAgICAgICAgICBpc0ZsaXBwZWRZID0gZmFsc2U7XG4gICAgICBpZiAoTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUpIHtcbiAgICAgICAgaXNGbGlwcGVkWCA9IExFRlRfTU9WQUJMRSA/IG1vdXNlWCA+IG9yaWdpblggOiBtb3VzZVggPCBvcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKSB7XG4gICAgICAgIGlzRmxpcHBlZFkgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA+IG9yaWdpblkgOiBtb3VzZVkgPCBvcmlnaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmxpcHBlZFgpIHtcbiAgICAgICAgdmFyIHRtcCA9IHgxO3gxID0geDI7eDIgPSB0bXA7XG4gICAgICAgIG9yaWdpblswXSA9IDEgLSBvcmlnaW5bMF07XG4gICAgICB9XG4gICAgICBpZiAoaXNGbGlwcGVkWSkge1xuICAgICAgICB2YXIgX3RtcCA9IHkxO3kxID0geTI7eTIgPSBfdG1wO1xuICAgICAgICBvcmlnaW5bMV0gPSAxIC0gb3JpZ2luWzFdO1xuICAgICAgfVxuICAgICAgdmFyIGJveCA9IG5ldyBCb3goeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbykge1xuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKE1VTFRJX0FYSVMpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBtb3VzZVkgPiBib3gueTEgKyByYXRpbyAqIGJveC53aWR0aCgpIHx8IG1vdXNlWSA8IGJveC55MiAtIHJhdGlvICogYm94LndpZHRoKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoVE9QX01PVkFCTEUgfHwgQk9UVE9NX01PVkFCTEUpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXRpb01vZGUgPSBpc1ZlcnRpY2FsTW92ZW1lbnQgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGJveC5jb25zdHJhaW5Ub1JhdGlvKHJhdGlvLCBvcmlnaW4sIHJhdGlvTW9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pblNpemU7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5vcHRpb25zLm1heFNpemU7XG4gICAgICBib3guY29uc3RyYWluVG9TaXplKG1heC53aWR0aCwgbWF4LmhlaWdodCwgbWluLndpZHRoLCBtaW4uaGVpZ2h0LCBvcmlnaW4sIHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBwYXJlbnRIZWlnaHQgPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBib3guY29uc3RyYWluVG9Cb3VuZGFyeShwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgdGhpcy5ib3ggPSBib3g7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IYW5kbGVNb3ZlRW5kKGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblJlZ2lvbk1vdmVTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZVN0YXJ0KGUpIHtcbiAgICAgIHZhciBfZSRkZXRhaWwyID0gZS5kZXRhaWwsXG4gICAgICAgICAgbW91c2VYID0gX2UkZGV0YWlsMi5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsMi5tb3VzZVk7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jcm9wcGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBtb3VzZVggPSBtb3VzZVggLSBjb250YWluZXIubGVmdDtcbiAgICAgIG1vdXNlWSA9IG1vdXNlWSAtIGNvbnRhaW5lci50b3A7XG4gICAgICB0aGlzLmN1cnJlbnRNb3ZlID0ge1xuICAgICAgICBvZmZzZXRYOiBtb3VzZVggLSB0aGlzLmJveC54MSxcbiAgICAgICAgb2Zmc2V0WTogbW91c2VZIC0gdGhpcy5ib3gueTFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcFN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZU1vdmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZU1vdmluZyhlKSB7XG4gICAgICB2YXIgX2UkZGV0YWlsMyA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbDMubW91c2VYLFxuICAgICAgICAgIG1vdXNlWSA9IF9lJGRldGFpbDMubW91c2VZO1xuICAgICAgdmFyIF9jdXJyZW50TW92ZSA9IHRoaXMuY3VycmVudE1vdmUsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9jdXJyZW50TW92ZS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfY3VycmVudE1vdmUub2Zmc2V0WTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIHRoaXMuYm94Lm1vdmUobW91c2VYIC0gb2Zmc2V0WCwgbW91c2VZIC0gb2Zmc2V0WSk7XG4gICAgICBpZiAodGhpcy5ib3gueDEgPCAwKSB7XG4gICAgICAgIHRoaXMuYm94Lm1vdmUoMCwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib3gueDIgPiBjb250YWluZXIud2lkdGgpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShjb250YWluZXIud2lkdGggLSB0aGlzLmJveC53aWR0aCgpLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MSA8IDApIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MiA+IGNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCBjb250YWluZXIuaGVpZ2h0IC0gdGhpcy5ib3guaGVpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZUVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZUVuZChlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgaWYgKG1vZGUgPT09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IHRoaXMub3B0aW9ucy5yZXR1cm5Nb2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUgPT0gJ3JlYWwnKSB7XG4gICAgICAgIHZhciBhY3R1YWxXaWR0aCA9IHRoaXMuaW1hZ2VFbC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSB0aGlzLmltYWdlRWwubmF0dXJhbEhlaWdodDtcbiAgICAgICAgdmFyIF9pbWFnZUVsJGdldEJvdW5kaW5nQyA9IHRoaXMuaW1hZ2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQy53aWR0aCxcbiAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MuaGVpZ2h0O1xuICAgICAgICB2YXIgZmFjdG9yWCA9IGFjdHVhbFdpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICB2YXIgZmFjdG9yWSA9IGFjdHVhbEhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJveC54MSAqIGZhY3RvclgpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib3gueTEgKiBmYWN0b3JZKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpICogZmFjdG9yWCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuYm94LmhlaWdodCgpICogZmFjdG9yWSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAncmF0aW8nKSB7XG4gICAgICAgIHZhciBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MyID0gdGhpcy5pbWFnZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgX2VsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIud2lkdGgsXG4gICAgICAgICAgICBfZWxlbWVudEhlaWdodCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIuaGVpZ2h0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJvdW5kKHRoaXMuYm94LngxIC8gX2VsZW1lbnRXaWR0aCwgMyksXG4gICAgICAgICAgeTogcm91bmQodGhpcy5ib3gueTEgLyBfZWxlbWVudEhlaWdodCwgMyksXG4gICAgICAgICAgd2lkdGg6IHJvdW5kKHRoaXMuYm94LndpZHRoKCkgLyBfZWxlbWVudFdpZHRoLCAzKSxcbiAgICAgICAgICBoZWlnaHQ6IHJvdW5kKHRoaXMuYm94LmhlaWdodCgpIC8gX2VsZW1lbnRIZWlnaHQsIDMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3JhdycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKHRoaXMuYm94LngxKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0cykge1xuICAgICAgdmFyIGRlZmF1bHRzJCQxID0ge1xuICAgICAgICBhc3BlY3RSYXRpbzogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsIH0sXG4gICAgICAgIG1pblNpemU6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9LFxuICAgICAgICBzdGFydFNpemU6IHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAsIHVuaXQ6ICclJyB9LFxuICAgICAgICByZXR1cm5Nb2RlOiAncmVhbCcsXG4gICAgICAgIG9uSW5pdGlhbGl6ZTogbnVsbCxcbiAgICAgICAgb25Dcm9wU3RhcnQ6IG51bGwsXG4gICAgICAgIG9uQ3JvcE1vdmU6IG51bGwsXG4gICAgICAgIG9uQ3JvcEVuZDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgICBpZiAob3B0cy5hc3BlY3RSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5hc3BlY3RSYXRpbyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbyA9IG9wdHMuYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5hc3BlY3RSYXRpbyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBvcHRzLmFzcGVjdFJhdGlvWzFdIC8gb3B0cy5hc3BlY3RSYXRpb1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1heFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMubWF4U2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9wdHMubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICBtYXhTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLm1heFNpemVbMF0gfHwgbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG9wdHMubWF4U2l6ZVsxXSB8fCBudWxsLFxuICAgICAgICAgIHVuaXQ6IG9wdHMubWF4U2l6ZVsyXSB8fCAncHgnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbWluU2l6ZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5taW5TaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgIG1pblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IG9wdHMubWluU2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5taW5TaXplWzFdIHx8IG51bGwsXG4gICAgICAgICAgdW5pdDogb3B0cy5taW5TaXplWzJdIHx8ICdweCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMuc3RhcnRTaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5zdGFydFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLnN0YXJ0U2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5zdGFydFNpemVbMV0gfHwgbnVsbCxcbiAgICAgICAgICB1bml0OiBvcHRzLnN0YXJ0U2l6ZVsyXSB8fCAnJSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkluaXRpYWxpemUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uSW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkluaXRpYWxpemUgPSBvcHRzLm9uSW5pdGlhbGl6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkNyb3BTdGFydCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Dcm9wU3RhcnQgPSBvcHRzLm9uQ3JvcFN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcEVuZCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcEVuZCA9IG9wdHMub25Dcm9wRW5kO1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcE1vdmUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ3JvcHByLmpzOiBgb25VcGRhdGVgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIGBvbkNyb3BNb3ZlYCBvciBgb25Dcm9wRW5kYCBpbnN0ZWFkLicpO1xuICAgICAgICBvbkNyb3BNb3ZlID0gb3B0cy5vblVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkNyb3BNb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcE1vdmUgPSBvcHRzLm9uQ3JvcE1vdmU7XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuTW9kZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5yZXR1cm5Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBvcHRzLnJldHVybk1vZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFsncmVhbCcsICdyYXRpbycsICdyYXcnXS5pbmRleE9mKHMpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCByZXR1cm4gbW9kZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5Nb2RlID0gcztcbiAgICAgIH1cbiAgICAgIHZhciBjb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbiBjb252ZXJ0VG9QaXhlbHMoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBzaXplS2V5cyA9IFsnbWF4U2l6ZScsICdtaW5TaXplJywgJ3N0YXJ0U2l6ZSddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHNpemVLZXlzW2ldO1xuICAgICAgICAgIGlmICh0aGlzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0udW5pdCA9PSAnJScpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XS53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XS53aWR0aCA9IHRoaXNba2V5XS53aWR0aCAvIDEwMCAqIHdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzW2tleV0uaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldLmhlaWdodCA9IHRoaXNba2V5XS5oZWlnaHQgLyAxMDAgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV0udW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYgIT09IG51bGwgPyB2IDogZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3BlY3RSYXRpbzogZGVmYXVsdFZhbHVlKGFzcGVjdFJhdGlvLCBkZWZhdWx0cyQkMS5hc3BlY3RSYXRpbyksXG4gICAgICAgIG1heFNpemU6IGRlZmF1bHRWYWx1ZShtYXhTaXplLCBkZWZhdWx0cyQkMS5tYXhTaXplKSxcbiAgICAgICAgbWluU2l6ZTogZGVmYXVsdFZhbHVlKG1pblNpemUsIGRlZmF1bHRzJCQxLm1pblNpemUpLFxuICAgICAgICBzdGFydFNpemU6IGRlZmF1bHRWYWx1ZShzdGFydFNpemUsIGRlZmF1bHRzJCQxLnN0YXJ0U2l6ZSksXG4gICAgICAgIHJldHVybk1vZGU6IGRlZmF1bHRWYWx1ZShyZXR1cm5Nb2RlLCBkZWZhdWx0cyQkMS5yZXR1cm5Nb2RlKSxcbiAgICAgICAgb25Jbml0aWFsaXplOiBkZWZhdWx0VmFsdWUob25Jbml0aWFsaXplLCBkZWZhdWx0cyQkMS5vbkluaXRpYWxpemUpLFxuICAgICAgICBvbkNyb3BTdGFydDogZGVmYXVsdFZhbHVlKG9uQ3JvcFN0YXJ0LCBkZWZhdWx0cyQkMS5vbkNyb3BTdGFydCksXG4gICAgICAgIG9uQ3JvcE1vdmU6IGRlZmF1bHRWYWx1ZShvbkNyb3BNb3ZlLCBkZWZhdWx0cyQkMS5vbkNyb3BNb3ZlKSxcbiAgICAgICAgb25Dcm9wRW5kOiBkZWZhdWx0VmFsdWUob25Dcm9wRW5kLCBkZWZhdWx0cyQkMS5vbkNyb3BFbmQpLFxuICAgICAgICBjb252ZXJ0VG9QaXhlbHM6IGNvbnZlcnRUb1BpeGVsc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3BwckNvcmU7XG59KCk7XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbn1cblxudmFyIENyb3BwciQxID0gZnVuY3Rpb24gKF9Dcm9wcHJDb3JlKSB7XG4gIGluaGVyaXRzKENyb3BwciwgX0Nyb3BwckNvcmUpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIENhbGxzIHRoZSBDcm9wcHJDb3JlJ3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBmdW5jdGlvbiBDcm9wcHIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3Bwcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENyb3Bwci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENyb3BwcikpLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucywgX2RlZmVycmVkKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlXSBXaGljaCBtb2RlIG9mIGNhbGN1bGF0aW9uIHRvIHVzZTogJ3JlYWwnLCAncmF0aW8nIG9yXG4gICAqICAgICAgJ3JhdycuXG4gICAqL1xuICBjcmVhdGVDbGFzcyhDcm9wcHIsIFt7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShtb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ2dldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ3NldEltYWdlJywgdGhpcykuY2FsbCh0aGlzLCBzcmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmV0dXJuIGdldChDcm9wcHIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3JvcHByLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbW92ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICAgIHRoaXMuYm94Lm1vdmUoeCwgeSk7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BFbmQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ3JvcEVuZCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAuNSwgMC41XSAoY2VudGVyKS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplVG8od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWy41LCAuNV07XG4gICAgICB0aGlzLmJveC5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGNyb3AgcmVnaW9uIGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvcmlnaW4gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgIERlZmF1bHRzIHRvIFswLjUsIDAuNV0gKGNlbnRlcikuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZUJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IpIHtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsuNSwgLjVdO1xuICAgICAgdGhpcy5ib3guc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmJveCA9IHRoaXMuaW5pdGlhbGl6ZUJveCh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3JvcHByO1xufShDcm9wcHJDb3JlKTtcblxucmV0dXJuIENyb3BwciQxO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/croppr/dist/croppr.js\n");

/***/ }),

/***/ "./node_modules/croppr/src/box.js":
/*!****************************************!*\
  !*** ./node_modules/croppr/src/box.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Box; });\n/**\n * Box component\n */\nclass Box {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /** \n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  set(x1 = null, y1 = null, x2 = null, y2 = null) {\n    this.x1 = x1 == null ? this.x1 : x1;\n    this.y1 = y1 == null ? this.y1 : y1;\n    this.x2 = x2 == null ? this.x2 : x2;\n    this.y2 = y2 == null ? this.y2 : y2;\n    return this;\n  }\n\n  /**\n   * Calculates the width of the box.\n   * @returns {Number}\n   */\n  width() {\n    return Math.abs(this.x2 - this.x1);\n  }\n\n  /**\n   * Calculates the height of the box.\n   * @returns {Number}\n   */\n  height() {\n    return Math.abs(this.y2 - this.y1);\n  }\n\n  /**\n   * Resizes the box to a new size.\n   * @param {Number} newWidth\n   * @param {Number} newHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  resize(newWidth, newHeight, origin = [0, 0]) {\n    const fromX = this.x1 + (this.width() * origin[0]);\n    const fromY = this.y1 + (this.height() * origin[1]);\n\n    this.x1 = fromX - (newWidth * origin[0]);\n    this.y1 = fromY - (newHeight * origin[1]);\n    this.x2 = this.x1 + newWidth;\n    this.y2 = this.y1 + newHeight;\n\n    return this;\n  }\n\n  /**\n   * Scale the box by a factor.\n   * @param {Number} factor\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  scale(factor, origin = [0, 0]) {\n    const newWidth = this.width() * factor;\n    const newHeight = this.height() * factor;\n    this.resize(newWidth, newHeight, origin);\n    return this;\n  }\n\n  /**\n   * Move the box to the specified coordinates.\n   */\n  move(x = null, y = null) {\n    let width = this.width();\n    let height = this.height();\n    x = x === null ? this.x1 : x;\n    y = y === null ? this.y1 : y;\n\n    this.x1 = x;\n    this.y1 = y;\n    this.x2 = x + width;\n    this.y2 = y + height;\n    return this;\n  }\n\n  /**\n   * Get relative x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getRelativePoint(point = [0, 0]) {\n    const x = this.width() * point[0];\n    const y = this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Get absolute x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getAbsolutePoint(point = [0, 0]) {\n    const x = this.x1 + this.width() * point[0];\n    const y = this.y1 + this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Constrain the box to a fixed ratio.\n   * @param {Number} ratio\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {String} [grow] The axis to grow to maintain the ratio.\n   *     Defaults to 'height'.\n   */\n  constrainToRatio(ratio, origin = [0, 0], grow = 'height') {\n    if (ratio === null) { return; }\n    const width = this.width();\n    const height = this.height();\n    switch (grow) {\n      case 'height': // Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n        break;\n      case 'width': // Grow width only\n        this.resize(this.height() * 1 / ratio, this.height(), origin);\n        break;\n      default: // Default: Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box within a boundary.\n   * @param {Number} boundaryWidth\n   * @param {Number} boundaryHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   */\n  constrainToBoundary(boundaryWidth, boundaryHeight, origin = [0, 0]) {\n\n    // Calculate the maximum sizes for each direction of growth\n    const [originX, originY] = this.getAbsolutePoint(origin);\n    const maxIfLeft = originX\n    const maxIfTop = originY\n    const maxIfRight = boundaryWidth - originX\n    const maxIfBottom = boundaryHeight - originY\n\n    // Express the direction of growth in terms of left, both,\n    // and right as -1, 0, and 1 respectively. Ditto for top/both/down.\n    const directionX = -2 * origin[0] + 1;\n    const directionY = -2 * origin[1] + 1;\n\n    // Determine the max size to use according to the direction of growth.\n    let [maxWidth, maxHeight] = [null, null];\n    switch (directionX) {\n      case -1: maxWidth = maxIfLeft; break;\n      case 0: maxWidth = Math.min(maxIfLeft, maxIfRight) * 2; break;\n      case +1: maxWidth = maxIfRight; break;\n    }\n    switch (directionY) {\n      case -1: maxHeight = maxIfTop; break;\n      case 0: maxHeight = Math.min(maxIfTop, maxIfBottom) * 2; break;\n      case +1: maxHeight = maxIfBottom; break;\n    }\n\n    // Resize if the box exceeds the calculated max width/height.\n    if (this.width() > maxWidth) {\n      const factor = maxWidth / this.width();\n      this.scale(factor, origin);\n    }\n    if (this.height() > maxHeight) {\n      const factor = maxHeight / this.height();\n      this.scale(factor, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box to a maximum/minimum size.\n   * @param {Number} [maxWidth]\n   * @param {Number} [maxHeight]\n   * @param {Number} [minWidth]\n   * @param {Number} [minHeight]\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {Number} [ratio] Ratio to maintain.\n   */\n  constrainToSize(maxWidth = null, maxHeight = null,\n    minWidth = null, minHeight = null,\n    origin = [0, 0], ratio = null) {\n\n    // Calculate new max/min widths & heights that constrains to the ratio\n    if (ratio) {\n      if (ratio > 1) {\n        maxWidth = maxHeight * 1 / ratio;\n        minHeight = minHeight * ratio;\n      } else if (ratio < 1) {\n        maxHeight = maxWidth * ratio;\n        minWidth = minHeight * 1 / ratio;\n      }\n    }\n\n    if (maxWidth && this.width() > maxWidth) {\n      const newWidth = maxWidth,\n        newHeight = ratio === null ? this.height() : maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (maxHeight && this.height() > maxHeight) {\n      const newWidth = ratio === null ? this.width() : maxWidth,\n        newHeight = maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minWidth && this.width() < minWidth) {\n      const newWidth = minWidth,\n        newHeight = ratio === null ? this.height() : minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minHeight && this.height() < minHeight) {\n      const newWidth = ratio === null ? this.width() : minWidth,\n        newHeight = minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    return this;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL3NyYy9ib3guanM/NGY5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsNkRBQTZEO0FBQzdELHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDhEQUE4RDtBQUM5RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcm9wcHIvc3JjL2JveC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQm94IGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3gge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCb3ggaW5zdGFuY2UuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICB9XG5cbiAgLyoqIFxuICAgKiBTZXRzIHRoZSBuZXcgZGltZW5zaW9ucyBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIHNldCh4MSA9IG51bGwsIHkxID0gbnVsbCwgeDIgPSBudWxsLCB5MiA9IG51bGwpIHtcbiAgICB0aGlzLngxID0geDEgPT0gbnVsbCA/IHRoaXMueDEgOiB4MTtcbiAgICB0aGlzLnkxID0geTEgPT0gbnVsbCA/IHRoaXMueTEgOiB5MTtcbiAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IHRoaXMueTIgOiB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCBvZiB0aGUgYm94LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGJveCB0byBhIG5ldyBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV3V2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgIERlZmF1bHRzIHRvIFswLCAwXSAodG9wIGxlZnQpLlxuICAgKi9cbiAgcmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGZyb21YID0gdGhpcy54MSArICh0aGlzLndpZHRoKCkgKiBvcmlnaW5bMF0pO1xuICAgIGNvbnN0IGZyb21ZID0gdGhpcy55MSArICh0aGlzLmhlaWdodCgpICogb3JpZ2luWzFdKTtcblxuICAgIHRoaXMueDEgPSBmcm9tWCAtIChuZXdXaWR0aCAqIG9yaWdpblswXSk7XG4gICAgdGhpcy55MSA9IGZyb21ZIC0gKG5ld0hlaWdodCAqIG9yaWdpblsxXSk7XG4gICAgdGhpcy54MiA9IHRoaXMueDEgKyBuZXdXaWR0aDtcbiAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBib3ggYnkgYSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICovXG4gIHNjYWxlKGZhY3Rvciwgb3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoKCkgKiBmYWN0b3I7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSAqIGZhY3RvcjtcbiAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGJveCB0byB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgbW92ZSh4ID0gbnVsbCwgeSA9IG51bGwpIHtcbiAgICBsZXQgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgbGV0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgeCA9IHggPT09IG51bGwgPyB0aGlzLngxIDogeDtcbiAgICB5ID0geSA9PT0gbnVsbCA/IHRoaXMueTEgOiB5O1xuXG4gICAgdGhpcy54MSA9IHg7XG4gICAgdGhpcy55MSA9IHk7XG4gICAgdGhpcy54MiA9IHggKyB3aWR0aDtcbiAgICB0aGlzLnkyID0geSArIGhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmVsYXRpdmUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRSZWxhdGl2ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgIGNvbnN0IHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRBYnNvbHV0ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMueDEgKyB0aGlzLndpZHRoKCkgKiBwb2ludFswXTtcbiAgICBjb25zdCB5ID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBwb2ludFsxXTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbiB0aGUgYm94IHRvIGEgZml4ZWQgcmF0aW8uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3Jvd10gVGhlIGF4aXMgdG8gZ3JvdyB0byBtYWludGFpbiB0aGUgcmF0aW8uXG4gICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICovXG4gIGNvbnN0cmFpblRvUmF0aW8ocmF0aW8sIG9yaWdpbiA9IFswLCAwXSwgZ3JvdyA9ICdoZWlnaHQnKSB7XG4gICAgaWYgKHJhdGlvID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgc3dpdGNoIChncm93KSB7XG4gICAgICBjYXNlICdoZWlnaHQnOiAvLyBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOiAvLyBHcm93IHdpZHRoIG9ubHlcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBEZWZhdWx0OiBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RyYWluIHRoZSBib3ggd2l0aGluIGEgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeUhlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqL1xuICBjb25zdHJhaW5Ub0JvdW5kYXJ5KGJvdW5kYXJ5V2lkdGgsIGJvdW5kYXJ5SGVpZ2h0LCBvcmlnaW4gPSBbMCwgMF0pIHtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBzaXplcyBmb3IgZWFjaCBkaXJlY3Rpb24gb2YgZ3Jvd3RoXG4gICAgY29uc3QgW29yaWdpblgsIG9yaWdpblldID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbik7XG4gICAgY29uc3QgbWF4SWZMZWZ0ID0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmVG9wID0gb3JpZ2luWVxuICAgIGNvbnN0IG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmQm90dG9tID0gYm91bmRhcnlIZWlnaHQgLSBvcmlnaW5ZXG5cbiAgICAvLyBFeHByZXNzIHRoZSBkaXJlY3Rpb24gb2YgZ3Jvd3RoIGluIHRlcm1zIG9mIGxlZnQsIGJvdGgsXG4gICAgLy8gYW5kIHJpZ2h0IGFzIC0xLCAwLCBhbmQgMSByZXNwZWN0aXZlbHkuIERpdHRvIGZvciB0b3AvYm90aC9kb3duLlxuICAgIGNvbnN0IGRpcmVjdGlvblggPSAtMiAqIG9yaWdpblswXSArIDE7XG4gICAgY29uc3QgZGlyZWN0aW9uWSA9IC0yICogb3JpZ2luWzFdICsgMTtcblxuICAgIC8vIERldGVybWluZSB0aGUgbWF4IHNpemUgdG8gdXNlIGFjY29yZGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIGdyb3d0aC5cbiAgICBsZXQgW21heFdpZHRoLCBtYXhIZWlnaHRdID0gW251bGwsIG51bGxdO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uWCkge1xuICAgICAgY2FzZSAtMTogbWF4V2lkdGggPSBtYXhJZkxlZnQ7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhXaWR0aCA9IE1hdGgubWluKG1heElmTGVmdCwgbWF4SWZSaWdodCkgKiAyOyBicmVhaztcbiAgICAgIGNhc2UgKzE6IG1heFdpZHRoID0gbWF4SWZSaWdodDsgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZGlyZWN0aW9uWSkge1xuICAgICAgY2FzZSAtMTogbWF4SGVpZ2h0ID0gbWF4SWZUb3A7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjsgYnJlYWs7XG4gICAgICBjYXNlICsxOiBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTsgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplIGlmIHRoZSBib3ggZXhjZWVkcyB0aGUgY2FsY3VsYXRlZCBtYXggd2lkdGgvaGVpZ2h0LlxuICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IG1heEhlaWdodCAvIHRoaXMuaGVpZ2h0KCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW4gdGhlIGJveCB0byBhIG1heGltdW0vbWluaW11bSBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heEhlaWdodF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5XaWR0aF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAqL1xuICBjb25zdHJhaW5Ub1NpemUobWF4V2lkdGggPSBudWxsLCBtYXhIZWlnaHQgPSBudWxsLFxuICAgIG1pbldpZHRoID0gbnVsbCwgbWluSGVpZ2h0ID0gbnVsbCxcbiAgICBvcmlnaW4gPSBbMCwgMF0sIHJhdGlvID0gbnVsbCkge1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyBtYXgvbWluIHdpZHRocyAmIGhlaWdodHMgdGhhdCBjb25zdHJhaW5zIHRvIHRoZSByYXRpb1xuICAgIGlmIChyYXRpbykge1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICBtYXhXaWR0aCA9IG1heEhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMSkge1xuICAgICAgICBtYXhIZWlnaHQgPSBtYXhXaWR0aCAqIHJhdGlvO1xuICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggJiYgdGhpcy53aWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHJhdGlvID09PSBudWxsID8gdGhpcy53aWR0aCgpIDogbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMuaGVpZ2h0KCkgOiBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIGlmIChtaW5IZWlnaHQgJiYgdGhpcy5oZWlnaHQoKSA8IG1pbkhlaWdodCkge1xuICAgICAgY29uc3QgbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/croppr/src/box.js\n");

/***/ })

}]);