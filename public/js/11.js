(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[11],{

/***/ "./node_modules/blueimp-load-image/js/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global module, require */\n\nmodule.exports = __webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")\n\n__webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\")\n__webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")\n__webpack_require__(/*! ./load-image-fetch */ \"./node_modules/blueimp-load-image/js/load-image-fetch.js\")\n__webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")\n__webpack_require__(/*! ./load-image-exif-map */ \"./node_modules/blueimp-load-image/js/load-image-exif-map.js\")\n__webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")\n__webpack_require__(/*! ./load-image-iptc-map */ \"./node_modules/blueimp-load-image/js/load-image-iptc-map.js\")\n__webpack_require__(/*! ./load-image-orientation */ \"./node_modules/blueimp-load-image/js/load-image-orientation.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2luZGV4LmpzP2ZiZDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWM7O0FBRXZDLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQy9CLG1CQUFPLENBQUMsZ0dBQTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKVxuXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2Utc2NhbGUnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLWZldGNoJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmJylcbnJlcXVpcmUoJy4vbG9hZC1pbWFnZS1leGlmLW1hcCcpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0YycpXG5yZXF1aXJlKCcuL2xvYWQtaW1hZ2UtaXB0Yy1tYXAnKVxucmVxdWlyZSgnLi9sb2FkLWltYWdlLW9yaWVudGF0aW9uJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/index.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-exif */ \"./node_modules/blueimp-load-image/js/load-image-exif.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var ExifMapProto = loadImage.ExifMap.prototype\n\n  ExifMapProto.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    0x8769: {\n      // ExifIFDPointer\n      0x9000: 'ExifVersion', // EXIF version\n      0xa000: 'FlashpixVersion', // Flashpix format version\n      0xa001: 'ColorSpace', // Color space information tag\n      0xa002: 'PixelXDimension', // Valid width of meaningful image\n      0xa003: 'PixelYDimension', // Valid height of meaningful image\n      0xa500: 'Gamma',\n      0x9101: 'ComponentsConfiguration', // Information about channels\n      0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel\n      0x927c: 'MakerNote', // Any desired information written by the manufacturer\n      0x9286: 'UserComment', // Comments by user\n      0xa004: 'RelatedSoundFile', // Name of related sound file\n      0x9003: 'DateTimeOriginal', // Date and time when the original image was generated\n      0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally\n      0x9010: 'OffsetTime', // Time zone when the image file was last changed\n      0x9011: 'OffsetTimeOriginal', // Time zone when the image was stored digitally\n      0x9012: 'OffsetTimeDigitized', // Time zone when the image was stored digitally\n      0x9290: 'SubSecTime', // Fractions of seconds for DateTime\n      0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal\n      0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized\n      0x829a: 'ExposureTime', // Exposure time (in seconds)\n      0x829d: 'FNumber',\n      0x8822: 'ExposureProgram', // Exposure program\n      0x8824: 'SpectralSensitivity', // Spectral sensitivity\n      0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n      0x8828: 'OECF', // Optoelectric conversion factor\n      0x8830: 'SensitivityType',\n      0x8831: 'StandardOutputSensitivity',\n      0x8832: 'RecommendedExposureIndex',\n      0x8833: 'ISOSpeed',\n      0x8834: 'ISOSpeedLatitudeyyy',\n      0x8835: 'ISOSpeedLatitudezzz',\n      0x9201: 'ShutterSpeedValue', // Shutter speed\n      0x9202: 'ApertureValue', // Lens aperture\n      0x9203: 'BrightnessValue', // Value of brightness\n      0x9204: 'ExposureBias', // Exposure bias\n      0x9205: 'MaxApertureValue', // Smallest F number of lens\n      0x9206: 'SubjectDistance', // Distance to subject in meters\n      0x9207: 'MeteringMode', // Metering mode\n      0x9208: 'LightSource', // Kind of light source\n      0x9209: 'Flash', // Flash status\n      0x9214: 'SubjectArea', // Location and area of main subject\n      0x920a: 'FocalLength', // Focal length of the lens in mm\n      0xa20b: 'FlashEnergy', // Strobe energy in BCPS\n      0xa20c: 'SpatialFrequencyResponse',\n      0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit\n      0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit\n      0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution\n      0xa214: 'SubjectLocation', // Location of subject in image\n      0xa215: 'ExposureIndex', // Exposure index selected on camera\n      0xa217: 'SensingMethod', // Image sensor type\n      0xa300: 'FileSource', // Image source (3 == DSC)\n      0xa301: 'SceneType', // Scene type (1 == directly photographed)\n      0xa302: 'CFAPattern', // Color filter array geometric pattern\n      0xa401: 'CustomRendered', // Special processing\n      0xa402: 'ExposureMode', // Exposure mode\n      0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual\n      0xa404: 'DigitalZoomRatio', // Digital zoom ratio\n      0xa405: 'FocalLengthIn35mmFilm',\n      0xa406: 'SceneCaptureType', // Type of scene\n      0xa407: 'GainControl', // Degree of overall image gain adjustment\n      0xa408: 'Contrast', // Direction of contrast processing applied by camera\n      0xa409: 'Saturation', // Direction of saturation processing applied by camera\n      0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera\n      0xa40b: 'DeviceSettingDescription',\n      0xa40c: 'SubjectDistanceRange', // Distance to subject\n      0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image\n      0xa430: 'CameraOwnerName',\n      0xa431: 'BodySerialNumber',\n      0xa432: 'LensSpecification',\n      0xa433: 'LensMake',\n      0xa434: 'LensModel',\n      0xa435: 'LensSerialNumber'\n    },\n    0x8825: {\n      // GPSInfoIFDPointer\n      0x0000: 'GPSVersionID',\n      0x0001: 'GPSLatitudeRef',\n      0x0002: 'GPSLatitude',\n      0x0003: 'GPSLongitudeRef',\n      0x0004: 'GPSLongitude',\n      0x0005: 'GPSAltitudeRef',\n      0x0006: 'GPSAltitude',\n      0x0007: 'GPSTimeStamp',\n      0x0008: 'GPSSatellites',\n      0x0009: 'GPSStatus',\n      0x000a: 'GPSMeasureMode',\n      0x000b: 'GPSDOP',\n      0x000c: 'GPSSpeedRef',\n      0x000d: 'GPSSpeed',\n      0x000e: 'GPSTrackRef',\n      0x000f: 'GPSTrack',\n      0x0010: 'GPSImgDirectionRef',\n      0x0011: 'GPSImgDirection',\n      0x0012: 'GPSMapDatum',\n      0x0013: 'GPSDestLatitudeRef',\n      0x0014: 'GPSDestLatitude',\n      0x0015: 'GPSDestLongitudeRef',\n      0x0016: 'GPSDestLongitude',\n      0x0017: 'GPSDestBearingRef',\n      0x0018: 'GPSDestBearing',\n      0x0019: 'GPSDestDistanceRef',\n      0x001a: 'GPSDestDistance',\n      0x001b: 'GPSProcessingMethod',\n      0x001c: 'GPSAreaInformation',\n      0x001d: 'GPSDateStamp',\n      0x001e: 'GPSDifferential',\n      0x001f: 'GPSHPositioningError'\n    },\n    0xa005: {\n      // InteroperabilityIFDPointer\n      0x0001: 'InteroperabilityIndex'\n    }\n  }\n\n  // IFD1 directory can contain any IFD0 tags:\n  ExifMapProto.tags.ifd1 = ExifMapProto.tags\n\n  ExifMapProto.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'Original',\n      2: 'Horizontal flip',\n      3: 'Rotate 180° CCW',\n      4: 'Vertical flip',\n      5: 'Vertical flip + Rotate 90° CW',\n      6: 'Rotate 90° CW',\n      7: 'Horizontal flip + Rotate 90° CW',\n      8: 'Rotate 90° CCW'\n    }\n  }\n\n  ExifMapProto.getText = function (name) {\n    var value = this.get(name)\n    switch (name) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[name][value]\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return\n        return String.fromCharCode(value[0], value[1], value[2], value[3])\n      case 'ComponentsConfiguration':\n        if (!value) return\n        return (\n          this.stringValues[name][value[0]] +\n          this.stringValues[name][value[1]] +\n          this.stringValues[name][value[2]] +\n          this.stringValues[name][value[3]]\n        )\n      case 'GPSVersionID':\n        if (!value) return\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]\n    }\n    return String(value)\n  }\n\n  ExifMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var obj\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        obj = this[prop]\n        if (obj && obj.getAll) {\n          map[this.ifds[prop].name] = obj.getAll()\n        } else {\n          name = this.tags[prop]\n          if (name) map[name] = this.getText(name)\n        }\n      }\n    }\n    return map\n  }\n\n  ExifMapProto.getName = function (tagCode) {\n    var name = this.tags[tagCode]\n    if (typeof name === 'object') return this.ifds[tagCode].name\n    return name\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = ExifMapProto.tags\n    var prop\n    var ifd\n    var subTags\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        ifd = ExifMapProto.ifds[prop]\n        if (ifd) {\n          subTags = tags[prop]\n          for (prop in subTags) {\n            if (Object.prototype.hasOwnProperty.call(subTags, prop)) {\n              ifd.map[subTags[prop]] = Number(prop)\n            }\n          }\n        } else {\n          ExifMapProto.map[tags[prop]] = Number(prop)\n        }\n      }\n    }\n  })()\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi1tYXAuanM/NzU2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLEVBQUUsdUdBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRCxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi1tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIEV4aWYgTWFwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIEV4aWYgdGFncyBtYXBwaW5nIGJhc2VkIG9uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNlaWRlbGluL2V4aWYtanNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9sb2FkLWltYWdlJywgJy4vbG9hZC1pbWFnZS1leGlmJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoJy4vbG9hZC1pbWFnZScpLCByZXF1aXJlKCcuL2xvYWQtaW1hZ2UtZXhpZicpKVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5sb2FkSW1hZ2UpXG4gIH1cbn0pKGZ1bmN0aW9uIChsb2FkSW1hZ2UpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgdmFyIEV4aWZNYXBQcm90byA9IGxvYWRJbWFnZS5FeGlmTWFwLnByb3RvdHlwZVxuXG4gIEV4aWZNYXBQcm90by50YWdzID0ge1xuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgLy8gVElGRiB0YWdzIChJRkQwKTpcbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAgIDB4MDEwMTogJ0ltYWdlSGVpZ2h0JyxcbiAgICAweDAxMDI6ICdCaXRzUGVyU2FtcGxlJyxcbiAgICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gICAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gICAgMHgwMTEyOiAnT3JpZW50YXRpb24nLFxuICAgIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gICAgMHgwMTFjOiAnUGxhbmFyQ29uZmlndXJhdGlvbicsXG4gICAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gICAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gICAgMHgwMTFhOiAnWFJlc29sdXRpb24nLFxuICAgIDB4MDExYjogJ1lSZXNvbHV0aW9uJyxcbiAgICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gICAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgICAweDAxMTY6ICdSb3dzUGVyU3RyaXAnLFxuICAgIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gICAgMHgwMjAxOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0JyxcbiAgICAweDAyMDI6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgnLFxuICAgIDB4MDEyZDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAgIDB4MDEzZTogJ1doaXRlUG9pbnQnLFxuICAgIDB4MDEzZjogJ1ByaW1hcnlDaHJvbWF0aWNpdGllcycsXG4gICAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAgIDB4MDIxNDogJ1JlZmVyZW5jZUJsYWNrV2hpdGUnLFxuICAgIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgICAweDAxMGU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgICAweDAxMGY6ICdNYWtlJyxcbiAgICAweDAxMTA6ICdNb2RlbCcsXG4gICAgMHgwMTMxOiAnU29mdHdhcmUnLFxuICAgIDB4MDEzYjogJ0FydGlzdCcsXG4gICAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgICAweDg3Njk6IHtcbiAgICAgIC8vIEV4aWZJRkRQb2ludGVyXG4gICAgICAweDkwMDA6ICdFeGlmVmVyc2lvbicsIC8vIEVYSUYgdmVyc2lvblxuICAgICAgMHhhMDAwOiAnRmxhc2hwaXhWZXJzaW9uJywgLy8gRmxhc2hwaXggZm9ybWF0IHZlcnNpb25cbiAgICAgIDB4YTAwMTogJ0NvbG9yU3BhY2UnLCAvLyBDb2xvciBzcGFjZSBpbmZvcm1hdGlvbiB0YWdcbiAgICAgIDB4YTAwMjogJ1BpeGVsWERpbWVuc2lvbicsIC8vIFZhbGlkIHdpZHRoIG9mIG1lYW5pbmdmdWwgaW1hZ2VcbiAgICAgIDB4YTAwMzogJ1BpeGVsWURpbWVuc2lvbicsIC8vIFZhbGlkIGhlaWdodCBvZiBtZWFuaW5nZnVsIGltYWdlXG4gICAgICAweGE1MDA6ICdHYW1tYScsXG4gICAgICAweDkxMDE6ICdDb21wb25lbnRzQ29uZmlndXJhdGlvbicsIC8vIEluZm9ybWF0aW9uIGFib3V0IGNoYW5uZWxzXG4gICAgICAweDkxMDI6ICdDb21wcmVzc2VkQml0c1BlclBpeGVsJywgLy8gQ29tcHJlc3NlZCBiaXRzIHBlciBwaXhlbFxuICAgICAgMHg5MjdjOiAnTWFrZXJOb3RlJywgLy8gQW55IGRlc2lyZWQgaW5mb3JtYXRpb24gd3JpdHRlbiBieSB0aGUgbWFudWZhY3R1cmVyXG4gICAgICAweDkyODY6ICdVc2VyQ29tbWVudCcsIC8vIENvbW1lbnRzIGJ5IHVzZXJcbiAgICAgIDB4YTAwNDogJ1JlbGF0ZWRTb3VuZEZpbGUnLCAvLyBOYW1lIG9mIHJlbGF0ZWQgc291bmQgZmlsZVxuICAgICAgMHg5MDAzOiAnRGF0ZVRpbWVPcmlnaW5hbCcsIC8vIERhdGUgYW5kIHRpbWUgd2hlbiB0aGUgb3JpZ2luYWwgaW1hZ2Ugd2FzIGdlbmVyYXRlZFxuICAgICAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLCAvLyBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIGltYWdlIHdhcyBzdG9yZWQgZGlnaXRhbGx5XG4gICAgICAweDkwMTA6ICdPZmZzZXRUaW1lJywgLy8gVGltZSB6b25lIHdoZW4gdGhlIGltYWdlIGZpbGUgd2FzIGxhc3QgY2hhbmdlZFxuICAgICAgMHg5MDExOiAnT2Zmc2V0VGltZU9yaWdpbmFsJywgLy8gVGltZSB6b25lIHdoZW4gdGhlIGltYWdlIHdhcyBzdG9yZWQgZGlnaXRhbGx5XG4gICAgICAweDkwMTI6ICdPZmZzZXRUaW1lRGlnaXRpemVkJywgLy8gVGltZSB6b25lIHdoZW4gdGhlIGltYWdlIHdhcyBzdG9yZWQgZGlnaXRhbGx5XG4gICAgICAweDkyOTA6ICdTdWJTZWNUaW1lJywgLy8gRnJhY3Rpb25zIG9mIHNlY29uZHMgZm9yIERhdGVUaW1lXG4gICAgICAweDkyOTE6ICdTdWJTZWNUaW1lT3JpZ2luYWwnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVPcmlnaW5hbFxuICAgICAgMHg5MjkyOiAnU3ViU2VjVGltZURpZ2l0aXplZCcsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZURpZ2l0aXplZFxuICAgICAgMHg4MjlhOiAnRXhwb3N1cmVUaW1lJywgLy8gRXhwb3N1cmUgdGltZSAoaW4gc2Vjb25kcylcbiAgICAgIDB4ODI5ZDogJ0ZOdW1iZXInLFxuICAgICAgMHg4ODIyOiAnRXhwb3N1cmVQcm9ncmFtJywgLy8gRXhwb3N1cmUgcHJvZ3JhbVxuICAgICAgMHg4ODI0OiAnU3BlY3RyYWxTZW5zaXRpdml0eScsIC8vIFNwZWN0cmFsIHNlbnNpdGl2aXR5XG4gICAgICAweDg4Mjc6ICdQaG90b2dyYXBoaWNTZW5zaXRpdml0eScsIC8vIEVYSUYgMi4zLCBJU09TcGVlZFJhdGluZ3MgaW4gRVhJRiAyLjJcbiAgICAgIDB4ODgyODogJ09FQ0YnLCAvLyBPcHRvZWxlY3RyaWMgY29udmVyc2lvbiBmYWN0b3JcbiAgICAgIDB4ODgzMDogJ1NlbnNpdGl2aXR5VHlwZScsXG4gICAgICAweDg4MzE6ICdTdGFuZGFyZE91dHB1dFNlbnNpdGl2aXR5JyxcbiAgICAgIDB4ODgzMjogJ1JlY29tbWVuZGVkRXhwb3N1cmVJbmRleCcsXG4gICAgICAweDg4MzM6ICdJU09TcGVlZCcsXG4gICAgICAweDg4MzQ6ICdJU09TcGVlZExhdGl0dWRleXl5JyxcbiAgICAgIDB4ODgzNTogJ0lTT1NwZWVkTGF0aXR1ZGV6enonLFxuICAgICAgMHg5MjAxOiAnU2h1dHRlclNwZWVkVmFsdWUnLCAvLyBTaHV0dGVyIHNwZWVkXG4gICAgICAweDkyMDI6ICdBcGVydHVyZVZhbHVlJywgLy8gTGVucyBhcGVydHVyZVxuICAgICAgMHg5MjAzOiAnQnJpZ2h0bmVzc1ZhbHVlJywgLy8gVmFsdWUgb2YgYnJpZ2h0bmVzc1xuICAgICAgMHg5MjA0OiAnRXhwb3N1cmVCaWFzJywgLy8gRXhwb3N1cmUgYmlhc1xuICAgICAgMHg5MjA1OiAnTWF4QXBlcnR1cmVWYWx1ZScsIC8vIFNtYWxsZXN0IEYgbnVtYmVyIG9mIGxlbnNcbiAgICAgIDB4OTIwNjogJ1N1YmplY3REaXN0YW5jZScsIC8vIERpc3RhbmNlIHRvIHN1YmplY3QgaW4gbWV0ZXJzXG4gICAgICAweDkyMDc6ICdNZXRlcmluZ01vZGUnLCAvLyBNZXRlcmluZyBtb2RlXG4gICAgICAweDkyMDg6ICdMaWdodFNvdXJjZScsIC8vIEtpbmQgb2YgbGlnaHQgc291cmNlXG4gICAgICAweDkyMDk6ICdGbGFzaCcsIC8vIEZsYXNoIHN0YXR1c1xuICAgICAgMHg5MjE0OiAnU3ViamVjdEFyZWEnLCAvLyBMb2NhdGlvbiBhbmQgYXJlYSBvZiBtYWluIHN1YmplY3RcbiAgICAgIDB4OTIwYTogJ0ZvY2FsTGVuZ3RoJywgLy8gRm9jYWwgbGVuZ3RoIG9mIHRoZSBsZW5zIGluIG1tXG4gICAgICAweGEyMGI6ICdGbGFzaEVuZXJneScsIC8vIFN0cm9iZSBlbmVyZ3kgaW4gQkNQU1xuICAgICAgMHhhMjBjOiAnU3BhdGlhbEZyZXF1ZW5jeVJlc3BvbnNlJyxcbiAgICAgIDB4YTIwZTogJ0ZvY2FsUGxhbmVYUmVzb2x1dGlvbicsIC8vIE51bWJlciBvZiBwaXhlbHMgaW4gd2lkdGggZGlyZWN0aW9uIHBlciBGUFJVbml0XG4gICAgICAweGEyMGY6ICdGb2NhbFBsYW5lWVJlc29sdXRpb24nLCAvLyBOdW1iZXIgb2YgcGl4ZWxzIGluIGhlaWdodCBkaXJlY3Rpb24gcGVyIEZQUlVuaXRcbiAgICAgIDB4YTIxMDogJ0ZvY2FsUGxhbmVSZXNvbHV0aW9uVW5pdCcsIC8vIFVuaXQgZm9yIG1lYXN1cmluZyB0aGUgZm9jYWwgcGxhbmUgcmVzb2x1dGlvblxuICAgICAgMHhhMjE0OiAnU3ViamVjdExvY2F0aW9uJywgLy8gTG9jYXRpb24gb2Ygc3ViamVjdCBpbiBpbWFnZVxuICAgICAgMHhhMjE1OiAnRXhwb3N1cmVJbmRleCcsIC8vIEV4cG9zdXJlIGluZGV4IHNlbGVjdGVkIG9uIGNhbWVyYVxuICAgICAgMHhhMjE3OiAnU2Vuc2luZ01ldGhvZCcsIC8vIEltYWdlIHNlbnNvciB0eXBlXG4gICAgICAweGEzMDA6ICdGaWxlU291cmNlJywgLy8gSW1hZ2Ugc291cmNlICgzID09IERTQylcbiAgICAgIDB4YTMwMTogJ1NjZW5lVHlwZScsIC8vIFNjZW5lIHR5cGUgKDEgPT0gZGlyZWN0bHkgcGhvdG9ncmFwaGVkKVxuICAgICAgMHhhMzAyOiAnQ0ZBUGF0dGVybicsIC8vIENvbG9yIGZpbHRlciBhcnJheSBnZW9tZXRyaWMgcGF0dGVyblxuICAgICAgMHhhNDAxOiAnQ3VzdG9tUmVuZGVyZWQnLCAvLyBTcGVjaWFsIHByb2Nlc3NpbmdcbiAgICAgIDB4YTQwMjogJ0V4cG9zdXJlTW9kZScsIC8vIEV4cG9zdXJlIG1vZGVcbiAgICAgIDB4YTQwMzogJ1doaXRlQmFsYW5jZScsIC8vIDEgPSBhdXRvIHdoaXRlIGJhbGFuY2UsIDIgPSBtYW51YWxcbiAgICAgIDB4YTQwNDogJ0RpZ2l0YWxab29tUmF0aW8nLCAvLyBEaWdpdGFsIHpvb20gcmF0aW9cbiAgICAgIDB4YTQwNTogJ0ZvY2FsTGVuZ3RoSW4zNW1tRmlsbScsXG4gICAgICAweGE0MDY6ICdTY2VuZUNhcHR1cmVUeXBlJywgLy8gVHlwZSBvZiBzY2VuZVxuICAgICAgMHhhNDA3OiAnR2FpbkNvbnRyb2wnLCAvLyBEZWdyZWUgb2Ygb3ZlcmFsbCBpbWFnZSBnYWluIGFkanVzdG1lbnRcbiAgICAgIDB4YTQwODogJ0NvbnRyYXN0JywgLy8gRGlyZWN0aW9uIG9mIGNvbnRyYXN0IHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgICAgIDB4YTQwOTogJ1NhdHVyYXRpb24nLCAvLyBEaXJlY3Rpb24gb2Ygc2F0dXJhdGlvbiBwcm9jZXNzaW5nIGFwcGxpZWQgYnkgY2FtZXJhXG4gICAgICAweGE0MGE6ICdTaGFycG5lc3MnLCAvLyBEaXJlY3Rpb24gb2Ygc2hhcnBuZXNzIHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgICAgIDB4YTQwYjogJ0RldmljZVNldHRpbmdEZXNjcmlwdGlvbicsXG4gICAgICAweGE0MGM6ICdTdWJqZWN0RGlzdGFuY2VSYW5nZScsIC8vIERpc3RhbmNlIHRvIHN1YmplY3RcbiAgICAgIDB4YTQyMDogJ0ltYWdlVW5pcXVlSUQnLCAvLyBJZGVudGlmaWVyIGFzc2lnbmVkIHVuaXF1ZWx5IHRvIGVhY2ggaW1hZ2VcbiAgICAgIDB4YTQzMDogJ0NhbWVyYU93bmVyTmFtZScsXG4gICAgICAweGE0MzE6ICdCb2R5U2VyaWFsTnVtYmVyJyxcbiAgICAgIDB4YTQzMjogJ0xlbnNTcGVjaWZpY2F0aW9uJyxcbiAgICAgIDB4YTQzMzogJ0xlbnNNYWtlJyxcbiAgICAgIDB4YTQzNDogJ0xlbnNNb2RlbCcsXG4gICAgICAweGE0MzU6ICdMZW5zU2VyaWFsTnVtYmVyJ1xuICAgIH0sXG4gICAgMHg4ODI1OiB7XG4gICAgICAvLyBHUFNJbmZvSUZEUG9pbnRlclxuICAgICAgMHgwMDAwOiAnR1BTVmVyc2lvbklEJyxcbiAgICAgIDB4MDAwMTogJ0dQU0xhdGl0dWRlUmVmJyxcbiAgICAgIDB4MDAwMjogJ0dQU0xhdGl0dWRlJyxcbiAgICAgIDB4MDAwMzogJ0dQU0xvbmdpdHVkZVJlZicsXG4gICAgICAweDAwMDQ6ICdHUFNMb25naXR1ZGUnLFxuICAgICAgMHgwMDA1OiAnR1BTQWx0aXR1ZGVSZWYnLFxuICAgICAgMHgwMDA2OiAnR1BTQWx0aXR1ZGUnLFxuICAgICAgMHgwMDA3OiAnR1BTVGltZVN0YW1wJyxcbiAgICAgIDB4MDAwODogJ0dQU1NhdGVsbGl0ZXMnLFxuICAgICAgMHgwMDA5OiAnR1BTU3RhdHVzJyxcbiAgICAgIDB4MDAwYTogJ0dQU01lYXN1cmVNb2RlJyxcbiAgICAgIDB4MDAwYjogJ0dQU0RPUCcsXG4gICAgICAweDAwMGM6ICdHUFNTcGVlZFJlZicsXG4gICAgICAweDAwMGQ6ICdHUFNTcGVlZCcsXG4gICAgICAweDAwMGU6ICdHUFNUcmFja1JlZicsXG4gICAgICAweDAwMGY6ICdHUFNUcmFjaycsXG4gICAgICAweDAwMTA6ICdHUFNJbWdEaXJlY3Rpb25SZWYnLFxuICAgICAgMHgwMDExOiAnR1BTSW1nRGlyZWN0aW9uJyxcbiAgICAgIDB4MDAxMjogJ0dQU01hcERhdHVtJyxcbiAgICAgIDB4MDAxMzogJ0dQU0Rlc3RMYXRpdHVkZVJlZicsXG4gICAgICAweDAwMTQ6ICdHUFNEZXN0TGF0aXR1ZGUnLFxuICAgICAgMHgwMDE1OiAnR1BTRGVzdExvbmdpdHVkZVJlZicsXG4gICAgICAweDAwMTY6ICdHUFNEZXN0TG9uZ2l0dWRlJyxcbiAgICAgIDB4MDAxNzogJ0dQU0Rlc3RCZWFyaW5nUmVmJyxcbiAgICAgIDB4MDAxODogJ0dQU0Rlc3RCZWFyaW5nJyxcbiAgICAgIDB4MDAxOTogJ0dQU0Rlc3REaXN0YW5jZVJlZicsXG4gICAgICAweDAwMWE6ICdHUFNEZXN0RGlzdGFuY2UnLFxuICAgICAgMHgwMDFiOiAnR1BTUHJvY2Vzc2luZ01ldGhvZCcsXG4gICAgICAweDAwMWM6ICdHUFNBcmVhSW5mb3JtYXRpb24nLFxuICAgICAgMHgwMDFkOiAnR1BTRGF0ZVN0YW1wJyxcbiAgICAgIDB4MDAxZTogJ0dQU0RpZmZlcmVudGlhbCcsXG4gICAgICAweDAwMWY6ICdHUFNIUG9zaXRpb25pbmdFcnJvcidcbiAgICB9LFxuICAgIDB4YTAwNToge1xuICAgICAgLy8gSW50ZXJvcGVyYWJpbGl0eUlGRFBvaW50ZXJcbiAgICAgIDB4MDAwMTogJ0ludGVyb3BlcmFiaWxpdHlJbmRleCdcbiAgICB9XG4gIH1cblxuICAvLyBJRkQxIGRpcmVjdG9yeSBjYW4gY29udGFpbiBhbnkgSUZEMCB0YWdzOlxuICBFeGlmTWFwUHJvdG8udGFncy5pZmQxID0gRXhpZk1hcFByb3RvLnRhZ3NcblxuICBFeGlmTWFwUHJvdG8uc3RyaW5nVmFsdWVzID0ge1xuICAgIEV4cG9zdXJlUHJvZ3JhbToge1xuICAgICAgMDogJ1VuZGVmaW5lZCcsXG4gICAgICAxOiAnTWFudWFsJyxcbiAgICAgIDI6ICdOb3JtYWwgcHJvZ3JhbScsXG4gICAgICAzOiAnQXBlcnR1cmUgcHJpb3JpdHknLFxuICAgICAgNDogJ1NodXR0ZXIgcHJpb3JpdHknLFxuICAgICAgNTogJ0NyZWF0aXZlIHByb2dyYW0nLFxuICAgICAgNjogJ0FjdGlvbiBwcm9ncmFtJyxcbiAgICAgIDc6ICdQb3J0cmFpdCBtb2RlJyxcbiAgICAgIDg6ICdMYW5kc2NhcGUgbW9kZSdcbiAgICB9LFxuICAgIE1ldGVyaW5nTW9kZToge1xuICAgICAgMDogJ1Vua25vd24nLFxuICAgICAgMTogJ0F2ZXJhZ2UnLFxuICAgICAgMjogJ0NlbnRlcldlaWdodGVkQXZlcmFnZScsXG4gICAgICAzOiAnU3BvdCcsXG4gICAgICA0OiAnTXVsdGlTcG90JyxcbiAgICAgIDU6ICdQYXR0ZXJuJyxcbiAgICAgIDY6ICdQYXJ0aWFsJyxcbiAgICAgIDI1NTogJ090aGVyJ1xuICAgIH0sXG4gICAgTGlnaHRTb3VyY2U6IHtcbiAgICAgIDA6ICdVbmtub3duJyxcbiAgICAgIDE6ICdEYXlsaWdodCcsXG4gICAgICAyOiAnRmx1b3Jlc2NlbnQnLFxuICAgICAgMzogJ1R1bmdzdGVuIChpbmNhbmRlc2NlbnQgbGlnaHQpJyxcbiAgICAgIDQ6ICdGbGFzaCcsXG4gICAgICA5OiAnRmluZSB3ZWF0aGVyJyxcbiAgICAgIDEwOiAnQ2xvdWR5IHdlYXRoZXInLFxuICAgICAgMTE6ICdTaGFkZScsXG4gICAgICAxMjogJ0RheWxpZ2h0IGZsdW9yZXNjZW50IChEIDU3MDAgLSA3MTAwSyknLFxuICAgICAgMTM6ICdEYXkgd2hpdGUgZmx1b3Jlc2NlbnQgKE4gNDYwMCAtIDU0MDBLKScsXG4gICAgICAxNDogJ0Nvb2wgd2hpdGUgZmx1b3Jlc2NlbnQgKFcgMzkwMCAtIDQ1MDBLKScsXG4gICAgICAxNTogJ1doaXRlIGZsdW9yZXNjZW50IChXVyAzMjAwIC0gMzcwMEspJyxcbiAgICAgIDE3OiAnU3RhbmRhcmQgbGlnaHQgQScsXG4gICAgICAxODogJ1N0YW5kYXJkIGxpZ2h0IEInLFxuICAgICAgMTk6ICdTdGFuZGFyZCBsaWdodCBDJyxcbiAgICAgIDIwOiAnRDU1JyxcbiAgICAgIDIxOiAnRDY1JyxcbiAgICAgIDIyOiAnRDc1JyxcbiAgICAgIDIzOiAnRDUwJyxcbiAgICAgIDI0OiAnSVNPIHN0dWRpbyB0dW5nc3RlbicsXG4gICAgICAyNTU6ICdPdGhlcidcbiAgICB9LFxuICAgIEZsYXNoOiB7XG4gICAgICAweDAwMDA6ICdGbGFzaCBkaWQgbm90IGZpcmUnLFxuICAgICAgMHgwMDAxOiAnRmxhc2ggZmlyZWQnLFxuICAgICAgMHgwMDA1OiAnU3Ryb2JlIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDA3OiAnU3Ryb2JlIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwMDk6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlJyxcbiAgICAgIDB4MDAwZDogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDBmOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDAxMDogJ0ZsYXNoIGRpZCBub3QgZmlyZSwgY29tcHVsc29yeSBmbGFzaCBtb2RlJyxcbiAgICAgIDB4MDAxODogJ0ZsYXNoIGRpZCBub3QgZmlyZSwgYXV0byBtb2RlJyxcbiAgICAgIDB4MDAxOTogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUnLFxuICAgICAgMHgwMDFkOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgICAweDAwMWY6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDIwOiAnTm8gZmxhc2ggZnVuY3Rpb24nLFxuICAgICAgMHgwMDQxOiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuICAgICAgMHgwMDQ1OiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDQ3OiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgICAweDAwNDk6ICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAgIDB4MDA0ZDogJ0ZsYXNoIGZpcmVkLCBjb21wdWxzb3J5IGZsYXNoIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgICAgMHgwMDRmOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAgIDB4MDA1OTogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnLFxuICAgICAgMHgwMDVkOiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgICAweDAwNWY6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnXG4gICAgfSxcbiAgICBTZW5zaW5nTWV0aG9kOiB7XG4gICAgICAxOiAnVW5kZWZpbmVkJyxcbiAgICAgIDI6ICdPbmUtY2hpcCBjb2xvciBhcmVhIHNlbnNvcicsXG4gICAgICAzOiAnVHdvLWNoaXAgY29sb3IgYXJlYSBzZW5zb3InLFxuICAgICAgNDogJ1RocmVlLWNoaXAgY29sb3IgYXJlYSBzZW5zb3InLFxuICAgICAgNTogJ0NvbG9yIHNlcXVlbnRpYWwgYXJlYSBzZW5zb3InLFxuICAgICAgNzogJ1RyaWxpbmVhciBzZW5zb3InLFxuICAgICAgODogJ0NvbG9yIHNlcXVlbnRpYWwgbGluZWFyIHNlbnNvcidcbiAgICB9LFxuICAgIFNjZW5lQ2FwdHVyZVR5cGU6IHtcbiAgICAgIDA6ICdTdGFuZGFyZCcsXG4gICAgICAxOiAnTGFuZHNjYXBlJyxcbiAgICAgIDI6ICdQb3J0cmFpdCcsXG4gICAgICAzOiAnTmlnaHQgc2NlbmUnXG4gICAgfSxcbiAgICBTY2VuZVR5cGU6IHtcbiAgICAgIDE6ICdEaXJlY3RseSBwaG90b2dyYXBoZWQnXG4gICAgfSxcbiAgICBDdXN0b21SZW5kZXJlZDoge1xuICAgICAgMDogJ05vcm1hbCBwcm9jZXNzJyxcbiAgICAgIDE6ICdDdXN0b20gcHJvY2VzcydcbiAgICB9LFxuICAgIFdoaXRlQmFsYW5jZToge1xuICAgICAgMDogJ0F1dG8gd2hpdGUgYmFsYW5jZScsXG4gICAgICAxOiAnTWFudWFsIHdoaXRlIGJhbGFuY2UnXG4gICAgfSxcbiAgICBHYWluQ29udHJvbDoge1xuICAgICAgMDogJ05vbmUnLFxuICAgICAgMTogJ0xvdyBnYWluIHVwJyxcbiAgICAgIDI6ICdIaWdoIGdhaW4gdXAnLFxuICAgICAgMzogJ0xvdyBnYWluIGRvd24nLFxuICAgICAgNDogJ0hpZ2ggZ2FpbiBkb3duJ1xuICAgIH0sXG4gICAgQ29udHJhc3Q6IHtcbiAgICAgIDA6ICdOb3JtYWwnLFxuICAgICAgMTogJ1NvZnQnLFxuICAgICAgMjogJ0hhcmQnXG4gICAgfSxcbiAgICBTYXR1cmF0aW9uOiB7XG4gICAgICAwOiAnTm9ybWFsJyxcbiAgICAgIDE6ICdMb3cgc2F0dXJhdGlvbicsXG4gICAgICAyOiAnSGlnaCBzYXR1cmF0aW9uJ1xuICAgIH0sXG4gICAgU2hhcnBuZXNzOiB7XG4gICAgICAwOiAnTm9ybWFsJyxcbiAgICAgIDE6ICdTb2Z0JyxcbiAgICAgIDI6ICdIYXJkJ1xuICAgIH0sXG4gICAgU3ViamVjdERpc3RhbmNlUmFuZ2U6IHtcbiAgICAgIDA6ICdVbmtub3duJyxcbiAgICAgIDE6ICdNYWNybycsXG4gICAgICAyOiAnQ2xvc2UgdmlldycsXG4gICAgICAzOiAnRGlzdGFudCB2aWV3J1xuICAgIH0sXG4gICAgRmlsZVNvdXJjZToge1xuICAgICAgMzogJ0RTQydcbiAgICB9LFxuICAgIENvbXBvbmVudHNDb25maWd1cmF0aW9uOiB7XG4gICAgICAwOiAnJyxcbiAgICAgIDE6ICdZJyxcbiAgICAgIDI6ICdDYicsXG4gICAgICAzOiAnQ3InLFxuICAgICAgNDogJ1InLFxuICAgICAgNTogJ0cnLFxuICAgICAgNjogJ0InXG4gICAgfSxcbiAgICBPcmllbnRhdGlvbjoge1xuICAgICAgMTogJ09yaWdpbmFsJyxcbiAgICAgIDI6ICdIb3Jpem9udGFsIGZsaXAnLFxuICAgICAgMzogJ1JvdGF0ZSAxODDCsCBDQ1cnLFxuICAgICAgNDogJ1ZlcnRpY2FsIGZsaXAnLFxuICAgICAgNTogJ1ZlcnRpY2FsIGZsaXAgKyBSb3RhdGUgOTDCsCBDVycsXG4gICAgICA2OiAnUm90YXRlIDkwwrAgQ1cnLFxuICAgICAgNzogJ0hvcml6b250YWwgZmxpcCArIFJvdGF0ZSA5MMKwIENXJyxcbiAgICAgIDg6ICdSb3RhdGUgOTDCsCBDQ1cnXG4gICAgfVxuICB9XG5cbiAgRXhpZk1hcFByb3RvLmdldFRleHQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KG5hbWUpXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdMaWdodFNvdXJjZSc6XG4gICAgICBjYXNlICdGbGFzaCc6XG4gICAgICBjYXNlICdNZXRlcmluZ01vZGUnOlxuICAgICAgY2FzZSAnRXhwb3N1cmVQcm9ncmFtJzpcbiAgICAgIGNhc2UgJ1NlbnNpbmdNZXRob2QnOlxuICAgICAgY2FzZSAnU2NlbmVDYXB0dXJlVHlwZSc6XG4gICAgICBjYXNlICdTY2VuZVR5cGUnOlxuICAgICAgY2FzZSAnQ3VzdG9tUmVuZGVyZWQnOlxuICAgICAgY2FzZSAnV2hpdGVCYWxhbmNlJzpcbiAgICAgIGNhc2UgJ0dhaW5Db250cm9sJzpcbiAgICAgIGNhc2UgJ0NvbnRyYXN0JzpcbiAgICAgIGNhc2UgJ1NhdHVyYXRpb24nOlxuICAgICAgY2FzZSAnU2hhcnBuZXNzJzpcbiAgICAgIGNhc2UgJ1N1YmplY3REaXN0YW5jZVJhbmdlJzpcbiAgICAgIGNhc2UgJ0ZpbGVTb3VyY2UnOlxuICAgICAgY2FzZSAnT3JpZW50YXRpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZXNbbmFtZV1bdmFsdWVdXG4gICAgICBjYXNlICdFeGlmVmVyc2lvbic6XG4gICAgICBjYXNlICdGbGFzaHBpeFZlcnNpb24nOlxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pXG4gICAgICBjYXNlICdDb21wb25lbnRzQ29uZmlndXJhdGlvbic6XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVyblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHRoaXMuc3RyaW5nVmFsdWVzW25hbWVdW3ZhbHVlWzBdXSArXG4gICAgICAgICAgdGhpcy5zdHJpbmdWYWx1ZXNbbmFtZV1bdmFsdWVbMV1dICtcbiAgICAgICAgICB0aGlzLnN0cmluZ1ZhbHVlc1tuYW1lXVt2YWx1ZVsyXV0gK1xuICAgICAgICAgIHRoaXMuc3RyaW5nVmFsdWVzW25hbWVdW3ZhbHVlWzNdXVxuICAgICAgICApXG4gICAgICBjYXNlICdHUFNWZXJzaW9uSUQnOlxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdICsgJy4nICsgdmFsdWVbMV0gKyAnLicgKyB2YWx1ZVsyXSArICcuJyArIHZhbHVlWzNdXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gIH1cblxuICBFeGlmTWFwUHJvdG8uZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXAgPSB7fVxuICAgIHZhciBwcm9wXG4gICAgdmFyIG9ialxuICAgIHZhciBuYW1lXG4gICAgZm9yIChwcm9wIGluIHRoaXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcHJvcCkpIHtcbiAgICAgICAgb2JqID0gdGhpc1twcm9wXVxuICAgICAgICBpZiAob2JqICYmIG9iai5nZXRBbGwpIHtcbiAgICAgICAgICBtYXBbdGhpcy5pZmRzW3Byb3BdLm5hbWVdID0gb2JqLmdldEFsbCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudGFnc1twcm9wXVxuICAgICAgICAgIGlmIChuYW1lKSBtYXBbbmFtZV0gPSB0aGlzLmdldFRleHQobmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICBFeGlmTWFwUHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uICh0YWdDb2RlKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRhZ3NbdGFnQ29kZV1cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSByZXR1cm4gdGhpcy5pZmRzW3RhZ0NvZGVdLm5hbWVcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gRXh0ZW5kIHRoZSBtYXAgb2YgdGFnIG5hbWVzIHRvIHRhZyBjb2RlczpcbiAgOyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRhZ3MgPSBFeGlmTWFwUHJvdG8udGFnc1xuICAgIHZhciBwcm9wXG4gICAgdmFyIGlmZFxuICAgIHZhciBzdWJUYWdzXG4gICAgLy8gTWFwIHRoZSB0YWcgbmFtZXMgdG8gdGFnczpcbiAgICBmb3IgKHByb3AgaW4gdGFncykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWdzLCBwcm9wKSkge1xuICAgICAgICBpZmQgPSBFeGlmTWFwUHJvdG8uaWZkc1twcm9wXVxuICAgICAgICBpZiAoaWZkKSB7XG4gICAgICAgICAgc3ViVGFncyA9IHRhZ3NbcHJvcF1cbiAgICAgICAgICBmb3IgKHByb3AgaW4gc3ViVGFncykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdWJUYWdzLCBwcm9wKSkge1xuICAgICAgICAgICAgICBpZmQubWFwW3N1YlRhZ3NbcHJvcF1dID0gTnVtYmVyKHByb3ApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEV4aWZNYXBQcm90by5tYXBbdGFnc1twcm9wXV0gPSBOdW1iZXIocHJvcClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSkoKVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-exif.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-exif.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n/* eslint-disable no-console */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * Exif tag map\n   *\n   * @name ExifMap\n   * @class\n   * @param {number|string} tagCode IFD tag code\n   */\n  function ExifMap(tagCode) {\n    if (tagCode) {\n      Object.defineProperty(this, 'map', {\n        value: this.ifds[tagCode].map\n      })\n      Object.defineProperty(this, 'tags', {\n        value: (this.tags && this.tags[tagCode]) || {}\n      })\n    }\n  }\n\n  ExifMap.prototype.map = {\n    Orientation: 0x0112,\n    Thumbnail: 'ifd1',\n    Blob: 0x0201, // Alias for JPEGInterchangeFormat\n    Exif: 0x8769,\n    GPSInfo: 0x8825,\n    Interoperability: 0xa005\n  }\n\n  ExifMap.prototype.ifds = {\n    ifd1: { name: 'Thumbnail', map: ExifMap.prototype.map },\n    0x8769: { name: 'Exif', map: {} },\n    0x8825: { name: 'GPSInfo', map: {} },\n    0xa005: { name: 'Interoperability', map: {} }\n  }\n\n  /**\n   * Retrieves exif tag value\n   *\n   * @param {number|string} id Exif tag code or name\n   * @returns {object} Exif tag value\n   */\n  ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Returns the Exif Thumbnail data as Blob.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Thumbnail data offset\n   * @param {number} length Thumbnail data length\n   * @returns {undefined|Blob} Returns the Thumbnail Blob or undefined\n   */\n  function getExifThumbnail(dataView, offset, length) {\n    if (!length) return\n    if (offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.')\n      return\n    }\n    return new Blob(\n      [loadImage.bufferSlice.call(dataView.buffer, offset, offset + length)],\n      {\n        type: 'image/jpeg'\n      }\n    )\n  }\n\n  var ExifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function (dataView, dataOffset) {\n        return dataView.getUint8(dataOffset)\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function (dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset))\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian)\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getUint32(dataOffset, littleEndian) /\n          dataView.getUint32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getInt32(dataOffset, littleEndian) /\n          dataView.getInt32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    }\n  }\n  // undefined, 8-bit byte, value depending on field:\n  ExifTagTypes[7] = ExifTagTypes[1]\n\n  /**\n   * Returns Exif tag value.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} offset Tag offset\n   * @param {number} type Tag type\n   * @param {number} length Tag length\n   * @param {boolean} littleEndian Little endian encoding\n   * @returns {object} Tag value\n   */\n  function getExifValue(\n    dataView,\n    tiffOffset,\n    offset,\n    type,\n    length,\n    littleEndian\n  ) {\n    var tagType = ExifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.')\n      return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset =\n      tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : offset + 8\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.')\n      return\n    }\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(\n        dataView,\n        dataOffset + i * tagType.size,\n        littleEndian\n      )\n    }\n    if (tagType.ascii) {\n      str = ''\n      // Concatenate the chars:\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]\n        // Ignore the terminating NULL byte(s):\n        if (c === '\\u0000') {\n          break\n        }\n        str += c\n      }\n      return str\n    }\n    return values\n  }\n\n  /**\n   * Determines if the given tag should be included.\n   *\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @param {number|string} tagCode Tag code to check\n   * @returns {boolean} True if the tag should be included\n   */\n  function shouldIncludeTag(includeTags, excludeTags, tagCode) {\n    return (\n      (!includeTags || includeTags[tagCode]) &&\n      (!excludeTags || excludeTags[tagCode] !== true)\n    )\n  }\n\n  /**\n   * Parses Exif tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} dirOffset Directory offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {ExifMap} tags Map to store parsed exif tags\n   * @param {ExifMap} tagOffsets Map to store parsed exif tag offsets\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @returns {number} Next directory offset\n   */\n  function parseExifTags(\n    dataView,\n    tiffOffset,\n    dirOffset,\n    littleEndian,\n    tags,\n    tagOffsets,\n    includeTags,\n    excludeTags\n  ) {\n    var tagsNumber, dirEndOffset, i, tagOffset, tagNumber, tagValue\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.')\n      return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.')\n      return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n      tagOffset = dirOffset + 2 + 12 * i\n      tagNumber = dataView.getUint16(tagOffset, littleEndian)\n      if (!shouldIncludeTag(includeTags, excludeTags, tagNumber)) continue\n      tagValue = getExifValue(\n        dataView,\n        tiffOffset,\n        tagOffset,\n        dataView.getUint16(tagOffset + 2, littleEndian), // tag type\n        dataView.getUint32(tagOffset + 4, littleEndian), // tag length\n        littleEndian\n      )\n      tags[tagNumber] = tagValue\n      if (tagOffsets) {\n        tagOffsets[tagNumber] = tagOffset\n      }\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n  }\n\n  /**\n   * Parses tags in a given IFD (Image File Directory).\n   *\n   * @param {object} data Data object to store exif tags and offsets\n   * @param {number|string} tagCode IFD tag code\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseExifIFD(\n    data,\n    tagCode,\n    dataView,\n    tiffOffset,\n    littleEndian,\n    includeTags,\n    excludeTags\n  ) {\n    var dirOffset = data.exif[tagCode]\n    if (dirOffset) {\n      data.exif[tagCode] = new ExifMap(tagCode)\n      if (data.exifOffsets) {\n        data.exifOffsets[tagCode] = new ExifMap(tagCode)\n      }\n      parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        data.exif[tagCode],\n        data.exifOffsets && data.exifOffsets[tagCode],\n        includeTags && includeTags[tagCode],\n        excludeTags && excludeTags[tagCode]\n      )\n    }\n  }\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return\n    }\n    var includeTags = options.includeExifTags\n    var excludeTags = options.excludeExifTags || {\n      0x8769: {\n        // ExifIFDPointer\n        0x927c: true // MakerNote\n      }\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailIFD\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.')\n      return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.')\n      return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true\n        break\n      case 0x4d4d:\n        littleEndian = false\n        break\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\n        return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.')\n      return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new ExifMap()\n    if (!options.disableExifOffsets) {\n      data.exifOffsets = new ExifMap()\n      data.exifTiffOffset = tiffOffset\n      data.exifLittleEndian = littleEndian\n    }\n    // Parse the tags of the main image directory (IFD0) and retrieve the\n    // offset to the next directory (IFD1), usually the thumbnail directory:\n    dirOffset = parseExifTags(\n      dataView,\n      tiffOffset,\n      tiffOffset + dirOffset,\n      littleEndian,\n      data.exif,\n      data.exifOffsets,\n      includeTags,\n      excludeTags\n    )\n    if (dirOffset && shouldIncludeTag(includeTags, excludeTags, 'ifd1')) {\n      data.exif.ifd1 = dirOffset\n      if (data.exifOffsets) {\n        data.exifOffsets.ifd1 = tiffOffset + dirOffset\n      }\n    }\n    Object.keys(data.exif.ifds).forEach(function (tagCode) {\n      parseExifIFD(\n        data,\n        tagCode,\n        dataView,\n        tiffOffset,\n        littleEndian,\n        includeTags,\n        excludeTags\n      )\n    })\n    thumbnailIFD = data.exif.ifd1\n    // Check for JPEG Thumbnail offset and data length:\n    if (thumbnailIFD && thumbnailIFD[0x0201]) {\n      thumbnailIFD[0x0201] = getExifThumbnail(\n        dataView,\n        tiffOffset + thumbnailIFD[0x0201],\n        thumbnailIFD[0x0202] // Thumbnail data length\n      )\n    }\n  }\n\n  // Registers the Exif parser for the APP1 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\n  loadImage.exifWriters = {\n    // Orientation writer:\n    0x0112: function (buffer, data, value) {\n      var orientationOffset = data.exifOffsets[0x0112]\n      if (!orientationOffset) return buffer\n      var view = new DataView(buffer, orientationOffset + 8, 2)\n      view.setUint16(0, value, data.exifLittleEndian)\n      return buffer\n    }\n  }\n\n  loadImage.writeExifData = function (buffer, data, id, value) {\n    loadImage.exifWriters[data.exif.map[id]](buffer, data, value)\n  }\n\n  loadImage.ExifMap = ExifMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - exif: The parsed Exif tags\n  // - exifOffsets: The parsed Exif tag offsets\n  // - exifTiffOffset: TIFF header offset (used for offset pointers)\n  // - exifLittleEndian: little endian order if true, big endian if false\n\n  // Adds the following options to the parseMetaData method:\n  // - disableExif: Disables Exif parsing when true.\n  // - disableExifOffsets: Disables storing Exif tag offsets when true.\n  // - includeExifTags: A map of Exif tags to include for parsing.\n  // - excludeExifTags: A map of Exif tags to exclude from parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZXhpZi5qcz83N2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFELEdBQUcsTUFBTSxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0RBQWdEO0FBQzNELGFBQWEsc0JBQXNCLEVBQUU7QUFDckMsYUFBYSx5QkFBeUIsRUFBRTtBQUN4QyxhQUFhLGtDQUFrQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsY0FBYztBQUMzQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLWV4aWYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIEV4aWYgUGFyc2VyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlLCBEYXRhVmlldyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1tZXRhJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24gKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICAvKipcbiAgICogRXhpZiB0YWcgbWFwXG4gICAqXG4gICAqIEBuYW1lIEV4aWZNYXBcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdGFnQ29kZSBJRkQgdGFnIGNvZGVcbiAgICovXG4gIGZ1bmN0aW9uIEV4aWZNYXAodGFnQ29kZSkge1xuICAgIGlmICh0YWdDb2RlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21hcCcsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuaWZkc1t0YWdDb2RlXS5tYXBcbiAgICAgIH0pXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZ3MnLCB7XG4gICAgICAgIHZhbHVlOiAodGhpcy50YWdzICYmIHRoaXMudGFnc1t0YWdDb2RlXSkgfHwge31cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgRXhpZk1hcC5wcm90b3R5cGUubWFwID0ge1xuICAgIE9yaWVudGF0aW9uOiAweDAxMTIsXG4gICAgVGh1bWJuYWlsOiAnaWZkMScsXG4gICAgQmxvYjogMHgwMjAxLCAvLyBBbGlhcyBmb3IgSlBFR0ludGVyY2hhbmdlRm9ybWF0XG4gICAgRXhpZjogMHg4NzY5LFxuICAgIEdQU0luZm86IDB4ODgyNSxcbiAgICBJbnRlcm9wZXJhYmlsaXR5OiAweGEwMDVcbiAgfVxuXG4gIEV4aWZNYXAucHJvdG90eXBlLmlmZHMgPSB7XG4gICAgaWZkMTogeyBuYW1lOiAnVGh1bWJuYWlsJywgbWFwOiBFeGlmTWFwLnByb3RvdHlwZS5tYXAgfSxcbiAgICAweDg3Njk6IHsgbmFtZTogJ0V4aWYnLCBtYXA6IHt9IH0sXG4gICAgMHg4ODI1OiB7IG5hbWU6ICdHUFNJbmZvJywgbWFwOiB7fSB9LFxuICAgIDB4YTAwNTogeyBuYW1lOiAnSW50ZXJvcGVyYWJpbGl0eScsIG1hcDoge30gfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBleGlmIHRhZyB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkIEV4aWYgdGFnIGNvZGUgb3IgbmFtZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBFeGlmIHRhZyB2YWx1ZVxuICAgKi9cbiAgRXhpZk1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8IHRoaXNbdGhpcy5tYXBbaWRdXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEV4aWYgVGh1bWJuYWlsIGRhdGEgYXMgQmxvYi5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRodW1ibmFpbCBkYXRhIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRodW1ibmFpbCBkYXRhIGxlbmd0aFxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEJsb2J9IFJldHVybnMgdGhlIFRodW1ibmFpbCBCbG9iIG9yIHVuZGVmaW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RXhpZlRodW1ibmFpbChkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIWxlbmd0aCkgcmV0dXJuXG4gICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCB0aHVtYm5haWwgZGF0YS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYihcbiAgICAgIFtsb2FkSW1hZ2UuYnVmZmVyU2xpY2UuY2FsbChkYXRhVmlldy5idWZmZXIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKV0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdpbWFnZS9qcGVnJ1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHZhciBFeGlmVGFnVHlwZXMgPSB7XG4gICAgLy8gYnl0ZSwgOC1iaXQgdW5zaWduZWQgaW50OlxuICAgIDE6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KGRhdGFPZmZzZXQpXG4gICAgICB9LFxuICAgICAgc2l6ZTogMVxuICAgIH0sXG4gICAgLy8gYXNjaWksIDgtYml0IGJ5dGU6XG4gICAgMjoge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChkYXRhT2Zmc2V0KSlcbiAgICAgIH0sXG4gICAgICBzaXplOiAxLFxuICAgICAgYXNjaWk6IHRydWVcbiAgICB9LFxuICAgIC8vIHNob3J0LCAxNiBiaXQgaW50OlxuICAgIDM6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIH0sXG4gICAgICBzaXplOiAyXG4gICAgfSxcbiAgICAvLyBsb25nLCAzMiBiaXQgaW50OlxuICAgIDQ6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICAgIH0sXG4gICAgICBzaXplOiA0XG4gICAgfSxcbiAgICAvLyByYXRpb25hbCA9IHR3byBsb25nIHZhbHVlcywgZmlyc3QgaXMgbnVtZXJhdG9yLCBzZWNvbmQgaXMgZGVub21pbmF0b3I6XG4gICAgNToge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChkYXRhVmlldywgZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGF0YVZpZXcuZ2V0VWludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikgL1xuICAgICAgICAgIGRhdGFWaWV3LmdldFVpbnQzMihkYXRhT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2l6ZTogOFxuICAgIH0sXG4gICAgLy8gc2xvbmcsIDMyIGJpdCBzaWduZWQgaW50OlxuICAgIDk6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MzIoZGF0YU9mZnNldCwgbGl0dGxlRW5kaWFuKVxuICAgICAgfSxcbiAgICAgIHNpemU6IDRcbiAgICB9LFxuICAgIC8vIHNyYXRpb25hbCwgdHdvIHNsb25ncywgZmlyc3QgaXMgbnVtZXJhdG9yLCBzZWNvbmQgaXMgZGVub21pbmF0b3I6XG4gICAgMTA6IHtcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbikgL1xuICAgICAgICAgIGRhdGFWaWV3LmdldEludDMyKGRhdGFPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBzaXplOiA4XG4gICAgfVxuICB9XG4gIC8vIHVuZGVmaW5lZCwgOC1iaXQgYnl0ZSwgdmFsdWUgZGVwZW5kaW5nIG9uIGZpZWxkOlxuICBFeGlmVGFnVHlwZXNbN10gPSBFeGlmVGFnVHlwZXNbMV1cblxuICAvKipcbiAgICogUmV0dXJucyBFeGlmIHRhZyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlmZk9mZnNldCBUSUZGIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRhZyBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGFnIHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUYWcgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIExpdHRsZSBlbmRpYW4gZW5jb2RpbmdcbiAgICogQHJldHVybnMge29iamVjdH0gVGFnIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFeGlmVmFsdWUoXG4gICAgZGF0YVZpZXcsXG4gICAgdGlmZk9mZnNldCxcbiAgICBvZmZzZXQsXG4gICAgdHlwZSxcbiAgICBsZW5ndGgsXG4gICAgbGl0dGxlRW5kaWFuXG4gICkge1xuICAgIHZhciB0YWdUeXBlID0gRXhpZlRhZ1R5cGVzW3R5cGVdXG4gICAgdmFyIHRhZ1NpemVcbiAgICB2YXIgZGF0YU9mZnNldFxuICAgIHZhciB2YWx1ZXNcbiAgICB2YXIgaVxuICAgIHZhciBzdHJcbiAgICB2YXIgY1xuICAgIGlmICghdGFnVHlwZSkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIHRhZyB0eXBlLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGFnU2l6ZSA9IHRhZ1R5cGUuc2l6ZSAqIGxlbmd0aFxuICAgIC8vIERldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgY29udGFpbmVkIGluIHRoZSBkYXRhT2Zmc2V0IGJ5dGVzLFxuICAgIC8vIG9yIGlmIHRoZSB2YWx1ZSBhdCB0aGUgZGF0YU9mZnNldCBpcyBhIHBvaW50ZXIgdG8gdGhlIGFjdHVhbCBkYXRhOlxuICAgIGRhdGFPZmZzZXQgPVxuICAgICAgdGFnU2l6ZSA+IDRcbiAgICAgICAgPyB0aWZmT2Zmc2V0ICsgZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCArIDgsIGxpdHRsZUVuZGlhbilcbiAgICAgICAgOiBvZmZzZXQgKyA4XG4gICAgaWYgKGRhdGFPZmZzZXQgKyB0YWdTaXplID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBJbnZhbGlkIGRhdGEgb2Zmc2V0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRhZ1R5cGUuZ2V0VmFsdWUoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICB9XG4gICAgdmFsdWVzID0gW11cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHRhZ1R5cGUuZ2V0VmFsdWUoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICBkYXRhT2Zmc2V0ICsgaSAqIHRhZ1R5cGUuc2l6ZSxcbiAgICAgICAgbGl0dGxlRW5kaWFuXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0YWdUeXBlLmFzY2lpKSB7XG4gICAgICBzdHIgPSAnJ1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIGNoYXJzOlxuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gdmFsdWVzW2ldXG4gICAgICAgIC8vIElnbm9yZSB0aGUgdGVybWluYXRpbmcgTlVMTCBieXRlKHMpOlxuICAgICAgICBpZiAoYyA9PT0gJ1xcdTAwMDAnKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gY1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGFnIHNob3VsZCBiZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluY2x1ZGVUYWdzIE1hcCBvZiB0YWdzIHRvIGluY2x1ZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGV4Y2x1ZGVUYWdzIE1hcCBvZiB0YWdzIHRvIGV4Y2x1ZGVcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB0YWdDb2RlIFRhZyBjb2RlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YWcgc2hvdWxkIGJlIGluY2x1ZGVkXG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGRJbmNsdWRlVGFnKGluY2x1ZGVUYWdzLCBleGNsdWRlVGFncywgdGFnQ29kZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoIWluY2x1ZGVUYWdzIHx8IGluY2x1ZGVUYWdzW3RhZ0NvZGVdKSAmJlxuICAgICAgKCFleGNsdWRlVGFncyB8fCBleGNsdWRlVGFnc1t0YWdDb2RlXSAhPT0gdHJ1ZSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIEV4aWYgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlmZk9mZnNldCBUSUZGIG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGlyT2Zmc2V0IERpcmVjdG9yeSBvZmZzZXRcbiAgICogQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW4gTGl0dGxlIGVuZGlhbiBlbmNvZGluZ1xuICAgKiBAcGFyYW0ge0V4aWZNYXB9IHRhZ3MgTWFwIHRvIHN0b3JlIHBhcnNlZCBleGlmIHRhZ3NcbiAgICogQHBhcmFtIHtFeGlmTWFwfSB0YWdPZmZzZXRzIE1hcCB0byBzdG9yZSBwYXJzZWQgZXhpZiB0YWcgb2Zmc2V0c1xuICAgKiBAcGFyYW0ge29iamVjdH0gaW5jbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gaW5jbHVkZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZXhjbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gZXhjbHVkZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOZXh0IGRpcmVjdG9yeSBvZmZzZXRcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlRXhpZlRhZ3MoXG4gICAgZGF0YVZpZXcsXG4gICAgdGlmZk9mZnNldCxcbiAgICBkaXJPZmZzZXQsXG4gICAgbGl0dGxlRW5kaWFuLFxuICAgIHRhZ3MsXG4gICAgdGFnT2Zmc2V0cyxcbiAgICBpbmNsdWRlVGFncyxcbiAgICBleGNsdWRlVGFnc1xuICApIHtcbiAgICB2YXIgdGFnc051bWJlciwgZGlyRW5kT2Zmc2V0LCBpLCB0YWdPZmZzZXQsIHRhZ051bWJlciwgdGFnVmFsdWVcbiAgICBpZiAoZGlyT2Zmc2V0ICsgNiA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBkaXJlY3Rvcnkgb2Zmc2V0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGFnc051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNihkaXJPZmZzZXQsIGxpdHRsZUVuZGlhbilcbiAgICBkaXJFbmRPZmZzZXQgPSBkaXJPZmZzZXQgKyAyICsgMTIgKiB0YWdzTnVtYmVyXG4gICAgaWYgKGRpckVuZE9mZnNldCArIDQgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgZGlyZWN0b3J5IHNpemUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFnc051bWJlcjsgaSArPSAxKSB7XG4gICAgICB0YWdPZmZzZXQgPSBkaXJPZmZzZXQgKyAyICsgMTIgKiBpXG4gICAgICB0YWdOdW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MTYodGFnT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gICAgICBpZiAoIXNob3VsZEluY2x1ZGVUYWcoaW5jbHVkZVRhZ3MsIGV4Y2x1ZGVUYWdzLCB0YWdOdW1iZXIpKSBjb250aW51ZVxuICAgICAgdGFnVmFsdWUgPSBnZXRFeGlmVmFsdWUoXG4gICAgICAgIGRhdGFWaWV3LFxuICAgICAgICB0aWZmT2Zmc2V0LFxuICAgICAgICB0YWdPZmZzZXQsXG4gICAgICAgIGRhdGFWaWV3LmdldFVpbnQxNih0YWdPZmZzZXQgKyAyLCBsaXR0bGVFbmRpYW4pLCAvLyB0YWcgdHlwZVxuICAgICAgICBkYXRhVmlldy5nZXRVaW50MzIodGFnT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKSwgLy8gdGFnIGxlbmd0aFxuICAgICAgICBsaXR0bGVFbmRpYW5cbiAgICAgIClcbiAgICAgIHRhZ3NbdGFnTnVtYmVyXSA9IHRhZ1ZhbHVlXG4gICAgICBpZiAodGFnT2Zmc2V0cykge1xuICAgICAgICB0YWdPZmZzZXRzW3RhZ051bWJlcl0gPSB0YWdPZmZzZXRcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBvZmZzZXQgdG8gdGhlIG5leHQgZGlyZWN0b3J5OlxuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIoZGlyRW5kT2Zmc2V0LCBsaXR0bGVFbmRpYW4pXG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRhZ3MgaW4gYSBnaXZlbiBJRkQgKEltYWdlIEZpbGUgRGlyZWN0b3J5KS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3QgdG8gc3RvcmUgZXhpZiB0YWdzIGFuZCBvZmZzZXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdGFnQ29kZSBJRkQgdGFnIGNvZGVcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlmZk9mZnNldCBUSUZGIG9mZnNldFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBMaXR0bGUgZW5kaWFuIGVuY29kaW5nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBpbmNsdWRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBleGNsdWRlVGFncyBNYXAgb2YgdGFncyB0byBleGNsdWRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUV4aWZJRkQoXG4gICAgZGF0YSxcbiAgICB0YWdDb2RlLFxuICAgIGRhdGFWaWV3LFxuICAgIHRpZmZPZmZzZXQsXG4gICAgbGl0dGxlRW5kaWFuLFxuICAgIGluY2x1ZGVUYWdzLFxuICAgIGV4Y2x1ZGVUYWdzXG4gICkge1xuICAgIHZhciBkaXJPZmZzZXQgPSBkYXRhLmV4aWZbdGFnQ29kZV1cbiAgICBpZiAoZGlyT2Zmc2V0KSB7XG4gICAgICBkYXRhLmV4aWZbdGFnQ29kZV0gPSBuZXcgRXhpZk1hcCh0YWdDb2RlKVxuICAgICAgaWYgKGRhdGEuZXhpZk9mZnNldHMpIHtcbiAgICAgICAgZGF0YS5leGlmT2Zmc2V0c1t0YWdDb2RlXSA9IG5ldyBFeGlmTWFwKHRhZ0NvZGUpXG4gICAgICB9XG4gICAgICBwYXJzZUV4aWZUYWdzKFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCxcbiAgICAgICAgdGlmZk9mZnNldCArIGRpck9mZnNldCxcbiAgICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgICBkYXRhLmV4aWZbdGFnQ29kZV0sXG4gICAgICAgIGRhdGEuZXhpZk9mZnNldHMgJiYgZGF0YS5leGlmT2Zmc2V0c1t0YWdDb2RlXSxcbiAgICAgICAgaW5jbHVkZVRhZ3MgJiYgaW5jbHVkZVRhZ3NbdGFnQ29kZV0sXG4gICAgICAgIGV4Y2x1ZGVUYWdzICYmIGV4Y2x1ZGVUYWdzW3RhZ0NvZGVdXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlRXhpZkRhdGEgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZUV4aWYpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaW5jbHVkZVRhZ3MgPSBvcHRpb25zLmluY2x1ZGVFeGlmVGFnc1xuICAgIHZhciBleGNsdWRlVGFncyA9IG9wdGlvbnMuZXhjbHVkZUV4aWZUYWdzIHx8IHtcbiAgICAgIDB4ODc2OToge1xuICAgICAgICAvLyBFeGlmSUZEUG9pbnRlclxuICAgICAgICAweDkyN2M6IHRydWUgLy8gTWFrZXJOb3RlXG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0aWZmT2Zmc2V0ID0gb2Zmc2V0ICsgMTBcbiAgICB2YXIgbGl0dGxlRW5kaWFuXG4gICAgdmFyIGRpck9mZnNldFxuICAgIHZhciB0aHVtYm5haWxJRkRcbiAgICAvLyBDaGVjayBmb3IgdGhlIEFTQ0lJIGNvZGUgZm9yIFwiRXhpZlwiICgweDQ1Nzg2OTY2KTpcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpICE9PSAweDQ1Nzg2OTY2KSB7XG4gICAgICAvLyBObyBFeGlmIGRhdGEsIG1pZ2h0IGJlIFhNUCBkYXRhIGluc3RlYWRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGlmZk9mZnNldCArIDggPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBFeGlmIGRhdGE6IEludmFsaWQgc2VnbWVudCBzaXplLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHRoZSB0d28gbnVsbCBieXRlczpcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDgpICE9PSAweDAwMDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogTWlzc2luZyBieXRlIGFsaWdubWVudCBvZmZzZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgYnl0ZSBhbGlnbm1lbnQ6XG4gICAgc3dpdGNoIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkpIHtcbiAgICAgIGNhc2UgMHg0OTQ5OlxuICAgICAgICBsaXR0bGVFbmRpYW4gPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDB4NGQ0ZDpcbiAgICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2VcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEV4aWYgZGF0YTogSW52YWxpZCBieXRlIGFsaWdubWVudCBtYXJrZXIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIENoZWNrIGZvciB0aGUgVElGRiB0YWcgbWFya2VyICgweDAwMkEpOlxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsIGxpdHRsZUVuZGlhbikgIT09IDB4MDAyYSkge1xuICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgRXhpZiBkYXRhOiBNaXNzaW5nIFRJRkYgbWFya2VyLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gUmV0cmlldmUgdGhlIGRpcmVjdG9yeSBvZmZzZXQgYnl0ZXMsIHVzdWFsbHkgMHgwMDAwMDAwOCBvciA4IGRlY2ltYWw6XG4gICAgZGlyT2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pXG4gICAgLy8gQ3JlYXRlIHRoZSBleGlmIG9iamVjdCB0byBzdG9yZSB0aGUgdGFnczpcbiAgICBkYXRhLmV4aWYgPSBuZXcgRXhpZk1hcCgpXG4gICAgaWYgKCFvcHRpb25zLmRpc2FibGVFeGlmT2Zmc2V0cykge1xuICAgICAgZGF0YS5leGlmT2Zmc2V0cyA9IG5ldyBFeGlmTWFwKClcbiAgICAgIGRhdGEuZXhpZlRpZmZPZmZzZXQgPSB0aWZmT2Zmc2V0XG4gICAgICBkYXRhLmV4aWZMaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW5cbiAgICB9XG4gICAgLy8gUGFyc2UgdGhlIHRhZ3Mgb2YgdGhlIG1haW4gaW1hZ2UgZGlyZWN0b3J5IChJRkQwKSBhbmQgcmV0cmlldmUgdGhlXG4gICAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IGRpcmVjdG9yeSAoSUZEMSksIHVzdWFsbHkgdGhlIHRodW1ibmFpbCBkaXJlY3Rvcnk6XG4gICAgZGlyT2Zmc2V0ID0gcGFyc2VFeGlmVGFncyhcbiAgICAgIGRhdGFWaWV3LFxuICAgICAgdGlmZk9mZnNldCxcbiAgICAgIHRpZmZPZmZzZXQgKyBkaXJPZmZzZXQsXG4gICAgICBsaXR0bGVFbmRpYW4sXG4gICAgICBkYXRhLmV4aWYsXG4gICAgICBkYXRhLmV4aWZPZmZzZXRzLFxuICAgICAgaW5jbHVkZVRhZ3MsXG4gICAgICBleGNsdWRlVGFnc1xuICAgIClcbiAgICBpZiAoZGlyT2Zmc2V0ICYmIHNob3VsZEluY2x1ZGVUYWcoaW5jbHVkZVRhZ3MsIGV4Y2x1ZGVUYWdzLCAnaWZkMScpKSB7XG4gICAgICBkYXRhLmV4aWYuaWZkMSA9IGRpck9mZnNldFxuICAgICAgaWYgKGRhdGEuZXhpZk9mZnNldHMpIHtcbiAgICAgICAgZGF0YS5leGlmT2Zmc2V0cy5pZmQxID0gdGlmZk9mZnNldCArIGRpck9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3Qua2V5cyhkYXRhLmV4aWYuaWZkcykuZm9yRWFjaChmdW5jdGlvbiAodGFnQ29kZSkge1xuICAgICAgcGFyc2VFeGlmSUZEKFxuICAgICAgICBkYXRhLFxuICAgICAgICB0YWdDb2RlLFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCxcbiAgICAgICAgbGl0dGxlRW5kaWFuLFxuICAgICAgICBpbmNsdWRlVGFncyxcbiAgICAgICAgZXhjbHVkZVRhZ3NcbiAgICAgIClcbiAgICB9KVxuICAgIHRodW1ibmFpbElGRCA9IGRhdGEuZXhpZi5pZmQxXG4gICAgLy8gQ2hlY2sgZm9yIEpQRUcgVGh1bWJuYWlsIG9mZnNldCBhbmQgZGF0YSBsZW5ndGg6XG4gICAgaWYgKHRodW1ibmFpbElGRCAmJiB0aHVtYm5haWxJRkRbMHgwMjAxXSkge1xuICAgICAgdGh1bWJuYWlsSUZEWzB4MDIwMV0gPSBnZXRFeGlmVGh1bWJuYWlsKFxuICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgdGlmZk9mZnNldCArIHRodW1ibmFpbElGRFsweDAyMDFdLFxuICAgICAgICB0aHVtYm5haWxJRkRbMHgwMjAyXSAvLyBUaHVtYm5haWwgZGF0YSBsZW5ndGhcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlcnMgdGhlIEV4aWYgcGFyc2VyIGZvciB0aGUgQVBQMSBKUEVHIG1ldGFkYXRhIHNlZ21lbnQ6XG4gIGxvYWRJbWFnZS5tZXRhRGF0YVBhcnNlcnMuanBlZ1sweGZmZTFdLnB1c2gobG9hZEltYWdlLnBhcnNlRXhpZkRhdGEpXG5cbiAgbG9hZEltYWdlLmV4aWZXcml0ZXJzID0ge1xuICAgIC8vIE9yaWVudGF0aW9uIHdyaXRlcjpcbiAgICAweDAxMTI6IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEsIHZhbHVlKSB7XG4gICAgICB2YXIgb3JpZW50YXRpb25PZmZzZXQgPSBkYXRhLmV4aWZPZmZzZXRzWzB4MDExMl1cbiAgICAgIGlmICghb3JpZW50YXRpb25PZmZzZXQpIHJldHVybiBidWZmZXJcbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgb3JpZW50YXRpb25PZmZzZXQgKyA4LCAyKVxuICAgICAgdmlldy5zZXRVaW50MTYoMCwgdmFsdWUsIGRhdGEuZXhpZkxpdHRsZUVuZGlhbilcbiAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2Uud3JpdGVFeGlmRGF0YSA9IGZ1bmN0aW9uIChidWZmZXIsIGRhdGEsIGlkLCB2YWx1ZSkge1xuICAgIGxvYWRJbWFnZS5leGlmV3JpdGVyc1tkYXRhLmV4aWYubWFwW2lkXV0oYnVmZmVyLCBkYXRhLCB2YWx1ZSlcbiAgfVxuXG4gIGxvYWRJbWFnZS5FeGlmTWFwID0gRXhpZk1hcFxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIHRoZSBwYXJzZU1ldGFEYXRhIGNhbGxiYWNrIGRhdGE6XG4gIC8vIC0gZXhpZjogVGhlIHBhcnNlZCBFeGlmIHRhZ3NcbiAgLy8gLSBleGlmT2Zmc2V0czogVGhlIHBhcnNlZCBFeGlmIHRhZyBvZmZzZXRzXG4gIC8vIC0gZXhpZlRpZmZPZmZzZXQ6IFRJRkYgaGVhZGVyIG9mZnNldCAodXNlZCBmb3Igb2Zmc2V0IHBvaW50ZXJzKVxuICAvLyAtIGV4aWZMaXR0bGVFbmRpYW46IGxpdHRsZSBlbmRpYW4gb3JkZXIgaWYgdHJ1ZSwgYmlnIGVuZGlhbiBpZiBmYWxzZVxuXG4gIC8vIEFkZHMgdGhlIGZvbGxvd2luZyBvcHRpb25zIHRvIHRoZSBwYXJzZU1ldGFEYXRhIG1ldGhvZDpcbiAgLy8gLSBkaXNhYmxlRXhpZjogRGlzYWJsZXMgRXhpZiBwYXJzaW5nIHdoZW4gdHJ1ZS5cbiAgLy8gLSBkaXNhYmxlRXhpZk9mZnNldHM6IERpc2FibGVzIHN0b3JpbmcgRXhpZiB0YWcgb2Zmc2V0cyB3aGVuIHRydWUuXG4gIC8vIC0gaW5jbHVkZUV4aWZUYWdzOiBBIG1hcCBvZiBFeGlmIHRhZ3MgdG8gaW5jbHVkZSBmb3IgcGFyc2luZy5cbiAgLy8gLSBleGNsdWRlRXhpZlRhZ3M6IEEgbWFwIG9mIEV4aWYgdGFncyB0byBleGNsdWRlIGZyb20gcGFyc2luZy5cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-exif.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-fetch.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n\n  if (\n    global.fetch &&\n    global.Request &&\n    global.Response &&\n    global.Response.prototype.blob\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Fetch response handler.\n       *\n       * @param {Response} response Fetch response\n       * @returns {Blob} Fetched Blob.\n       */\n      function responseHandler(response) {\n        return response.blob()\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        return fetch(new Request(url, callback)).then(responseHandler)\n      }\n      fetch(new Request(url, options))\n        .then(responseHandler)\n        .then(callback)\n        [\n          // Avoid parsing error in IE<9, where catch is a reserved word.\n          // eslint-disable-next-line dot-notation\n          'catch'\n        ](function (err) {\n          callback(null, err)\n        })\n    }\n  } else if (\n    global.XMLHttpRequest &&\n    // https://xhr.spec.whatwg.org/#the-responsetype-attribute\n    new XMLHttpRequest().responseType === ''\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Promise executor\n       *\n       * @param {Function} resolve Resolution function\n       * @param {Function} reject Rejection function\n       */\n      function executor(resolve, reject) {\n        options = options || {} // eslint-disable-line no-param-reassign\n        var req = new XMLHttpRequest()\n        req.open(options.method || 'GET', url)\n        if (options.headers) {\n          Object.keys(options.headers).forEach(function (key) {\n            req.setRequestHeader(key, options.headers[key])\n          })\n        }\n        req.withCredentials = options.credentials === 'include'\n        req.responseType = 'blob'\n        req.onload = function () {\n          resolve(req.response)\n        }\n        req.onerror = req.onabort = req.ontimeout = function (err) {\n          if (resolve === reject) {\n            // Not using Promises\n            reject(null, err)\n          } else {\n            reject(err)\n          }\n        }\n        req.send(options.body)\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        options = callback // eslint-disable-line no-param-reassign\n        return new Promise(executor)\n      }\n      return executor(callback, callback)\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtZmV0Y2guanM/YWQyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNyQyxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1mZXRjaC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgRmV0Y2hcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDE3LCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIFByb21pc2UgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBnbG9iYWwgPSBsb2FkSW1hZ2UuZ2xvYmFsXG5cbiAgaWYgKFxuICAgIGdsb2JhbC5mZXRjaCAmJlxuICAgIGdsb2JhbC5SZXF1ZXN0ICYmXG4gICAgZ2xvYmFsLlJlc3BvbnNlICYmXG4gICAgZ2xvYmFsLlJlc3BvbnNlLnByb3RvdHlwZS5ibG9iXG4gICkge1xuICAgIGxvYWRJbWFnZS5mZXRjaEJsb2IgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiBGZXRjaCByZXNwb25zZSBoYW5kbGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIEZldGNoIHJlc3BvbnNlXG4gICAgICAgKiBAcmV0dXJucyB7QmxvYn0gRmV0Y2hlZCBCbG9iLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiByZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKVxuICAgICAgfVxuICAgICAgaWYgKGdsb2JhbC5Qcm9taXNlICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmV0Y2gobmV3IFJlcXVlc3QodXJsLCBjYWxsYmFjaykpLnRoZW4ocmVzcG9uc2VIYW5kbGVyKVxuICAgICAgfVxuICAgICAgZmV0Y2gobmV3IFJlcXVlc3QodXJsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4ocmVzcG9uc2VIYW5kbGVyKVxuICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgW1xuICAgICAgICAgIC8vIEF2b2lkIHBhcnNpbmcgZXJyb3IgaW4gSUU8OSwgd2hlcmUgY2F0Y2ggaXMgYSByZXNlcnZlZCB3b3JkLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgICAnY2F0Y2gnXG4gICAgICAgIF0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0ICYmXG4gICAgLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyN0aGUtcmVzcG9uc2V0eXBlLWF0dHJpYnV0ZVxuICAgIG5ldyBYTUxIdHRwUmVxdWVzdCgpLnJlc3BvbnNlVHlwZSA9PT0gJydcbiAgKSB7XG4gICAgbG9hZEltYWdlLmZldGNoQmxvYiA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqIFByb21pc2UgZXhlY3V0b3JcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIFJlc29sdXRpb24gZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBSZWplY3Rpb24gZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCB1cmwpXG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZSdcbiAgICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICAgIHJlcS5vbmVycm9yID0gcmVxLm9uYWJvcnQgPSByZXEub250aW1lb3V0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChyZXNvbHZlID09PSByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIE5vdCB1c2luZyBQcm9taXNlc1xuICAgICAgICAgICAgcmVqZWN0KG51bGwsIGVycilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNlbmQob3B0aW9ucy5ib2R5KVxuICAgICAgfVxuICAgICAgaWYgKGdsb2JhbC5Qcm9taXNlICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zID0gY2FsbGJhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0b3IoY2FsbGJhY2ssIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-fetch.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc-map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://iptc.org/standards/photo-metadata\n * https://exiftool.org/TagNames/IPTC.html\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-iptc */ \"./node_modules/blueimp-load-image/js/load-image-iptc.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var IptcMapProto = loadImage.IptcMap.prototype\n\n  IptcMapProto.tags = {\n    0: 'ApplicationRecordVersion',\n    3: 'ObjectTypeReference',\n    4: 'ObjectAttributeReference',\n    5: 'ObjectName',\n    7: 'EditStatus',\n    8: 'EditorialUpdate',\n    10: 'Urgency',\n    12: 'SubjectReference',\n    15: 'Category',\n    20: 'SupplementalCategories',\n    22: 'FixtureIdentifier',\n    25: 'Keywords',\n    26: 'ContentLocationCode',\n    27: 'ContentLocationName',\n    30: 'ReleaseDate',\n    35: 'ReleaseTime',\n    37: 'ExpirationDate',\n    38: 'ExpirationTime',\n    40: 'SpecialInstructions',\n    42: 'ActionAdvised',\n    45: 'ReferenceService',\n    47: 'ReferenceDate',\n    50: 'ReferenceNumber',\n    55: 'DateCreated',\n    60: 'TimeCreated',\n    62: 'DigitalCreationDate',\n    63: 'DigitalCreationTime',\n    65: 'OriginatingProgram',\n    70: 'ProgramVersion',\n    75: 'ObjectCycle',\n    80: 'Byline',\n    85: 'BylineTitle',\n    90: 'City',\n    92: 'Sublocation',\n    95: 'State',\n    100: 'CountryCode',\n    101: 'Country',\n    103: 'OriginalTransmissionReference',\n    105: 'Headline',\n    110: 'Credit',\n    115: 'Source',\n    116: 'CopyrightNotice',\n    118: 'Contact',\n    120: 'Caption',\n    121: 'LocalCaption',\n    122: 'Writer',\n    125: 'RasterizedCaption',\n    130: 'ImageType',\n    131: 'ImageOrientation',\n    135: 'LanguageIdentifier',\n    150: 'AudioType',\n    151: 'AudioSamplingRate',\n    152: 'AudioSamplingResolution',\n    153: 'AudioDuration',\n    154: 'AudioOutcue',\n    184: 'JobID',\n    185: 'MasterDocumentID',\n    186: 'ShortDocumentID',\n    187: 'UniqueDocumentID',\n    188: 'OwnerID',\n    200: 'ObjectPreviewFileFormat',\n    201: 'ObjectPreviewFileVersion',\n    202: 'ObjectPreviewData',\n    221: 'Prefs',\n    225: 'ClassifyState',\n    228: 'SimilarityIndex',\n    230: 'DocumentNotes',\n    231: 'DocumentHistory',\n    232: 'ExifCameraInfo',\n    255: 'CatalogSets'\n  }\n\n  IptcMapProto.stringValues = {\n    10: {\n      0: '0 (reserved)',\n      1: '1 (most urgent)',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5 (normal urgency)',\n      6: '6',\n      7: '7',\n      8: '8 (least urgent)',\n      9: '9 (user-defined priority)'\n    },\n    75: {\n      a: 'Morning',\n      b: 'Both Morning and Evening',\n      p: 'Evening'\n    },\n    131: {\n      L: 'Landscape',\n      P: 'Portrait',\n      S: 'Square'\n    }\n  }\n\n  IptcMapProto.getText = function (id) {\n    var value = this.get(id)\n    var tagCode = this.map[id]\n    var stringValue = this.stringValues[tagCode]\n    if (stringValue) return stringValue[value]\n    return String(value)\n  }\n\n  IptcMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        name = this.tags[prop]\n        if (name) map[name] = this.getText(name)\n      }\n    }\n    return map\n  }\n\n  IptcMapProto.getName = function (tagCode) {\n    return this.tags[tagCode]\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = IptcMapProto.tags\n    var map = IptcMapProto.map || {}\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = Number(prop)\n      }\n    }\n  })()\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanM/ZTkxNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsNkZBQWMsRUFBRSx1R0FBbUIsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzFELEdBQUcsTUFBTSxFQUtOO0FBQ0gsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy1tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIElQVEMgTWFwXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUxvYWQtSW1hZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogQ29weXJpZ2h0IDIwMTgsIERhdmUgQmV2YW5cbiAqXG4gKiBJUFRDIHRhZ3MgbWFwcGluZyBiYXNlZCBvblxuICogaHR0cHM6Ly9pcHRjLm9yZy9zdGFuZGFyZHMvcGhvdG8tbWV0YWRhdGFcbiAqIGh0dHBzOi8vZXhpZnRvb2wub3JnL1RhZ05hbWVzL0lQVEMuaHRtbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLWlwdGMnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1pcHRjJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24gKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgSXB0Y01hcFByb3RvID0gbG9hZEltYWdlLklwdGNNYXAucHJvdG90eXBlXG5cbiAgSXB0Y01hcFByb3RvLnRhZ3MgPSB7XG4gICAgMDogJ0FwcGxpY2F0aW9uUmVjb3JkVmVyc2lvbicsXG4gICAgMzogJ09iamVjdFR5cGVSZWZlcmVuY2UnLFxuICAgIDQ6ICdPYmplY3RBdHRyaWJ1dGVSZWZlcmVuY2UnLFxuICAgIDU6ICdPYmplY3ROYW1lJyxcbiAgICA3OiAnRWRpdFN0YXR1cycsXG4gICAgODogJ0VkaXRvcmlhbFVwZGF0ZScsXG4gICAgMTA6ICdVcmdlbmN5JyxcbiAgICAxMjogJ1N1YmplY3RSZWZlcmVuY2UnLFxuICAgIDE1OiAnQ2F0ZWdvcnknLFxuICAgIDIwOiAnU3VwcGxlbWVudGFsQ2F0ZWdvcmllcycsXG4gICAgMjI6ICdGaXh0dXJlSWRlbnRpZmllcicsXG4gICAgMjU6ICdLZXl3b3JkcycsXG4gICAgMjY6ICdDb250ZW50TG9jYXRpb25Db2RlJyxcbiAgICAyNzogJ0NvbnRlbnRMb2NhdGlvbk5hbWUnLFxuICAgIDMwOiAnUmVsZWFzZURhdGUnLFxuICAgIDM1OiAnUmVsZWFzZVRpbWUnLFxuICAgIDM3OiAnRXhwaXJhdGlvbkRhdGUnLFxuICAgIDM4OiAnRXhwaXJhdGlvblRpbWUnLFxuICAgIDQwOiAnU3BlY2lhbEluc3RydWN0aW9ucycsXG4gICAgNDI6ICdBY3Rpb25BZHZpc2VkJyxcbiAgICA0NTogJ1JlZmVyZW5jZVNlcnZpY2UnLFxuICAgIDQ3OiAnUmVmZXJlbmNlRGF0ZScsXG4gICAgNTA6ICdSZWZlcmVuY2VOdW1iZXInLFxuICAgIDU1OiAnRGF0ZUNyZWF0ZWQnLFxuICAgIDYwOiAnVGltZUNyZWF0ZWQnLFxuICAgIDYyOiAnRGlnaXRhbENyZWF0aW9uRGF0ZScsXG4gICAgNjM6ICdEaWdpdGFsQ3JlYXRpb25UaW1lJyxcbiAgICA2NTogJ09yaWdpbmF0aW5nUHJvZ3JhbScsXG4gICAgNzA6ICdQcm9ncmFtVmVyc2lvbicsXG4gICAgNzU6ICdPYmplY3RDeWNsZScsXG4gICAgODA6ICdCeWxpbmUnLFxuICAgIDg1OiAnQnlsaW5lVGl0bGUnLFxuICAgIDkwOiAnQ2l0eScsXG4gICAgOTI6ICdTdWJsb2NhdGlvbicsXG4gICAgOTU6ICdTdGF0ZScsXG4gICAgMTAwOiAnQ291bnRyeUNvZGUnLFxuICAgIDEwMTogJ0NvdW50cnknLFxuICAgIDEwMzogJ09yaWdpbmFsVHJhbnNtaXNzaW9uUmVmZXJlbmNlJyxcbiAgICAxMDU6ICdIZWFkbGluZScsXG4gICAgMTEwOiAnQ3JlZGl0JyxcbiAgICAxMTU6ICdTb3VyY2UnLFxuICAgIDExNjogJ0NvcHlyaWdodE5vdGljZScsXG4gICAgMTE4OiAnQ29udGFjdCcsXG4gICAgMTIwOiAnQ2FwdGlvbicsXG4gICAgMTIxOiAnTG9jYWxDYXB0aW9uJyxcbiAgICAxMjI6ICdXcml0ZXInLFxuICAgIDEyNTogJ1Jhc3Rlcml6ZWRDYXB0aW9uJyxcbiAgICAxMzA6ICdJbWFnZVR5cGUnLFxuICAgIDEzMTogJ0ltYWdlT3JpZW50YXRpb24nLFxuICAgIDEzNTogJ0xhbmd1YWdlSWRlbnRpZmllcicsXG4gICAgMTUwOiAnQXVkaW9UeXBlJyxcbiAgICAxNTE6ICdBdWRpb1NhbXBsaW5nUmF0ZScsXG4gICAgMTUyOiAnQXVkaW9TYW1wbGluZ1Jlc29sdXRpb24nLFxuICAgIDE1MzogJ0F1ZGlvRHVyYXRpb24nLFxuICAgIDE1NDogJ0F1ZGlvT3V0Y3VlJyxcbiAgICAxODQ6ICdKb2JJRCcsXG4gICAgMTg1OiAnTWFzdGVyRG9jdW1lbnRJRCcsXG4gICAgMTg2OiAnU2hvcnREb2N1bWVudElEJyxcbiAgICAxODc6ICdVbmlxdWVEb2N1bWVudElEJyxcbiAgICAxODg6ICdPd25lcklEJyxcbiAgICAyMDA6ICdPYmplY3RQcmV2aWV3RmlsZUZvcm1hdCcsXG4gICAgMjAxOiAnT2JqZWN0UHJldmlld0ZpbGVWZXJzaW9uJyxcbiAgICAyMDI6ICdPYmplY3RQcmV2aWV3RGF0YScsXG4gICAgMjIxOiAnUHJlZnMnLFxuICAgIDIyNTogJ0NsYXNzaWZ5U3RhdGUnLFxuICAgIDIyODogJ1NpbWlsYXJpdHlJbmRleCcsXG4gICAgMjMwOiAnRG9jdW1lbnROb3RlcycsXG4gICAgMjMxOiAnRG9jdW1lbnRIaXN0b3J5JyxcbiAgICAyMzI6ICdFeGlmQ2FtZXJhSW5mbycsXG4gICAgMjU1OiAnQ2F0YWxvZ1NldHMnXG4gIH1cblxuICBJcHRjTWFwUHJvdG8uc3RyaW5nVmFsdWVzID0ge1xuICAgIDEwOiB7XG4gICAgICAwOiAnMCAocmVzZXJ2ZWQpJyxcbiAgICAgIDE6ICcxIChtb3N0IHVyZ2VudCknLFxuICAgICAgMjogJzInLFxuICAgICAgMzogJzMnLFxuICAgICAgNDogJzQnLFxuICAgICAgNTogJzUgKG5vcm1hbCB1cmdlbmN5KScsXG4gICAgICA2OiAnNicsXG4gICAgICA3OiAnNycsXG4gICAgICA4OiAnOCAobGVhc3QgdXJnZW50KScsXG4gICAgICA5OiAnOSAodXNlci1kZWZpbmVkIHByaW9yaXR5KSdcbiAgICB9LFxuICAgIDc1OiB7XG4gICAgICBhOiAnTW9ybmluZycsXG4gICAgICBiOiAnQm90aCBNb3JuaW5nIGFuZCBFdmVuaW5nJyxcbiAgICAgIHA6ICdFdmVuaW5nJ1xuICAgIH0sXG4gICAgMTMxOiB7XG4gICAgICBMOiAnTGFuZHNjYXBlJyxcbiAgICAgIFA6ICdQb3J0cmFpdCcsXG4gICAgICBTOiAnU3F1YXJlJ1xuICAgIH1cbiAgfVxuXG4gIElwdGNNYXBQcm90by5nZXRUZXh0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaWQpXG4gICAgdmFyIHRhZ0NvZGUgPSB0aGlzLm1hcFtpZF1cbiAgICB2YXIgc3RyaW5nVmFsdWUgPSB0aGlzLnN0cmluZ1ZhbHVlc1t0YWdDb2RlXVxuICAgIGlmIChzdHJpbmdWYWx1ZSkgcmV0dXJuIHN0cmluZ1ZhbHVlW3ZhbHVlXVxuICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gIH1cblxuICBJcHRjTWFwUHJvdG8uZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXAgPSB7fVxuICAgIHZhciBwcm9wXG4gICAgdmFyIG5hbWVcbiAgICBmb3IgKHByb3AgaW4gdGhpcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wKSkge1xuICAgICAgICBuYW1lID0gdGhpcy50YWdzW3Byb3BdXG4gICAgICAgIGlmIChuYW1lKSBtYXBbbmFtZV0gPSB0aGlzLmdldFRleHQobmFtZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgSXB0Y01hcFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAodGFnQ29kZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3NbdGFnQ29kZV1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgbWFwIG9mIHRhZyBuYW1lcyB0byB0YWcgY29kZXM6XG4gIDsoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YWdzID0gSXB0Y01hcFByb3RvLnRhZ3NcbiAgICB2YXIgbWFwID0gSXB0Y01hcFByb3RvLm1hcCB8fCB7fVxuICAgIHZhciBwcm9wXG4gICAgLy8gTWFwIHRoZSB0YWcgbmFtZXMgdG8gdGFnczpcbiAgICBmb3IgKHByb3AgaW4gdGFncykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWdzLCBwcm9wKSkge1xuICAgICAgICBtYXBbdGFnc1twcm9wXV0gPSBOdW1iZXIocHJvcClcbiAgICAgIH1cbiAgICB9XG4gIH0pKClcbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc-map.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-iptc.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-iptc.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * IPTC tag map\n   *\n   * @name IptcMap\n   * @class\n   */\n  function IptcMap() {}\n\n  IptcMap.prototype.map = {\n    ObjectName: 5\n  }\n\n  IptcMap.prototype.types = {\n    0: 'Uint16', // ApplicationRecordVersion\n    200: 'Uint16', // ObjectPreviewFileFormat\n    201: 'Uint16', // ObjectPreviewFileVersion\n    202: 'binary' // ObjectPreviewData\n  }\n\n  /**\n   * Retrieves IPTC tag value\n   *\n   * @param {number|string} id IPTC tag code or name\n   * @returns {object} IPTC tag value\n   */\n  IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Retrieves string for the given DataView and range\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Offset start\n   * @param {number} length Offset length\n   * @returns {string} String value\n   */\n  function getStringValue(dataView, offset, length) {\n    var outstr = ''\n    var end = offset + length\n    for (var n = offset; n < end; n += 1) {\n      outstr += String.fromCharCode(dataView.getUint8(n))\n    }\n    return outstr\n  }\n\n  /**\n   * Retrieves tag value for the given DataView and range\n   *\n   * @param {number} tagCode tag code\n   * @param {IptcMap} map IPTC tag map\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Range start\n   * @param {number} length Range length\n   * @returns {object} Tag value\n   */\n  function getTagValue(tagCode, map, dataView, offset, length) {\n    if (map.types[tagCode] === 'binary') {\n      return new Blob([dataView.buffer.slice(offset, offset + length)])\n    }\n    if (map.types[tagCode] === 'Uint16') {\n      return dataView.getUint16(offset)\n    }\n    return getStringValue(dataView, offset, length)\n  }\n\n  /**\n   * Combines IPTC value with existing ones.\n   *\n   * @param {object} value Existing IPTC field value\n   * @param {object} newValue New IPTC field value\n   * @returns {object} Resulting IPTC field value\n   */\n  function combineTagValues(value, newValue) {\n    if (value === undefined) return newValue\n    if (value instanceof Array) {\n      value.push(newValue)\n      return value\n    }\n    return [value, newValue]\n  }\n\n  /**\n   * Parses IPTC tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} segmentOffset Segment offset\n   * @param {number} segmentLength Segment length\n   * @param {object} data Data export object\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseIptcTags(\n    dataView,\n    segmentOffset,\n    segmentLength,\n    data,\n    includeTags,\n    excludeTags\n  ) {\n    var value, tagSize, tagCode\n    var segmentEnd = segmentOffset + segmentLength\n    var offset = segmentOffset\n    while (offset < segmentEnd) {\n      if (\n        dataView.getUint8(offset) === 0x1c && // tag marker\n        dataView.getUint8(offset + 1) === 0x02 // record number, only handles v2\n      ) {\n        tagCode = dataView.getUint8(offset + 2)\n        if (\n          (!includeTags || includeTags[tagCode]) &&\n          (!excludeTags || !excludeTags[tagCode])\n        ) {\n          tagSize = dataView.getInt16(offset + 3)\n          value = getTagValue(tagCode, data.iptc, dataView, offset + 5, tagSize)\n          data.iptc[tagCode] = combineTagValues(data.iptc[tagCode], value)\n          if (data.iptcOffsets) {\n            data.iptcOffsets[tagCode] = offset\n          }\n        }\n      }\n      offset += 1\n    }\n  }\n\n  /**\n   * Tests if field segment starts at offset.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {boolean} True if '8BIM<EOT><EOT>' exists at offset\n   */\n  function isSegmentStart(dataView, offset) {\n    return (\n      dataView.getUint32(offset) === 0x3842494d && // Photoshop segment start\n      dataView.getUint16(offset + 4) === 0x0404 // IPTC segment start\n    )\n  }\n\n  /**\n   * Returns header length.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {number} Header length\n   */\n  function getHeaderLength(dataView, offset) {\n    var length = dataView.getUint8(offset + 7)\n    if (length % 2 !== 0) length += 1\n    // Check for pre photoshop 6 format\n    if (length === 0) {\n      // Always 4\n      length = 4\n    }\n    return length\n  }\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    while (offset + 8 < markerLength) {\n      if (isSegmentStart(dataView, offset)) {\n        var headerLength = getHeaderLength(dataView, offset)\n        var segmentOffset = offset + 8 + headerLength\n        if (segmentOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var segmentLength = dataView.getUint16(offset + 6 + headerLength)\n        if (offset + segmentLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new IptcMap()\n        if (!options.disableIptcOffsets) {\n          data.iptcOffsets = new IptcMap()\n        }\n        parseIptcTags(\n          dataView,\n          segmentOffset,\n          segmentLength,\n          data,\n          options.includeIptcTags,\n          options.excludeIptcTags || { 202: true } // ObjectPreviewData\n        )\n        return\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset += 1\n    }\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  loadImage.IptcMap = IptcMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // - disableIptc: Disables IPTC parsing when true.\n  // - disableIptcOffsets: Disables storing IPTC tag offsets when true.\n  // - includeIptcTags: A map of IPTC tags to include for parsing.\n  // - excludeIptcTags: A map of IPTC tags to exclude from parsing.\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtaXB0Yy5qcz85ZmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDMUQsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS1pcHRjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBJUFRDIFBhcnNlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIENvcHlyaWdodCAyMDE4LCBEYXZlIEJldmFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUsIERhdGFWaWV3ICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2xvYWQtaW1hZ2UnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZSgnLi9sb2FkLWltYWdlJyksIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1tZXRhJykpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmxvYWRJbWFnZSlcbiAgfVxufSkoZnVuY3Rpb24gKGxvYWRJbWFnZSkge1xuICAndXNlIHN0cmljdCdcblxuICAvKipcbiAgICogSVBUQyB0YWcgbWFwXG4gICAqXG4gICAqIEBuYW1lIElwdGNNYXBcbiAgICogQGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBJcHRjTWFwKCkge31cblxuICBJcHRjTWFwLnByb3RvdHlwZS5tYXAgPSB7XG4gICAgT2JqZWN0TmFtZTogNVxuICB9XG5cbiAgSXB0Y01hcC5wcm90b3R5cGUudHlwZXMgPSB7XG4gICAgMDogJ1VpbnQxNicsIC8vIEFwcGxpY2F0aW9uUmVjb3JkVmVyc2lvblxuICAgIDIwMDogJ1VpbnQxNicsIC8vIE9iamVjdFByZXZpZXdGaWxlRm9ybWF0XG4gICAgMjAxOiAnVWludDE2JywgLy8gT2JqZWN0UHJldmlld0ZpbGVWZXJzaW9uXG4gICAgMjAyOiAnYmluYXJ5JyAvLyBPYmplY3RQcmV2aWV3RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBJUFRDIHRhZyB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkIElQVEMgdGFnIGNvZGUgb3IgbmFtZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBJUFRDIHRhZyB2YWx1ZVxuICAgKi9cbiAgSXB0Y01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8IHRoaXNbdGhpcy5tYXBbaWRdXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzdHJpbmcgZm9yIHRoZSBnaXZlbiBEYXRhVmlldyBhbmQgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgRGF0YSB2aWV3IGludGVyZmFjZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldCBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE9mZnNldCBsZW5ndGhcbiAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZShkYXRhVmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICB2YXIgb3V0c3RyID0gJydcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoXG4gICAgZm9yICh2YXIgbiA9IG9mZnNldDsgbiA8IGVuZDsgbiArPSAxKSB7XG4gICAgICBvdXRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChuKSlcbiAgICB9XG4gICAgcmV0dXJuIG91dHN0clxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0YWcgdmFsdWUgZm9yIHRoZSBnaXZlbiBEYXRhVmlldyBhbmQgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhZ0NvZGUgdGFnIGNvZGVcbiAgICogQHBhcmFtIHtJcHRjTWFwfSBtYXAgSVBUQyB0YWcgbWFwXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IERhdGEgdmlldyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBSYW5nZSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFJhbmdlIGxlbmd0aFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUYWcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRhZ1ZhbHVlKHRhZ0NvZGUsIG1hcCwgZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKG1hcC50eXBlc1t0YWdDb2RlXSA9PT0gJ2JpbmFyeScpIHtcbiAgICAgIHJldHVybiBuZXcgQmxvYihbZGF0YVZpZXcuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKV0pXG4gICAgfVxuICAgIGlmIChtYXAudHlwZXNbdGFnQ29kZV0gPT09ICdVaW50MTYnKSB7XG4gICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0cmluZ1ZhbHVlKGRhdGFWaWV3LCBvZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyBJUFRDIHZhbHVlIHdpdGggZXhpc3Rpbmcgb25lcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIEV4aXN0aW5nIElQVEMgZmllbGQgdmFsdWVcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1ZhbHVlIE5ldyBJUFRDIGZpZWxkIHZhbHVlXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFJlc3VsdGluZyBJUFRDIGZpZWxkIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBjb21iaW5lVGFnVmFsdWVzKHZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3VmFsdWVcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFsdWUucHVzaChuZXdWYWx1ZSlcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBuZXdWYWx1ZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgSVBUQyB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBEYXRhIHZpZXcgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50T2Zmc2V0IFNlZ21lbnQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50TGVuZ3RoIFNlZ21lbnQgbGVuZ3RoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIERhdGEgZXhwb3J0IG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5jbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gaW5jbHVkZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZXhjbHVkZVRhZ3MgTWFwIG9mIHRhZ3MgdG8gZXhjbHVkZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VJcHRjVGFncyhcbiAgICBkYXRhVmlldyxcbiAgICBzZWdtZW50T2Zmc2V0LFxuICAgIHNlZ21lbnRMZW5ndGgsXG4gICAgZGF0YSxcbiAgICBpbmNsdWRlVGFncyxcbiAgICBleGNsdWRlVGFnc1xuICApIHtcbiAgICB2YXIgdmFsdWUsIHRhZ1NpemUsIHRhZ0NvZGVcbiAgICB2YXIgc2VnbWVudEVuZCA9IHNlZ21lbnRPZmZzZXQgKyBzZWdtZW50TGVuZ3RoXG4gICAgdmFyIG9mZnNldCA9IHNlZ21lbnRPZmZzZXRcbiAgICB3aGlsZSAob2Zmc2V0IDwgc2VnbWVudEVuZCkge1xuICAgICAgaWYgKFxuICAgICAgICBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpID09PSAweDFjICYmIC8vIHRhZyBtYXJrZXJcbiAgICAgICAgZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSkgPT09IDB4MDIgLy8gcmVjb3JkIG51bWJlciwgb25seSBoYW5kbGVzIHYyXG4gICAgICApIHtcbiAgICAgICAgdGFnQ29kZSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDIpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoIWluY2x1ZGVUYWdzIHx8IGluY2x1ZGVUYWdzW3RhZ0NvZGVdKSAmJlxuICAgICAgICAgICghZXhjbHVkZVRhZ3MgfHwgIWV4Y2x1ZGVUYWdzW3RhZ0NvZGVdKVxuICAgICAgICApIHtcbiAgICAgICAgICB0YWdTaXplID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0ICsgMylcbiAgICAgICAgICB2YWx1ZSA9IGdldFRhZ1ZhbHVlKHRhZ0NvZGUsIGRhdGEuaXB0YywgZGF0YVZpZXcsIG9mZnNldCArIDUsIHRhZ1NpemUpXG4gICAgICAgICAgZGF0YS5pcHRjW3RhZ0NvZGVdID0gY29tYmluZVRhZ1ZhbHVlcyhkYXRhLmlwdGNbdGFnQ29kZV0sIHZhbHVlKVxuICAgICAgICAgIGlmIChkYXRhLmlwdGNPZmZzZXRzKSB7XG4gICAgICAgICAgICBkYXRhLmlwdGNPZmZzZXRzW3RhZ0NvZGVdID0gb2Zmc2V0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gMVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBmaWVsZCBzZWdtZW50IHN0YXJ0cyBhdCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IERhdGEgdmlldyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBTZWdtZW50IG9mZnNldFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiAnOEJJTTxFT1Q+PEVPVD4nIGV4aXN0cyBhdCBvZmZzZXRcbiAgICovXG4gIGZ1bmN0aW9uIGlzU2VnbWVudFN0YXJ0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCkgPT09IDB4Mzg0MjQ5NGQgJiYgLy8gUGhvdG9zaG9wIHNlZ21lbnQgc3RhcnRcbiAgICAgIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA0KSA9PT0gMHgwNDA0IC8vIElQVEMgc2VnbWVudCBzdGFydFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhlYWRlciBsZW5ndGguXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IERhdGEgdmlldyBpbnRlcmZhY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBTZWdtZW50IG9mZnNldFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBIZWFkZXIgbGVuZ3RoXG4gICAqL1xuICBmdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciBsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyA3KVxuICAgIGlmIChsZW5ndGggJSAyICE9PSAwKSBsZW5ndGggKz0gMVxuICAgIC8vIENoZWNrIGZvciBwcmUgcGhvdG9zaG9wIDYgZm9ybWF0XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQWx3YXlzIDRcbiAgICAgIGxlbmd0aCA9IDRcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgbG9hZEltYWdlLnBhcnNlSXB0Y0RhdGEgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZUlwdGMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbWFya2VyTGVuZ3RoID0gb2Zmc2V0ICsgbGVuZ3RoXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBtYXJrZXJMZW5ndGgpIHtcbiAgICAgIGlmIChpc1NlZ21lbnRTdGFydChkYXRhVmlldywgb2Zmc2V0KSkge1xuICAgICAgICB2YXIgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGFWaWV3LCBvZmZzZXQpXG4gICAgICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gb2Zmc2V0ICsgOCArIGhlYWRlckxlbmd0aFxuICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IG1hcmtlckxlbmd0aCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSVBUQyBkYXRhOiBJbnZhbGlkIHNlZ21lbnQgb2Zmc2V0LicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA2ICsgaGVhZGVyTGVuZ3RoKVxuICAgICAgICBpZiAob2Zmc2V0ICsgc2VnbWVudExlbmd0aCA+IG1hcmtlckxlbmd0aCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSVBUQyBkYXRhOiBJbnZhbGlkIHNlZ21lbnQgc2l6ZS4nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpcHRjIG9iamVjdCB0byBzdG9yZSB0aGUgdGFnczpcbiAgICAgICAgZGF0YS5pcHRjID0gbmV3IElwdGNNYXAoKVxuICAgICAgICBpZiAoIW9wdGlvbnMuZGlzYWJsZUlwdGNPZmZzZXRzKSB7XG4gICAgICAgICAgZGF0YS5pcHRjT2Zmc2V0cyA9IG5ldyBJcHRjTWFwKClcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUlwdGNUYWdzKFxuICAgICAgICAgIGRhdGFWaWV3LFxuICAgICAgICAgIHNlZ21lbnRPZmZzZXQsXG4gICAgICAgICAgc2VnbWVudExlbmd0aCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIG9wdGlvbnMuaW5jbHVkZUlwdGNUYWdzLFxuICAgICAgICAgIG9wdGlvbnMuZXhjbHVkZUlwdGNUYWdzIHx8IHsgMjAyOiB0cnVlIH0gLy8gT2JqZWN0UHJldmlld0RhdGFcbiAgICAgICAgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgb2Zmc2V0ICs9IDFcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlcnMgdGhpcyBJUFRDIHBhcnNlciBmb3IgdGhlIEFQUDEzIEpQRUcgbWV0YWRhdGEgc2VnbWVudDpcbiAgbG9hZEltYWdlLm1ldGFEYXRhUGFyc2Vycy5qcGVnWzB4ZmZlZF0ucHVzaChsb2FkSW1hZ2UucGFyc2VJcHRjRGF0YSlcblxuICBsb2FkSW1hZ2UuSXB0Y01hcCA9IElwdGNNYXBcblxuICAvLyBBZGRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB0byB0aGUgcGFyc2VNZXRhRGF0YSBjYWxsYmFjayBkYXRhOlxuICAvLyAtIGlwdGM6IFRoZSBpcHRjIHRhZ3MsIHBhcnNlZCBieSB0aGUgcGFyc2VJcHRjRGF0YSBtZXRob2RcblxuICAvLyBBZGRzIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyB0byB0aGUgcGFyc2VNZXRhRGF0YSBtZXRob2Q6XG4gIC8vIC0gZGlzYWJsZUlwdGM6IERpc2FibGVzIElQVEMgcGFyc2luZyB3aGVuIHRydWUuXG4gIC8vIC0gZGlzYWJsZUlwdGNPZmZzZXRzOiBEaXNhYmxlcyBzdG9yaW5nIElQVEMgdGFnIG9mZnNldHMgd2hlbiB0cnVlLlxuICAvLyAtIGluY2x1ZGVJcHRjVGFnczogQSBtYXAgb2YgSVBUQyB0YWdzIHRvIGluY2x1ZGUgZm9yIHBhcnNpbmcuXG4gIC8vIC0gZXhjbHVkZUlwdGNUYWdzOiBBIG1hcCBvZiBJUFRDIHRhZ3MgdG8gZXhjbHVkZSBmcm9tIHBhcnNpbmcuXG59KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-iptc.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-meta.js":
/*!***************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-meta.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n  var originalTransform = loadImage.transform\n\n  var blobSlice =\n    global.Blob &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  var bufferSlice =\n    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||\n    function (begin, end) {\n      // Polyfill for IE10, which does not support ArrayBuffer.slice\n      // eslint-disable-next-line no-param-reassign\n      end = end || this.byteLength - begin\n      var arr1 = new Uint8Array(this, begin, end)\n      var arr2 = new Uint8Array(end)\n      arr2.set(arr1)\n      return arr2.buffer\n    }\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (\n        !(\n          global.DataView &&\n          blobSlice &&\n          file &&\n          file.size >= 12 &&\n          file.type === 'image/jpeg'\n        )\n      ) {\n        // Nothing to parse\n        return resolve(data)\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144\n      if (\n        !loadImage.readFile(\n          blobSlice.call(file, 0, maxMetaDataSize),\n          function (buffer) {\n            // Note on endianness:\n            // Since the marker and length bytes in JPEG files are always\n            // stored in big endian order, we can leave the endian parameter\n            // of the DataView methods undefined, defaulting to big endian.\n            var dataView = new DataView(buffer)\n            // Check for the JPEG marker (0xffd8):\n            if (dataView.getUint16(0) !== 0xffd8) {\n              return reject(\n                new Error('Invalid JPEG file: Missing JPEG marker.')\n              )\n            }\n            var offset = 2\n            var maxOffset = dataView.byteLength - 4\n            var headLength = offset\n            var markerBytes\n            var markerLength\n            var parsers\n            var i\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific metadata like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid JPEG metadata: Invalid segment size.')\n                  break\n                }\n                parsers = metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the metadata\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              data.imageHead = bufferSlice.call(buffer, 0, headLength)\n            }\n            resolve(data)\n          },\n          reject,\n          'readAsArrayBuffer'\n        )\n      ) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data)\n      }\n    }\n    options = options || {} // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {} // eslint-disable-line no-param-reassign\n      data = options // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    data = data || {} // eslint-disable-line no-param-reassign\n    return executor(callback, callback)\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    })\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = { maxMetaDataSize: 256, disableMetaDataParsers: true }\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head)\n      })\n    }\n    parseMetaData(\n      blob,\n      function (data) {\n        callback(replaceJPEGHead(blob, data.imageHead, head))\n      },\n      options\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {} // eslint-disable-line no-param-reassign\n      parseMetaData(\n        file,\n        function (result) {\n          if (result !== data) {\n            // eslint-disable-next-line no-console\n            if (global.console) console.log(result)\n            result = data // eslint-disable-line no-param-reassign\n          }\n          originalTransform.call(\n            loadImage,\n            img,\n            options,\n            callback,\n            file,\n            result\n          )\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n\n  loadImage.blobSlice = blobSlice\n  loadImage.bufferSlice = bufferSlice\n  loadImage.replaceHead = replaceHead\n  loadImage.parseMetaData = parseMetaData\n  loadImage.metaDataParsers = metaDataParsers\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcz8wNzhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDckMsR0FBRyxNQUFNLEVBS047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsU0FBUztBQUN0QixlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UtbWV0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2UgTWV0YVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBJbWFnZSBtZXRhZGF0YSBoYW5kbGluZyBpbXBsZW1lbnRhdGlvblxuICogYmFzZWQgb24gdGhlIGhlbHAgYW5kIGNvbnRyaWJ1dGlvbiBvZlxuICogQWNoaW0gU3TDtmhyLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlLCBQcm9taXNlLCBEYXRhVmlldywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBnbG9iYWwgPSBsb2FkSW1hZ2UuZ2xvYmFsXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybSA9IGxvYWRJbWFnZS50cmFuc2Zvcm1cblxuICB2YXIgYmxvYlNsaWNlID1cbiAgICBnbG9iYWwuQmxvYiAmJlxuICAgIChCbG9iLnByb3RvdHlwZS5zbGljZSB8fFxuICAgICAgQmxvYi5wcm90b3R5cGUud2Via2l0U2xpY2UgfHxcbiAgICAgIEJsb2IucHJvdG90eXBlLm1velNsaWNlKVxuXG4gIHZhciBidWZmZXJTbGljZSA9XG4gICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpIHx8XG4gICAgZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICAgIC8vIFBvbHlmaWxsIGZvciBJRTEwLCB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IEFycmF5QnVmZmVyLnNsaWNlXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmJ5dGVMZW5ndGggLSBiZWdpblxuICAgICAgdmFyIGFycjEgPSBuZXcgVWludDhBcnJheSh0aGlzLCBiZWdpbiwgZW5kKVxuICAgICAgdmFyIGFycjIgPSBuZXcgVWludDhBcnJheShlbmQpXG4gICAgICBhcnIyLnNldChhcnIxKVxuICAgICAgcmV0dXJuIGFycjIuYnVmZmVyXG4gICAgfVxuXG4gIHZhciBtZXRhRGF0YVBhcnNlcnMgPSB7XG4gICAganBlZzoge1xuICAgICAgMHhmZmUxOiBbXSwgLy8gQVBQMSBtYXJrZXJcbiAgICAgIDB4ZmZlZDogW10gLy8gQVBQMTMgbWFya2VyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBpbWFnZSBtZXRhZGF0YSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggYW4gb2JqZWN0IGFyZ3VtZW50XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAgICogLSBpbWFnZUhlYWQ6IFRoZSBjb21wbGV0ZSBpbWFnZSBoZWFkIGFzIEFycmF5QnVmZmVyXG4gICAqIFRoZSBvcHRpb25zIGFyZ3VtZW50IGFjY2VwdHMgYW4gb2JqZWN0IGFuZCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqIC0gbWF4TWV0YURhdGFTaXplOiBEZWZpbmVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byBwYXJzZS5cbiAgICogLSBkaXNhYmxlSW1hZ2VIZWFkOiBEaXNhYmxlcyBjcmVhdGluZyB0aGUgaW1hZ2VIZWFkIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGZpbGUgQmxvYiBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFBhcnNpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGFdIFJlc3VsdCBkYXRhIG9iamVjdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fHVuZGVmaW5lZH0gUmV0dXJucyBQcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VNZXRhRGF0YShmaWxlLCBjYWxsYmFjaywgb3B0aW9ucywgZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIC8qKlxuICAgICAqIFByb21pc2UgZXhlY3V0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgUmVzb2x1dGlvbiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBSZWplY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBVbmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBnbG9iYWwuRGF0YVZpZXcgJiZcbiAgICAgICAgICBibG9iU2xpY2UgJiZcbiAgICAgICAgICBmaWxlICYmXG4gICAgICAgICAgZmlsZS5zaXplID49IDEyICYmXG4gICAgICAgICAgZmlsZS50eXBlID09PSAnaW1hZ2UvanBlZydcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gcGFyc2VcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSlcbiAgICAgIH1cbiAgICAgIC8vIDI1NiBLaUIgc2hvdWxkIGNvbnRhaW4gYWxsIEVYSUYvSUNDL0lQVEMgc2VnbWVudHM6XG4gICAgICB2YXIgbWF4TWV0YURhdGFTaXplID0gb3B0aW9ucy5tYXhNZXRhRGF0YVNpemUgfHwgMjYyMTQ0XG4gICAgICBpZiAoXG4gICAgICAgICFsb2FkSW1hZ2UucmVhZEZpbGUoXG4gICAgICAgICAgYmxvYlNsaWNlLmNhbGwoZmlsZSwgMCwgbWF4TWV0YURhdGFTaXplKSxcbiAgICAgICAgICBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBOb3RlIG9uIGVuZGlhbm5lc3M6XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgbWFya2VyIGFuZCBsZW5ndGggYnl0ZXMgaW4gSlBFRyBmaWxlcyBhcmUgYWx3YXlzXG4gICAgICAgICAgICAvLyBzdG9yZWQgaW4gYmlnIGVuZGlhbiBvcmRlciwgd2UgY2FuIGxlYXZlIHRoZSBlbmRpYW4gcGFyYW1ldGVyXG4gICAgICAgICAgICAvLyBvZiB0aGUgRGF0YVZpZXcgbWV0aG9kcyB1bmRlZmluZWQsIGRlZmF1bHRpbmcgdG8gYmlnIGVuZGlhbi5cbiAgICAgICAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIEpQRUcgbWFya2VyICgweGZmZDgpOlxuICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdJbnZhbGlkIEpQRUcgZmlsZTogTWlzc2luZyBKUEVHIG1hcmtlci4nKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMlxuICAgICAgICAgICAgdmFyIG1heE9mZnNldCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGggLSA0XG4gICAgICAgICAgICB2YXIgaGVhZExlbmd0aCA9IG9mZnNldFxuICAgICAgICAgICAgdmFyIG1hcmtlckJ5dGVzXG4gICAgICAgICAgICB2YXIgbWFya2VyTGVuZ3RoXG4gICAgICAgICAgICB2YXIgcGFyc2Vyc1xuICAgICAgICAgICAgdmFyIGlcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgbWFya2VyQnl0ZXMgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KVxuICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIEFQUG4gKDB4ZmZlTikgYW5kIENPTSAoMHhmZmZlKSBtYXJrZXJzLFxuICAgICAgICAgICAgICAvLyB3aGljaCBjb250YWluIGFwcGxpY2F0aW9uLXNwZWNpZmljIG1ldGFkYXRhIGxpa2VcbiAgICAgICAgICAgICAgLy8gRXhpZiwgSUNDIGFuZCBJUFRDIGRhdGEgYW5kIHRleHQgY29tbWVudHM6XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobWFya2VyQnl0ZXMgPj0gMHhmZmUwICYmIG1hcmtlckJ5dGVzIDw9IDB4ZmZlZikgfHxcbiAgICAgICAgICAgICAgICBtYXJrZXJCeXRlcyA9PT0gMHhmZmZlXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtYXJrZXIgYnl0ZXMgKDIpIGFyZSBhbHdheXMgZm9sbG93ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIGJ5dGVzICgyKSwgaW5kaWNhdGluZyB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1hcmtlciBzZWdtZW50LCB3aGljaCBpbmNsdWRlcyB0aGUgbGVuZ3RoIGJ5dGVzLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBub3QgdGhlIG1hcmtlciBieXRlcywgc28gd2UgYWRkIDI6XG4gICAgICAgICAgICAgICAgbWFya2VyTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpICsgMlxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyBtYXJrZXJMZW5ndGggPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgSlBFRyBtZXRhZGF0YTogSW52YWxpZCBzZWdtZW50IHNpemUuJylcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlcnMgPSBtZXRhRGF0YVBhcnNlcnMuanBlZ1ttYXJrZXJCeXRlc11cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VycyAmJiAhb3B0aW9ucy5kaXNhYmxlTWV0YURhdGFQYXJzZXJzKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJzW2ldLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya2VyTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBtYXJrZXJMZW5ndGhcbiAgICAgICAgICAgICAgICBoZWFkTGVuZ3RoID0gb2Zmc2V0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGFuIEFQUG4gb3IgQ09NIG1hcmtlciwgcHJvYmFibHkgc2FmZSB0b1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNZXRhIGxlbmd0aCBtdXN0IGJlIGxvbmdlciB0aGFuIEpQRUcgbWFya2VyICgyKVxuICAgICAgICAgICAgLy8gcGx1cyBBUFBuIG1hcmtlciAoMiksIGZvbGxvd2VkIGJ5IGxlbmd0aCBieXRlcyAoMik6XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGlzYWJsZUltYWdlSGVhZCAmJiBoZWFkTGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICBkYXRhLmltYWdlSGVhZCA9IGJ1ZmZlclNsaWNlLmNhbGwoYnVmZmVyLCAwLCBoZWFkTGVuZ3RoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICdyZWFkQXNBcnJheUJ1ZmZlcidcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vIHN1cHBvcnQgZm9yIHRoZSBGaWxlUmVhZGVyIGludGVyZmFjZSwgbm90aGluZyB0byBwYXJzZVxuICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBpZiAoZ2xvYmFsLlByb21pc2UgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0gY2FsbGJhY2sgfHwge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZGF0YSA9IG9wdGlvbnMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuICAgIH1cbiAgICBkYXRhID0gZGF0YSB8fCB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmV0dXJuIGV4ZWN1dG9yKGNhbGxiYWNrLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgaGVhZCBvZiBhIEpQRUcgQmxvYlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gb2xkSGVhZCBPbGQgSlBFRyBoZWFkXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG5ld0hlYWQgTmV3IEpQRUcgaGVhZFxuICAgKiBAcmV0dXJucyB7QmxvYn0gQ29tYmluZWQgQmxvYlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUpQRUdIZWFkKGJsb2IsIG9sZEhlYWQsIG5ld0hlYWQpIHtcbiAgICBpZiAoIWJsb2IgfHwgIW9sZEhlYWQgfHwgIW5ld0hlYWQpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtuZXdIZWFkLCBibG9iU2xpY2UuY2FsbChibG9iLCBvbGRIZWFkLmJ5dGVMZW5ndGgpXSwge1xuICAgICAgdHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgaW1hZ2UgaGVhZCBvZiBhIEpQRUcgYmxvYiB3aXRoIHRoZSBnaXZlbiBvbmUuXG4gICAqIFJldHVybnMgYSBQcm9taXNlIG9yIGNhbGxzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBuZXcgQmxvYi5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIEJsb2Igb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGhlYWQgTmV3IEpQRUcgaGVhZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2J8bnVsbD58dW5kZWZpbmVkfSBDb21iaW5lZCBCbG9iXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSGVhZChibG9iLCBoZWFkLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0geyBtYXhNZXRhRGF0YVNpemU6IDI1NiwgZGlzYWJsZU1ldGFEYXRhUGFyc2VyczogdHJ1ZSB9XG4gICAgaWYgKCFjYWxsYmFjayAmJiBnbG9iYWwuUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHBhcnNlTWV0YURhdGEoYmxvYiwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUpQRUdIZWFkKGJsb2IsIGRhdGEuaW1hZ2VIZWFkLCBoZWFkKVxuICAgICAgfSlcbiAgICB9XG4gICAgcGFyc2VNZXRhRGF0YShcbiAgICAgIGJsb2IsXG4gICAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhyZXBsYWNlSlBFR0hlYWQoYmxvYiwgZGF0YS5pbWFnZUhlYWQsIGhlYWQpKVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gIH1cblxuICBsb2FkSW1hZ2UudHJhbnNmb3JtID0gZnVuY3Rpb24gKGltZywgb3B0aW9ucywgY2FsbGJhY2ssIGZpbGUsIGRhdGEpIHtcbiAgICBpZiAobG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGEob3B0aW9ucykpIHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHBhcnNlTWV0YURhdGEoXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBkYXRhKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlKSBjb25zb2xlLmxvZyhyZXN1bHQpXG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uY2FsbChcbiAgICAgICAgICAgIGxvYWRJbWFnZSxcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGFcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxUcmFuc2Zvcm0uYXBwbHkobG9hZEltYWdlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgbG9hZEltYWdlLmJsb2JTbGljZSA9IGJsb2JTbGljZVxuICBsb2FkSW1hZ2UuYnVmZmVyU2xpY2UgPSBidWZmZXJTbGljZVxuICBsb2FkSW1hZ2UucmVwbGFjZUhlYWQgPSByZXBsYWNlSGVhZFxuICBsb2FkSW1hZ2UucGFyc2VNZXRhRGF0YSA9IHBhcnNlTWV0YURhdGFcbiAgbG9hZEltYWdlLm1ldGFEYXRhUGFyc2VycyA9IG1ldGFEYXRhUGFyc2Vyc1xufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-meta.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-orientation.js":
/*!**********************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-orientation.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/*\nExif orientation values to correctly display the letter F:\n\n    1             2\n  ██████        ██████\n  ██                ██\n  ████            ████\n  ██                ██\n  ██                ██\n\n    3             4\n      ██        ██\n      ██        ██\n    ████        ████\n      ██        ██\n  ██████        ██████\n\n    5             6\n██████████    ██\n██  ██        ██  ██\n██            ██████████\n\n    7             8\n        ██    ██████████\n    ██  ██        ██  ██\n██████████            ██\n\n*/\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\"), __webpack_require__(/*! ./load-image-scale */ \"./node_modules/blueimp-load-image/js/load-image-scale.js\"), __webpack_require__(/*! ./load-image-meta */ \"./node_modules/blueimp-load-image/js/load-image-meta.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n  var originalRequiresCanvas = loadImage.requiresCanvas\n  var originalRequiresMetaData = loadImage.requiresMetaData\n  var originalTransformCoordinates = loadImage.transformCoordinates\n  var originalGetTransformedOptions = loadImage.getTransformedOptions\n\n  ;(function ($) {\n    // Guard for non-browser environments (e.g. server-side rendering):\n    if (!$.global.document) return\n    // black+white 3x2 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90° CCW)\n    // Image data layout (B=black, F=white):\n    // BFF\n    // BBB\n    var testImageURL =\n      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/x' +\n      'ABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAA' +\n      'AAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQ' +\n      'voP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXw' +\n      'H/9k='\n    var img = document.createElement('img')\n    img.onload = function () {\n      // Check if the browser supports automatic image orientation:\n      $.orientation = img.width === 2 && img.height === 3\n      if ($.orientation) {\n        var canvas = $.createCanvas(1, 1, true)\n        var ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 1, 1, 1, 1, 0, 0, 1, 1)\n        // Check if the source image coordinates (sX, sY, sWidth, sHeight) are\n        // correctly applied to the auto-orientated image, which should result\n        // in a white opaque pixel (e.g. in Safari).\n        // Browsers that show a transparent pixel (e.g. Chromium) fail to crop\n        // auto-oriented images correctly and require a workaround, e.g.\n        // drawing the complete source image to an intermediate canvas first.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n        $.orientationCropBug =\n          ctx.getImageData(0, 0, 1, 1).data.toString() !== '255,255,255,255'\n      }\n    }\n    img.src = testImageURL\n  })(loadImage)\n\n  /**\n   * Determines if the orientation requires a canvas element.\n   *\n   * @param {object} [options] Options object\n   * @param {boolean} [withMetaData] Is metadata required for orientation\n   * @returns {boolean} Returns true if orientation requires canvas/meta\n   */\n  function requiresCanvasOrientation(options, withMetaData) {\n    var orientation = options && options.orientation\n    return (\n      // Exif orientation for browsers without automatic image orientation:\n      (orientation === true && !loadImage.orientation) ||\n      // Orientation reset for browsers with automatic image orientation:\n      (orientation === 1 && loadImage.orientation) ||\n      // Orientation to defined value, requires meta for orientation reset only:\n      ((!withMetaData || loadImage.orientation) &&\n        orientation > 1 &&\n        orientation < 9)\n    )\n  }\n\n  /**\n   * Determines if the image requires an orientation change.\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if an orientation change is required\n   */\n  function requiresOrientationChange(orientation, autoOrientation) {\n    return (\n      orientation !== autoOrientation &&\n      ((orientation === 1 && autoOrientation > 1 && autoOrientation < 9) ||\n        (orientation > 1 && orientation < 9))\n    )\n  }\n\n  /**\n   * Determines orientation combinations that require a rotation by 180°.\n   *\n   * The following is a list of combinations that return true:\n   *\n   * 2 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   * 4 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   *\n   * 5 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   * 7 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   *\n   * 6 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   * 8 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if rotation by 180° is required\n   */\n  function requiresRot180(orientation, autoOrientation) {\n    if (autoOrientation > 1 && autoOrientation < 9) {\n      switch (orientation) {\n        case 2:\n        case 4:\n          return autoOrientation > 4\n        case 5:\n        case 7:\n          return autoOrientation % 2 === 0\n        case 6:\n        case 8:\n          return (\n            autoOrientation === 2 ||\n            autoOrientation === 4 ||\n            autoOrientation === 5 ||\n            autoOrientation === 7\n          )\n      }\n    }\n    return false\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return (\n      requiresCanvasOrientation(options) ||\n      originalRequiresCanvas.call(loadImage, options)\n    )\n  }\n\n  // Determines if metadata should be loaded automatically:\n  loadImage.requiresMetaData = function (options) {\n    return (\n      requiresCanvasOrientation(options, true) ||\n      originalRequiresMetaData.call(loadImage, options)\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      img,\n      options,\n      function (img, data) {\n        if (data) {\n          var autoOrientation =\n            loadImage.orientation && data.exif && data.exif.get('Orientation')\n          if (autoOrientation > 4 && autoOrientation < 9) {\n            // Automatic image orientation switched image dimensions\n            var originalWidth = data.originalWidth\n            var originalHeight = data.originalHeight\n            data.originalWidth = originalHeight\n            data.originalHeight = originalWidth\n          }\n        }\n        callback(img, data)\n      },\n      file,\n      data\n    )\n  }\n\n  // Transforms coordinate and dimension options\n  // based on the given orientation option:\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var exifOrientation = data.exif && data.exif.get('Orientation')\n    var orientation = options.orientation\n    var autoOrientation = loadImage.orientation && exifOrientation\n    if (orientation === true) orientation = exifOrientation\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return options\n    }\n    var top = options.top\n    var right = options.right\n    var bottom = options.bottom\n    var left = options.left\n    var newOptions = {}\n    for (var i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.orientation = orientation\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      newOptions.maxWidth = options.maxHeight\n      newOptions.maxHeight = options.maxWidth\n      newOptions.minWidth = options.minHeight\n      newOptions.minHeight = options.minWidth\n      newOptions.sourceWidth = options.sourceHeight\n      newOptions.sourceHeight = options.sourceWidth\n    }\n    if (autoOrientation > 1) {\n      // Browsers which correctly apply source image coordinates to\n      // auto-oriented images\n      switch (autoOrientation) {\n        case 2:\n          // Horizontal flip\n          right = options.left\n          left = options.right\n          break\n        case 3:\n          // 180° Rotate CCW\n          top = options.bottom\n          right = options.left\n          bottom = options.top\n          left = options.right\n          break\n        case 4:\n          // Vertical flip\n          top = options.bottom\n          bottom = options.top\n          break\n        case 5:\n          // Horizontal flip + 90° Rotate CCW\n          top = options.left\n          right = options.bottom\n          bottom = options.right\n          left = options.top\n          break\n        case 6:\n          // 90° Rotate CCW\n          top = options.left\n          right = options.top\n          bottom = options.right\n          left = options.bottom\n          break\n        case 7:\n          // Vertical flip + 90° Rotate CCW\n          top = options.right\n          right = options.top\n          bottom = options.left\n          left = options.bottom\n          break\n        case 8:\n          // 90° Rotate CW\n          top = options.right\n          right = options.bottom\n          bottom = options.left\n          left = options.top\n          break\n      }\n      // Some orientation combinations require additional rotation by 180°:\n      if (requiresRot180(orientation, autoOrientation)) {\n        var tmpTop = top\n        var tmpRight = right\n        top = bottom\n        right = left\n        bottom = tmpTop\n        left = tmpRight\n      }\n    }\n    newOptions.top = top\n    newOptions.right = right\n    newOptions.bottom = bottom\n    newOptions.left = left\n    // Account for defined browser orientation:\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        newOptions.right = left\n        newOptions.left = right\n        break\n      case 3:\n        // 180° Rotate CCW\n        newOptions.top = bottom\n        newOptions.right = left\n        newOptions.bottom = top\n        newOptions.left = right\n        break\n      case 4:\n        // Vertical flip\n        newOptions.top = bottom\n        newOptions.bottom = top\n        break\n      case 5:\n        // Vertical flip + 90° Rotate CW\n        newOptions.top = left\n        newOptions.right = bottom\n        newOptions.bottom = right\n        newOptions.left = top\n        break\n      case 6:\n        // 90° Rotate CW\n        newOptions.top = right\n        newOptions.right = bottom\n        newOptions.bottom = left\n        newOptions.left = top\n        break\n      case 7:\n        // Horizontal flip + 90° Rotate CW\n        newOptions.top = right\n        newOptions.right = top\n        newOptions.bottom = left\n        newOptions.left = bottom\n        break\n      case 8:\n        // 90° Rotate CCW\n        newOptions.top = left\n        newOptions.right = top\n        newOptions.bottom = right\n        newOptions.left = bottom\n        break\n    }\n    return newOptions\n  }\n\n  // Transform image orientation based on the given EXIF orientation option:\n  loadImage.transformCoordinates = function (canvas, options, data) {\n    originalTransformCoordinates.call(loadImage, canvas, options, data)\n    var orientation = options.orientation\n    var autoOrientation =\n      loadImage.orientation && data.exif && data.exif.get('Orientation')\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return\n    }\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var sourceWidth = width\n    var sourceHeight = height\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      canvas.width = height\n      canvas.height = width\n    }\n    if (orientation > 4) {\n      // Destination and source dimensions are switched\n      sourceWidth = height\n      sourceHeight = width\n    }\n    // Reset automatic browser orientation:\n    switch (autoOrientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(sourceWidth, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180° Rotate CCW\n        ctx.translate(sourceWidth, sourceHeight)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Horizontal flip + 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.scale(-1, 1)\n        break\n      case 6:\n        // 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, 0)\n        break\n      case 7:\n        // Vertical flip + 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 8:\n        // 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -sourceHeight)\n        break\n    }\n    // Some orientation combinations require additional rotation by 180°:\n    if (requiresRot180(orientation, autoOrientation)) {\n      ctx.translate(sourceWidth, sourceHeight)\n      ctx.rotate(Math.PI)\n    }\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(width, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180° Rotate CCW\n        ctx.translate(width, height)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, height)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Vertical flip + 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.scale(1, -1)\n        break\n      case 6:\n        // 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -height)\n        break\n      case 7:\n        // Horizontal flip + 90° Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(width, -height)\n        ctx.scale(-1, 1)\n        break\n      case 8:\n        // 90° Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-width, 0)\n        break\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utb3JpZW50YXRpb24uanM/NzliYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyw2RkFBYyxFQUFFLHlHQUFvQixFQUFFLHVHQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDaEYsR0FBRyxNQUFNLEVBU047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtbG9hZC1pbWFnZS9qcy9sb2FkLWltYWdlLW9yaWVudGF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTG9hZCBJbWFnZSBPcmllbnRhdGlvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1Mb2FkLUltYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qXG5FeGlmIG9yaWVudGF0aW9uIHZhbHVlcyB0byBjb3JyZWN0bHkgZGlzcGxheSB0aGUgbGV0dGVyIEY6XG5cbiAgICAxICAgICAgICAgICAgIDJcbiAg4paI4paI4paI4paI4paI4paIICAgICAgICDilojilojilojilojilojilohcbiAg4paI4paIICAgICAgICAgICAgICAgIOKWiOKWiFxuICDilojilojilojiloggICAgICAgICAgICDilojilojilojilohcbiAg4paI4paIICAgICAgICAgICAgICAgIOKWiOKWiFxuICDilojiloggICAgICAgICAgICAgICAg4paI4paIXG5cbiAgICAzICAgICAgICAgICAgIDRcbiAgICAgIOKWiOKWiCAgICAgICAg4paI4paIXG4gICAgICDilojiloggICAgICAgIOKWiOKWiFxuICAgIOKWiOKWiOKWiOKWiCAgICAgICAg4paI4paI4paI4paIXG4gICAgICDilojiloggICAgICAgIOKWiOKWiFxuICDilojilojilojilojilojiloggICAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiFxuXG4gICAgNSAgICAgICAgICAgICA2XG7ilojilojilojilojilojilojilojilojilojiloggICAg4paI4paIXG7ilojiloggIOKWiOKWiCAgICAgICAg4paI4paIICDilojilohcbuKWiOKWiCAgICAgICAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiFxuXG4gICAgNyAgICAgICAgICAgICA4XG4gICAgICAgIOKWiOKWiCAgICDilojilojilojilojilojilojilojilojilojilohcbiAgICDilojiloggIOKWiOKWiCAgICAgICAg4paI4paIICDilojilohcbuKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiCAgICAgICAgICAgIOKWiOKWiFxuXG4qL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZScsICcuL2xvYWQtaW1hZ2Utc2NhbGUnLCAnLi9sb2FkLWltYWdlLW1ldGEnXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSxcbiAgICAgIHJlcXVpcmUoJy4vbG9hZC1pbWFnZS1zY2FsZScpLFxuICAgICAgcmVxdWlyZSgnLi9sb2FkLWltYWdlLW1ldGEnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybSA9IGxvYWRJbWFnZS50cmFuc2Zvcm1cbiAgdmFyIG9yaWdpbmFsUmVxdWlyZXNDYW52YXMgPSBsb2FkSW1hZ2UucmVxdWlyZXNDYW52YXNcbiAgdmFyIG9yaWdpbmFsUmVxdWlyZXNNZXRhRGF0YSA9IGxvYWRJbWFnZS5yZXF1aXJlc01ldGFEYXRhXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybUNvb3JkaW5hdGVzID0gbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzXG4gIHZhciBvcmlnaW5hbEdldFRyYW5zZm9ybWVkT3B0aW9ucyA9IGxvYWRJbWFnZS5nZXRUcmFuc2Zvcm1lZE9wdGlvbnNcblxuICA7KGZ1bmN0aW9uICgkKSB7XG4gICAgLy8gR3VhcmQgZm9yIG5vbi1icm93c2VyIGVudmlyb25tZW50cyAoZS5nLiBzZXJ2ZXItc2lkZSByZW5kZXJpbmcpOlxuICAgIGlmICghJC5nbG9iYWwuZG9jdW1lbnQpIHJldHVyblxuICAgIC8vIGJsYWNrK3doaXRlIDN4MiBKUEVHLCB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0YSBpbmZvcm1hdGlvbiBzZXQ6XG4gICAgLy8gLSBFWElGIE9yaWVudGF0aW9uOiA2IChSb3RhdGVkIDkwwrAgQ0NXKVxuICAgIC8vIEltYWdlIGRhdGEgbGF5b3V0IChCPWJsYWNrLCBGPXdoaXRlKTpcbiAgICAvLyBCRkZcbiAgICAvLyBCQkJcbiAgICB2YXIgdGVzdEltYWdlVVJMID1cbiAgICAgICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80UUFpUlhocFpnQUFUVTBBS2dBQUFBZ0FBUUVTQUFNQUFBQUJBQVlBQUFBJyArXG4gICAgICAnQUFBRC8yd0NFQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQScgK1xuICAgICAgJ1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUUnICtcbiAgICAgICdCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFmL0FBQkVJQUFJQUF3TUJFUUFDRVFFREVRSC94JyArXG4gICAgICAnQUJSQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFLRUFFQkFRQURBUUVBQUFBQUFBQUFBQUFHQlFRRENBa0NCd0VCQUFBQUFBQScgK1xuICAgICAgJ0FBQUFBQUFBQUFBQUFBQkVCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUC9hQUF3REFRQUNFUU1SQUQ4QUc4VDlOZlNNRVZNaFEnICtcbiAgICAgICd2b1AzZkZpUlorTVRIRGlmYS85NU9GU1pVNU96Unp4a3llanY4Y2lFZmhTY2VTWEdqUzhlU2RMblpjMkhEbTRNM0J4Y1h3JyArXG4gICAgICAnSC85az0nXG4gICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1dG9tYXRpYyBpbWFnZSBvcmllbnRhdGlvbjpcbiAgICAgICQub3JpZW50YXRpb24gPSBpbWcud2lkdGggPT09IDIgJiYgaW1nLmhlaWdodCA9PT0gM1xuICAgICAgaWYgKCQub3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9ICQuY3JlYXRlQ2FudmFzKDEsIDEsIHRydWUpXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSlcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSBpbWFnZSBjb29yZGluYXRlcyAoc1gsIHNZLCBzV2lkdGgsIHNIZWlnaHQpIGFyZVxuICAgICAgICAvLyBjb3JyZWN0bHkgYXBwbGllZCB0byB0aGUgYXV0by1vcmllbnRhdGVkIGltYWdlLCB3aGljaCBzaG91bGQgcmVzdWx0XG4gICAgICAgIC8vIGluIGEgd2hpdGUgb3BhcXVlIHBpeGVsIChlLmcuIGluIFNhZmFyaSkuXG4gICAgICAgIC8vIEJyb3dzZXJzIHRoYXQgc2hvdyBhIHRyYW5zcGFyZW50IHBpeGVsIChlLmcuIENocm9taXVtKSBmYWlsIHRvIGNyb3BcbiAgICAgICAgLy8gYXV0by1vcmllbnRlZCBpbWFnZXMgY29ycmVjdGx5IGFuZCByZXF1aXJlIGEgd29ya2Fyb3VuZCwgZS5nLlxuICAgICAgICAvLyBkcmF3aW5nIHRoZSBjb21wbGV0ZSBzb3VyY2UgaW1hZ2UgdG8gYW4gaW50ZXJtZWRpYXRlIGNhbnZhcyBmaXJzdC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNzQzNTRcbiAgICAgICAgJC5vcmllbnRhdGlvbkNyb3BCdWcgPVxuICAgICAgICAgIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS50b1N0cmluZygpICE9PSAnMjU1LDI1NSwyNTUsMjU1J1xuICAgICAgfVxuICAgIH1cbiAgICBpbWcuc3JjID0gdGVzdEltYWdlVVJMXG4gIH0pKGxvYWRJbWFnZSlcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgb3JpZW50YXRpb24gcmVxdWlyZXMgYSBjYW52YXMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoTWV0YURhdGFdIElzIG1ldGFkYXRhIHJlcXVpcmVkIGZvciBvcmllbnRhdGlvblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG9yaWVudGF0aW9uIHJlcXVpcmVzIGNhbnZhcy9tZXRhXG4gICAqL1xuICBmdW5jdGlvbiByZXF1aXJlc0NhbnZhc09yaWVudGF0aW9uKG9wdGlvbnMsIHdpdGhNZXRhRGF0YSkge1xuICAgIHZhciBvcmllbnRhdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmllbnRhdGlvblxuICAgIHJldHVybiAoXG4gICAgICAvLyBFeGlmIG9yaWVudGF0aW9uIGZvciBicm93c2VycyB3aXRob3V0IGF1dG9tYXRpYyBpbWFnZSBvcmllbnRhdGlvbjpcbiAgICAgIChvcmllbnRhdGlvbiA9PT0gdHJ1ZSAmJiAhbG9hZEltYWdlLm9yaWVudGF0aW9uKSB8fFxuICAgICAgLy8gT3JpZW50YXRpb24gcmVzZXQgZm9yIGJyb3dzZXJzIHdpdGggYXV0b21hdGljIGltYWdlIG9yaWVudGF0aW9uOlxuICAgICAgKG9yaWVudGF0aW9uID09PSAxICYmIGxvYWRJbWFnZS5vcmllbnRhdGlvbikgfHxcbiAgICAgIC8vIE9yaWVudGF0aW9uIHRvIGRlZmluZWQgdmFsdWUsIHJlcXVpcmVzIG1ldGEgZm9yIG9yaWVudGF0aW9uIHJlc2V0IG9ubHk6XG4gICAgICAoKCF3aXRoTWV0YURhdGEgfHwgbG9hZEltYWdlLm9yaWVudGF0aW9uKSAmJlxuICAgICAgICBvcmllbnRhdGlvbiA+IDEgJiZcbiAgICAgICAgb3JpZW50YXRpb24gPCA5KVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbWFnZSByZXF1aXJlcyBhbiBvcmllbnRhdGlvbiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3JpZW50YXRpb25dIERlZmluZWQgb3JpZW50YXRpb24gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthdXRvT3JpZW50YXRpb25dIEF1dG8tb3JpZW50YXRpb24gYmFzZWQgb24gRXhpZiBkYXRhXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW4gb3JpZW50YXRpb24gY2hhbmdlIGlzIHJlcXVpcmVkXG4gICAqL1xuICBmdW5jdGlvbiByZXF1aXJlc09yaWVudGF0aW9uQ2hhbmdlKG9yaWVudGF0aW9uLCBhdXRvT3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgb3JpZW50YXRpb24gIT09IGF1dG9PcmllbnRhdGlvbiAmJlxuICAgICAgKChvcmllbnRhdGlvbiA9PT0gMSAmJiBhdXRvT3JpZW50YXRpb24gPiAxICYmIGF1dG9PcmllbnRhdGlvbiA8IDkpIHx8XG4gICAgICAgIChvcmllbnRhdGlvbiA+IDEgJiYgb3JpZW50YXRpb24gPCA5KSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBvcmllbnRhdGlvbiBjb21iaW5hdGlvbnMgdGhhdCByZXF1aXJlIGEgcm90YXRpb24gYnkgMTgwwrAuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIGNvbWJpbmF0aW9ucyB0aGF0IHJldHVybiB0cnVlOlxuICAgKlxuICAgKiAyIChmbGlwKSA9PiA1IChyb3Q5MCxmbGlwKSwgNyAocm90OTAsZmxpcCksIDYgKHJvdDkwKSwgOCAocm90OTApXG4gICAqIDQgKGZsaXApID0+IDUgKHJvdDkwLGZsaXApLCA3IChyb3Q5MCxmbGlwKSwgNiAocm90OTApLCA4IChyb3Q5MClcbiAgICpcbiAgICogNSAocm90OTAsZmxpcCkgPT4gMiAoZmxpcCksIDQgKGZsaXApLCA2IChyb3Q5MCksIDggKHJvdDkwKVxuICAgKiA3IChyb3Q5MCxmbGlwKSA9PiAyIChmbGlwKSwgNCAoZmxpcCksIDYgKHJvdDkwKSwgOCAocm90OTApXG4gICAqXG4gICAqIDYgKHJvdDkwKSA9PiAyIChmbGlwKSwgNCAoZmxpcCksIDUgKHJvdDkwLGZsaXApLCA3IChyb3Q5MCxmbGlwKVxuICAgKiA4IChyb3Q5MCkgPT4gMiAoZmxpcCksIDQgKGZsaXApLCA1IChyb3Q5MCxmbGlwKSwgNyAocm90OTAsZmxpcClcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcmllbnRhdGlvbl0gRGVmaW5lZCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2F1dG9PcmllbnRhdGlvbl0gQXV0by1vcmllbnRhdGlvbiBiYXNlZCBvbiBFeGlmIGRhdGFcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiByb3RhdGlvbiBieSAxODDCsCBpcyByZXF1aXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWlyZXNSb3QxODAob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikge1xuICAgIGlmIChhdXRvT3JpZW50YXRpb24gPiAxICYmIGF1dG9PcmllbnRhdGlvbiA8IDkpIHtcbiAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGF1dG9PcmllbnRhdGlvbiA+IDRcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIGF1dG9PcmllbnRhdGlvbiAlIDIgPT09IDBcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGF1dG9PcmllbnRhdGlvbiA9PT0gMiB8fFxuICAgICAgICAgICAgYXV0b09yaWVudGF0aW9uID09PSA0IHx8XG4gICAgICAgICAgICBhdXRvT3JpZW50YXRpb24gPT09IDUgfHxcbiAgICAgICAgICAgIGF1dG9PcmllbnRhdGlvbiA9PT0gN1xuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB0YXJnZXQgaW1hZ2Ugc2hvdWxkIGJlIGEgY2FudmFzIGVsZW1lbnQ6XG4gIGxvYWRJbWFnZS5yZXF1aXJlc0NhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlcXVpcmVzQ2FudmFzT3JpZW50YXRpb24ob3B0aW9ucykgfHxcbiAgICAgIG9yaWdpbmFsUmVxdWlyZXNDYW52YXMuY2FsbChsb2FkSW1hZ2UsIG9wdGlvbnMpXG4gICAgKVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiBtZXRhZGF0YSBzaG91bGQgYmUgbG9hZGVkIGF1dG9tYXRpY2FsbHk6XG4gIGxvYWRJbWFnZS5yZXF1aXJlc01ldGFEYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgcmVxdWlyZXNDYW52YXNPcmllbnRhdGlvbihvcHRpb25zLCB0cnVlKSB8fFxuICAgICAgb3JpZ2luYWxSZXF1aXJlc01ldGFEYXRhLmNhbGwobG9hZEltYWdlLCBvcHRpb25zKVxuICAgIClcbiAgfVxuXG4gIGxvYWRJbWFnZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBjYWxsYmFjaywgZmlsZSwgZGF0YSkge1xuICAgIG9yaWdpbmFsVHJhbnNmb3JtLmNhbGwoXG4gICAgICBsb2FkSW1hZ2UsXG4gICAgICBpbWcsXG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb24gKGltZywgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHZhciBhdXRvT3JpZW50YXRpb24gPVxuICAgICAgICAgICAgbG9hZEltYWdlLm9yaWVudGF0aW9uICYmIGRhdGEuZXhpZiAmJiBkYXRhLmV4aWYuZ2V0KCdPcmllbnRhdGlvbicpXG4gICAgICAgICAgaWYgKGF1dG9PcmllbnRhdGlvbiA+IDQgJiYgYXV0b09yaWVudGF0aW9uIDwgOSkge1xuICAgICAgICAgICAgLy8gQXV0b21hdGljIGltYWdlIG9yaWVudGF0aW9uIHN3aXRjaGVkIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFdpZHRoID0gZGF0YS5vcmlnaW5hbFdpZHRoXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxIZWlnaHQgPSBkYXRhLm9yaWdpbmFsSGVpZ2h0XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsV2lkdGggPSBvcmlnaW5hbEhlaWdodFxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEhlaWdodCA9IG9yaWdpbmFsV2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soaW1nLCBkYXRhKVxuICAgICAgfSxcbiAgICAgIGZpbGUsXG4gICAgICBkYXRhXG4gICAgKVxuICB9XG5cbiAgLy8gVHJhbnNmb3JtcyBjb29yZGluYXRlIGFuZCBkaW1lbnNpb24gb3B0aW9uc1xuICAvLyBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3JpZW50YXRpb24gb3B0aW9uOlxuICBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zID0gZnVuY3Rpb24gKGltZywgb3B0cywgZGF0YSkge1xuICAgIHZhciBvcHRpb25zID0gb3JpZ2luYWxHZXRUcmFuc2Zvcm1lZE9wdGlvbnMuY2FsbChsb2FkSW1hZ2UsIGltZywgb3B0cylcbiAgICB2YXIgZXhpZk9yaWVudGF0aW9uID0gZGF0YS5leGlmICYmIGRhdGEuZXhpZi5nZXQoJ09yaWVudGF0aW9uJylcbiAgICB2YXIgb3JpZW50YXRpb24gPSBvcHRpb25zLm9yaWVudGF0aW9uXG4gICAgdmFyIGF1dG9PcmllbnRhdGlvbiA9IGxvYWRJbWFnZS5vcmllbnRhdGlvbiAmJiBleGlmT3JpZW50YXRpb25cbiAgICBpZiAob3JpZW50YXRpb24gPT09IHRydWUpIG9yaWVudGF0aW9uID0gZXhpZk9yaWVudGF0aW9uXG4gICAgaWYgKCFyZXF1aXJlc09yaWVudGF0aW9uQ2hhbmdlKG9yaWVudGF0aW9uLCBhdXRvT3JpZW50YXRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uc1xuICAgIH1cbiAgICB2YXIgdG9wID0gb3B0aW9ucy50b3BcbiAgICB2YXIgcmlnaHQgPSBvcHRpb25zLnJpZ2h0XG4gICAgdmFyIGJvdHRvbSA9IG9wdGlvbnMuYm90dG9tXG4gICAgdmFyIGxlZnQgPSBvcHRpb25zLmxlZnRcbiAgICB2YXIgbmV3T3B0aW9ucyA9IHt9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgIG5ld09wdGlvbnNbaV0gPSBvcHRpb25zW2ldXG4gICAgICB9XG4gICAgfVxuICAgIG5ld09wdGlvbnMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvblxuICAgIGlmIChcbiAgICAgIChvcmllbnRhdGlvbiA+IDQgJiYgIShhdXRvT3JpZW50YXRpb24gPiA0KSkgfHxcbiAgICAgIChvcmllbnRhdGlvbiA8IDUgJiYgYXV0b09yaWVudGF0aW9uID4gNClcbiAgICApIHtcbiAgICAgIC8vIEltYWdlIGRpbWVuc2lvbnMgYW5kIHRhcmdldCBkaW1lbnNpb25zIGFyZSBzd2l0Y2hlZFxuICAgICAgbmV3T3B0aW9ucy5tYXhXaWR0aCA9IG9wdGlvbnMubWF4SGVpZ2h0XG4gICAgICBuZXdPcHRpb25zLm1heEhlaWdodCA9IG9wdGlvbnMubWF4V2lkdGhcbiAgICAgIG5ld09wdGlvbnMubWluV2lkdGggPSBvcHRpb25zLm1pbkhlaWdodFxuICAgICAgbmV3T3B0aW9ucy5taW5IZWlnaHQgPSBvcHRpb25zLm1pbldpZHRoXG4gICAgICBuZXdPcHRpb25zLnNvdXJjZVdpZHRoID0gb3B0aW9ucy5zb3VyY2VIZWlnaHRcbiAgICAgIG5ld09wdGlvbnMuc291cmNlSGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICAgIH1cbiAgICBpZiAoYXV0b09yaWVudGF0aW9uID4gMSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2hpY2ggY29ycmVjdGx5IGFwcGx5IHNvdXJjZSBpbWFnZSBjb29yZGluYXRlcyB0b1xuICAgICAgLy8gYXV0by1vcmllbnRlZCBpbWFnZXNcbiAgICAgIHN3aXRjaCAoYXV0b09yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXBcbiAgICAgICAgICByaWdodCA9IG9wdGlvbnMubGVmdFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIDE4MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICAgIHJpZ2h0ID0gb3B0aW9ucy5sZWZ0XG4gICAgICAgICAgYm90dG9tID0gb3B0aW9ucy50b3BcbiAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5yaWdodFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwXG4gICAgICAgICAgdG9wID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgICBib3R0b20gPSBvcHRpb25zLnRvcFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgICByaWdodCA9IG9wdGlvbnMuYm90dG9tXG4gICAgICAgICAgYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnRvcFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAvLyA5MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLmxlZnRcbiAgICAgICAgICByaWdodCA9IG9wdGlvbnMudG9wXG4gICAgICAgICAgYm90dG9tID0gb3B0aW9ucy5yaWdodFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwICsgOTDCsCBSb3RhdGUgQ0NXXG4gICAgICAgICAgdG9wID0gb3B0aW9ucy5yaWdodFxuICAgICAgICAgIHJpZ2h0ID0gb3B0aW9ucy50b3BcbiAgICAgICAgICBib3R0b20gPSBvcHRpb25zLmxlZnRcbiAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5ib3R0b21cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgLy8gOTDCsCBSb3RhdGUgQ1dcbiAgICAgICAgICB0b3AgPSBvcHRpb25zLnJpZ2h0XG4gICAgICAgICAgcmlnaHQgPSBvcHRpb25zLmJvdHRvbVxuICAgICAgICAgIGJvdHRvbSA9IG9wdGlvbnMubGVmdFxuICAgICAgICAgIGxlZnQgPSBvcHRpb25zLnRvcFxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICAvLyBTb21lIG9yaWVudGF0aW9uIGNvbWJpbmF0aW9ucyByZXF1aXJlIGFkZGl0aW9uYWwgcm90YXRpb24gYnkgMTgwwrA6XG4gICAgICBpZiAocmVxdWlyZXNSb3QxODAob3JpZW50YXRpb24sIGF1dG9PcmllbnRhdGlvbikpIHtcbiAgICAgICAgdmFyIHRtcFRvcCA9IHRvcFxuICAgICAgICB2YXIgdG1wUmlnaHQgPSByaWdodFxuICAgICAgICB0b3AgPSBib3R0b21cbiAgICAgICAgcmlnaHQgPSBsZWZ0XG4gICAgICAgIGJvdHRvbSA9IHRtcFRvcFxuICAgICAgICBsZWZ0ID0gdG1wUmlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3T3B0aW9ucy50b3AgPSB0b3BcbiAgICBuZXdPcHRpb25zLnJpZ2h0ID0gcmlnaHRcbiAgICBuZXdPcHRpb25zLmJvdHRvbSA9IGJvdHRvbVxuICAgIG5ld09wdGlvbnMubGVmdCA9IGxlZnRcbiAgICAvLyBBY2NvdW50IGZvciBkZWZpbmVkIGJyb3dzZXIgb3JpZW50YXRpb246XG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXBcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5sZWZ0ID0gcmlnaHRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gMTgwwrAgUm90YXRlIENDV1xuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IGJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLnJpZ2h0ID0gbGVmdFxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IHRvcFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSByaWdodFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0OlxuICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwXG4gICAgICAgIG5ld09wdGlvbnMudG9wID0gYm90dG9tXG4gICAgICAgIG5ld09wdGlvbnMuYm90dG9tID0gdG9wXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIFZlcnRpY2FsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IGxlZnRcbiAgICAgICAgbmV3T3B0aW9ucy5yaWdodCA9IGJvdHRvbVxuICAgICAgICBuZXdPcHRpb25zLmJvdHRvbSA9IHJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IHRvcFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA2OlxuICAgICAgICAvLyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IHJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMucmlnaHQgPSBib3R0b21cbiAgICAgICAgbmV3T3B0aW9ucy5ib3R0b20gPSBsZWZ0XG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IHRvcFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICBuZXdPcHRpb25zLnRvcCA9IHJpZ2h0XG4gICAgICAgIG5ld09wdGlvbnMucmlnaHQgPSB0b3BcbiAgICAgICAgbmV3T3B0aW9ucy5ib3R0b20gPSBsZWZ0XG4gICAgICAgIG5ld09wdGlvbnMubGVmdCA9IGJvdHRvbVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA4OlxuICAgICAgICAvLyA5MMKwIFJvdGF0ZSBDQ1dcbiAgICAgICAgbmV3T3B0aW9ucy50b3AgPSBsZWZ0XG4gICAgICAgIG5ld09wdGlvbnMucmlnaHQgPSB0b3BcbiAgICAgICAgbmV3T3B0aW9ucy5ib3R0b20gPSByaWdodFxuICAgICAgICBuZXdPcHRpb25zLmxlZnQgPSBib3R0b21cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnNcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBpbWFnZSBvcmllbnRhdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gRVhJRiBvcmllbnRhdGlvbiBvcHRpb246XG4gIGxvYWRJbWFnZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChjYW52YXMsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICBvcmlnaW5hbFRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwobG9hZEltYWdlLCBjYW52YXMsIG9wdGlvbnMsIGRhdGEpXG4gICAgdmFyIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvblxuICAgIHZhciBhdXRvT3JpZW50YXRpb24gPVxuICAgICAgbG9hZEltYWdlLm9yaWVudGF0aW9uICYmIGRhdGEuZXhpZiAmJiBkYXRhLmV4aWYuZ2V0KCdPcmllbnRhdGlvbicpXG4gICAgaWYgKCFyZXF1aXJlc09yaWVudGF0aW9uQ2hhbmdlKG9yaWVudGF0aW9uLCBhdXRvT3JpZW50YXRpb24pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB2YXIgc291cmNlV2lkdGggPSB3aWR0aFxuICAgIHZhciBzb3VyY2VIZWlnaHQgPSBoZWlnaHRcbiAgICBpZiAoXG4gICAgICAob3JpZW50YXRpb24gPiA0ICYmICEoYXV0b09yaWVudGF0aW9uID4gNCkpIHx8XG4gICAgICAob3JpZW50YXRpb24gPCA1ICYmIGF1dG9PcmllbnRhdGlvbiA+IDQpXG4gICAgKSB7XG4gICAgICAvLyBJbWFnZSBkaW1lbnNpb25zIGFuZCB0YXJnZXQgZGltZW5zaW9ucyBhcmUgc3dpdGNoZWRcbiAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodFxuICAgICAgY2FudmFzLmhlaWdodCA9IHdpZHRoXG4gICAgfVxuICAgIGlmIChvcmllbnRhdGlvbiA+IDQpIHtcbiAgICAgIC8vIERlc3RpbmF0aW9uIGFuZCBzb3VyY2UgZGltZW5zaW9ucyBhcmUgc3dpdGNoZWRcbiAgICAgIHNvdXJjZVdpZHRoID0gaGVpZ2h0XG4gICAgICBzb3VyY2VIZWlnaHQgPSB3aWR0aFxuICAgIH1cbiAgICAvLyBSZXNldCBhdXRvbWF0aWMgYnJvd3NlciBvcmllbnRhdGlvbjpcbiAgICBzd2l0Y2ggKGF1dG9PcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXBcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShzb3VyY2VXaWR0aCwgMClcbiAgICAgICAgY3R4LnNjYWxlKC0xLCAxKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyAxODDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC50cmFuc2xhdGUoc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodClcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0OlxuICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwXG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgc291cmNlSGVpZ2h0KVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDU6XG4gICAgICAgIC8vIEhvcml6b250YWwgZmxpcCArIDkwwrAgUm90YXRlIENDV1xuICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHguc2NhbGUoLTEsIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIDkwwrAgUm90YXRlIENDV1xuICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKC1zb3VyY2VXaWR0aCwgMClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gVmVydGljYWwgZmxpcCArIDkwwrAgUm90YXRlIENDV1xuICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHgudHJhbnNsYXRlKC1zb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDg6XG4gICAgICAgIC8vIDkwwrAgUm90YXRlIENXXG4gICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAtc291cmNlSGVpZ2h0KVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICAvLyBTb21lIG9yaWVudGF0aW9uIGNvbWJpbmF0aW9ucyByZXF1aXJlIGFkZGl0aW9uYWwgcm90YXRpb24gYnkgMTgwwrA6XG4gICAgaWYgKHJlcXVpcmVzUm90MTgwKG9yaWVudGF0aW9uLCBhdXRvT3JpZW50YXRpb24pKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpXG4gICAgICBjdHgucm90YXRlKE1hdGguUEkpXG4gICAgfVxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gSG9yaXpvbnRhbCBmbGlwXG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApXG4gICAgICAgIGN0eC5zY2FsZSgtMSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gMTgwwrAgUm90YXRlIENDV1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgLy8gVmVydGljYWwgZmxpcFxuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodClcbiAgICAgICAgY3R4LnNjYWxlKDEsIC0xKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA1OlxuICAgICAgICAvLyBWZXJ0aWNhbCBmbGlwICsgOTDCsCBSb3RhdGUgQ1dcbiAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKVxuICAgICAgICBjdHguc2NhbGUoMSwgLTEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIDkwwrAgUm90YXRlIENXXG4gICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSlcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBIb3Jpem9udGFsIGZsaXAgKyA5MMKwIFJvdGF0ZSBDV1xuICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIC1oZWlnaHQpXG4gICAgICAgIGN0eC5zY2FsZSgtMSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgLy8gOTDCsCBSb3RhdGUgQ0NXXG4gICAgICAgIGN0eC5yb3RhdGUoLTAuNSAqIE1hdGguUEkpXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoLCAwKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-orientation.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image-scale.js":
/*!****************************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image-scale.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./load-image */ \"./node_modules/blueimp-load-image/js/load-image.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n\n  loadImage.createCanvas = function (width, height, offscreen) {\n    if (offscreen && loadImage.global.OffscreenCanvas) {\n      return new OffscreenCanvas(width, height)\n    }\n    var canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      loadImage.scale(img, options, data),\n      options,\n      callback,\n      file,\n      data\n    )\n  }\n\n  // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options and data passed as arguments:\n  loadImage.transformCoordinates = function () {}\n\n  // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options, data passed as arguments:\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio\n      newOptions.maxHeight = height\n    } else {\n      newOptions.maxWidth = width\n      newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n  }\n\n  // Canvas render method, allows to implement a different rendering algorithm:\n  loadImage.drawImage = function (\n    img,\n    canvas,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destWidth,\n    destHeight,\n    options\n  ) {\n    var ctx = canvas.getContext('2d')\n    if (options.imageSmoothingEnabled === false) {\n      ctx.msImageSmoothingEnabled = false\n      ctx.imageSmoothingEnabled = false\n    } else if (options.imageSmoothingQuality) {\n      ctx.imageSmoothingQuality = options.imageSmoothingQuality\n    }\n    ctx.drawImage(\n      img,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      0,\n      0,\n      destWidth,\n      destHeight\n    )\n    return ctx\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n  }\n\n  // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options:\n  loadImage.scale = function (img, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var useCanvas =\n      img.getContext ||\n      (loadImage.requiresCanvas(options) &&\n        !!loadImage.global.HTMLCanvasElement)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    var canvas\n    /**\n     * Scales up image dimensions\n     */\n    function scaleUp() {\n      var scale = Math.max(\n        (minWidth || destWidth) / destWidth,\n        (minHeight || destHeight) / destHeight\n      )\n      if (scale > 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    /**\n     * Scales down image dimensions\n     */\n    function scaleDown() {\n      var scale = Math.min(\n        (maxWidth || destWidth) / destWidth,\n        (maxHeight || destHeight) / destHeight\n      )\n      if (scale < 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    if (useCanvas) {\n      // eslint-disable-next-line no-param-reassign\n      options = loadImage.getTransformedOptions(img, options, data)\n      sourceX = options.left || 0\n      sourceY = options.top || 0\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0)\n      }\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0)\n      }\n      destWidth = sourceWidth\n      destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth\n      destHeight = maxHeight\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n      if (tmp < 0) {\n        sourceHeight = (maxHeight * sourceWidth) / maxWidth\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2\n        }\n      } else if (tmp > 0) {\n        sourceWidth = (maxWidth * sourceHeight) / maxHeight\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth\n        minHeight = maxHeight = maxHeight || minHeight\n      }\n      if (options.cover) {\n        scaleDown()\n        scaleUp()\n      } else {\n        scaleUp()\n        scaleDown()\n      }\n    }\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio\n      if (\n        pixelRatio > 1 &&\n        // Check if the image has not yet had the device pixel ratio applied:\n        !(\n          img.style.width &&\n          Math.floor(parseFloat(img.style.width, 10)) ===\n            Math.floor(width / pixelRatio)\n        )\n      ) {\n        destWidth *= pixelRatio\n        destHeight *= pixelRatio\n      }\n      // Check if workaround for Chromium orientation crop bug is required:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n      if (\n        loadImage.orientationCropBug &&\n        !img.getContext &&\n        (sourceX || sourceY || sourceWidth !== width || sourceHeight !== height)\n      ) {\n        // Write the complete source image to an intermediate canvas first:\n        tmp = img\n        // eslint-disable-next-line no-param-reassign\n        img = loadImage.createCanvas(width, height, true)\n        loadImage.drawImage(\n          tmp,\n          img,\n          0,\n          0,\n          width,\n          height,\n          width,\n          height,\n          options\n        )\n      }\n      downsamplingRatio = options.downsamplingRatio\n      if (\n        downsamplingRatio > 0 &&\n        downsamplingRatio < 1 &&\n        destWidth < sourceWidth &&\n        destHeight < sourceHeight\n      ) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas = loadImage.createCanvas(\n            sourceWidth * downsamplingRatio,\n            sourceHeight * downsamplingRatio,\n            true\n          )\n          loadImage.drawImage(\n            img,\n            canvas,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            canvas.width,\n            canvas.height,\n            options\n          )\n          sourceX = 0\n          sourceY = 0\n          sourceWidth = canvas.width\n          sourceHeight = canvas.height\n          // eslint-disable-next-line no-param-reassign\n          img = canvas\n        }\n      }\n      canvas = loadImage.createCanvas(destWidth, destHeight)\n      loadImage.transformCoordinates(canvas, options, data)\n      if (pixelRatio > 1) {\n        canvas.style.width = canvas.width / pixelRatio + 'px'\n      }\n      loadImage\n        .drawImage(\n          img,\n          canvas,\n          sourceX,\n          sourceY,\n          sourceWidth,\n          sourceHeight,\n          destWidth,\n          destHeight,\n          options\n        )\n        .setTransform(1, 0, 0, 1, 0, 0) // reset to the identity matrix\n      return canvas\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanM/YTcyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLDZGQUFjLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUNyQyxHQUFHLE1BQU0sRUFLTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2Utc2NhbGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSmF2YVNjcmlwdCBMb2FkIEltYWdlIFNjYWxpbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCdcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBBTUQgbW9kdWxlOlxuICAgIGRlZmluZShbJy4vbG9hZC1pbWFnZSddLCBmYWN0b3J5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKCcuL2xvYWQtaW1hZ2UnKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHM6XG4gICAgZmFjdG9yeSh3aW5kb3cubG9hZEltYWdlKVxuICB9XG59KShmdW5jdGlvbiAobG9hZEltYWdlKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBvcmlnaW5hbFRyYW5zZm9ybSA9IGxvYWRJbWFnZS50cmFuc2Zvcm1cblxuICBsb2FkSW1hZ2UuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIG9mZnNjcmVlbikge1xuICAgIGlmIChvZmZzY3JlZW4gJiYgbG9hZEltYWdlLmdsb2JhbC5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgIHJldHVybiBjYW52YXNcbiAgfVxuXG4gIGxvYWRJbWFnZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBjYWxsYmFjaywgZmlsZSwgZGF0YSkge1xuICAgIG9yaWdpbmFsVHJhbnNmb3JtLmNhbGwoXG4gICAgICBsb2FkSW1hZ2UsXG4gICAgICBsb2FkSW1hZ2Uuc2NhbGUoaW1nLCBvcHRpb25zLCBkYXRhKSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGZpbGUsXG4gICAgICBkYXRhXG4gICAgKVxuICB9XG5cbiAgLy8gVHJhbnNmb3JtIGltYWdlIGNvb3JkaW5hdGVzLCBhbGxvd3MgdG8gb3ZlcnJpZGUgZS5nLlxuICAvLyB0aGUgY2FudmFzIG9yaWVudGF0aW9uIGJhc2VkIG9uIHRoZSBvcmllbnRhdGlvbiBvcHRpb24sXG4gIC8vIGdldHMgY2FudmFzLCBvcHRpb25zIGFuZCBkYXRhIHBhc3NlZCBhcyBhcmd1bWVudHM6XG4gIGxvYWRJbWFnZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgLy8gUmV0dXJucyB0cmFuc2Zvcm1lZCBvcHRpb25zLCBhbGxvd3MgdG8gb3ZlcnJpZGUgZS5nLlxuICAvLyBtYXhXaWR0aCwgbWF4SGVpZ2h0IGFuZCBjcm9wIG9wdGlvbnMgYmFzZWQgb24gdGhlIGFzcGVjdFJhdGlvLlxuICAvLyBnZXRzIGltZywgb3B0aW9ucywgZGF0YSBwYXNzZWQgYXMgYXJndW1lbnRzOlxuICBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zID0gZnVuY3Rpb24gKGltZywgb3B0aW9ucykge1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IG9wdGlvbnMuYXNwZWN0UmF0aW9cbiAgICB2YXIgbmV3T3B0aW9uc1xuICAgIHZhciBpXG4gICAgdmFyIHdpZHRoXG4gICAgdmFyIGhlaWdodFxuICAgIGlmICghYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBvcHRpb25zXG4gICAgfVxuICAgIG5ld09wdGlvbnMgPSB7fVxuICAgIGZvciAoaSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgIG5ld09wdGlvbnNbaV0gPSBvcHRpb25zW2ldXG4gICAgICB9XG4gICAgfVxuICAgIG5ld09wdGlvbnMuY3JvcCA9IHRydWVcbiAgICB3aWR0aCA9IGltZy5uYXR1cmFsV2lkdGggfHwgaW1nLndpZHRoXG4gICAgaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLmhlaWdodFxuICAgIGlmICh3aWR0aCAvIGhlaWdodCA+IGFzcGVjdFJhdGlvKSB7XG4gICAgICBuZXdPcHRpb25zLm1heFdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW9cbiAgICAgIG5ld09wdGlvbnMubWF4SGVpZ2h0ID0gaGVpZ2h0XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld09wdGlvbnMubWF4V2lkdGggPSB3aWR0aFxuICAgICAgbmV3T3B0aW9ucy5tYXhIZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvXG4gICAgfVxuICAgIHJldHVybiBuZXdPcHRpb25zXG4gIH1cblxuICAvLyBDYW52YXMgcmVuZGVyIG1ldGhvZCwgYWxsb3dzIHRvIGltcGxlbWVudCBhIGRpZmZlcmVudCByZW5kZXJpbmcgYWxnb3JpdGhtOlxuICBsb2FkSW1hZ2UuZHJhd0ltYWdlID0gZnVuY3Rpb24gKFxuICAgIGltZyxcbiAgICBjYW52YXMsXG4gICAgc291cmNlWCxcbiAgICBzb3VyY2VZLFxuICAgIHNvdXJjZVdpZHRoLFxuICAgIHNvdXJjZUhlaWdodCxcbiAgICBkZXN0V2lkdGgsXG4gICAgZGVzdEhlaWdodCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGlmIChvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlXG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW1hZ2VTbW9vdGhpbmdRdWFsaXR5KSB7XG4gICAgICBjdHguaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gb3B0aW9ucy5pbWFnZVNtb290aGluZ1F1YWxpdHlcbiAgICB9XG4gICAgY3R4LmRyYXdJbWFnZShcbiAgICAgIGltZyxcbiAgICAgIHNvdXJjZVgsXG4gICAgICBzb3VyY2VZLFxuICAgICAgc291cmNlV2lkdGgsXG4gICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGRlc3RXaWR0aCxcbiAgICAgIGRlc3RIZWlnaHRcbiAgICApXG4gICAgcmV0dXJuIGN0eFxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdGFyZ2V0IGltYWdlIHNob3VsZCBiZSBhIGNhbnZhcyBlbGVtZW50OlxuICBsb2FkSW1hZ2UucmVxdWlyZXNDYW52YXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmNhbnZhcyB8fCBvcHRpb25zLmNyb3AgfHwgISFvcHRpb25zLmFzcGVjdFJhdGlvXG4gIH1cblxuICAvLyBTY2FsZXMgYW5kL29yIGNyb3BzIHRoZSBnaXZlbiBpbWFnZSAoaW1nIG9yIGNhbnZhcyBIVE1MIGVsZW1lbnQpXG4gIC8vIHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zOlxuICBsb2FkSW1hZ2Uuc2NhbGUgPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBkYXRhID0gZGF0YSB8fCB7fVxuICAgIHZhciB1c2VDYW52YXMgPVxuICAgICAgaW1nLmdldENvbnRleHQgfHxcbiAgICAgIChsb2FkSW1hZ2UucmVxdWlyZXNDYW52YXMob3B0aW9ucykgJiZcbiAgICAgICAgISFsb2FkSW1hZ2UuZ2xvYmFsLkhUTUxDYW52YXNFbGVtZW50KVxuICAgIHZhciB3aWR0aCA9IGltZy5uYXR1cmFsV2lkdGggfHwgaW1nLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHRcbiAgICB2YXIgZGVzdFdpZHRoID0gd2lkdGhcbiAgICB2YXIgZGVzdEhlaWdodCA9IGhlaWdodFxuICAgIHZhciBtYXhXaWR0aFxuICAgIHZhciBtYXhIZWlnaHRcbiAgICB2YXIgbWluV2lkdGhcbiAgICB2YXIgbWluSGVpZ2h0XG4gICAgdmFyIHNvdXJjZVdpZHRoXG4gICAgdmFyIHNvdXJjZUhlaWdodFxuICAgIHZhciBzb3VyY2VYXG4gICAgdmFyIHNvdXJjZVlcbiAgICB2YXIgcGl4ZWxSYXRpb1xuICAgIHZhciBkb3duc2FtcGxpbmdSYXRpb1xuICAgIHZhciB0bXBcbiAgICB2YXIgY2FudmFzXG4gICAgLyoqXG4gICAgICogU2NhbGVzIHVwIGltYWdlIGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsZVVwKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoXG4gICAgICAgIChtaW5XaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWluSGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlID4gMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgZG93biBpbWFnZSBkaW1lbnNpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGVEb3duKCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4oXG4gICAgICAgIChtYXhXaWR0aCB8fCBkZXN0V2lkdGgpIC8gZGVzdFdpZHRoLFxuICAgICAgICAobWF4SGVpZ2h0IHx8IGRlc3RIZWlnaHQpIC8gZGVzdEhlaWdodFxuICAgICAgKVxuICAgICAgaWYgKHNjYWxlIDwgMSkge1xuICAgICAgICBkZXN0V2lkdGggKj0gc2NhbGVcbiAgICAgICAgZGVzdEhlaWdodCAqPSBzY2FsZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlQ2FudmFzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG9wdGlvbnMgPSBsb2FkSW1hZ2UuZ2V0VHJhbnNmb3JtZWRPcHRpb25zKGltZywgb3B0aW9ucywgZGF0YSlcbiAgICAgIHNvdXJjZVggPSBvcHRpb25zLmxlZnQgfHwgMFxuICAgICAgc291cmNlWSA9IG9wdGlvbnMudG9wIHx8IDBcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9IHdpZHRoIC0gc291cmNlV2lkdGggLSBvcHRpb25zLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gd2lkdGggLSBzb3VyY2VYIC0gKG9wdGlvbnMucmlnaHQgfHwgMClcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZUhlaWdodCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5ib3R0b20gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWSA9IGhlaWdodCAtIHNvdXJjZUhlaWdodCAtIG9wdGlvbnMuYm90dG9tXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUhlaWdodCA9IGhlaWdodCAtIHNvdXJjZVkgLSAob3B0aW9ucy5ib3R0b20gfHwgMClcbiAgICAgIH1cbiAgICAgIGRlc3RXaWR0aCA9IHNvdXJjZVdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gc291cmNlSGVpZ2h0XG4gICAgfVxuICAgIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aFxuICAgIG1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0XG4gICAgbWluV2lkdGggPSBvcHRpb25zLm1pbldpZHRoXG4gICAgbWluSGVpZ2h0ID0gb3B0aW9ucy5taW5IZWlnaHRcbiAgICBpZiAodXNlQ2FudmFzICYmIG1heFdpZHRoICYmIG1heEhlaWdodCAmJiBvcHRpb25zLmNyb3ApIHtcbiAgICAgIGRlc3RXaWR0aCA9IG1heFdpZHRoXG4gICAgICBkZXN0SGVpZ2h0ID0gbWF4SGVpZ2h0XG4gICAgICB0bXAgPSBzb3VyY2VXaWR0aCAvIHNvdXJjZUhlaWdodCAtIG1heFdpZHRoIC8gbWF4SGVpZ2h0XG4gICAgICBpZiAodG1wIDwgMCkge1xuICAgICAgICBzb3VyY2VIZWlnaHQgPSAobWF4SGVpZ2h0ICogc291cmNlV2lkdGgpIC8gbWF4V2lkdGhcbiAgICAgICAgaWYgKG9wdGlvbnMudG9wID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5ib3R0b20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNvdXJjZVkgPSAoaGVpZ2h0IC0gc291cmNlSGVpZ2h0KSAvIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0bXAgPiAwKSB7XG4gICAgICAgIHNvdXJjZVdpZHRoID0gKG1heFdpZHRoICogc291cmNlSGVpZ2h0KSAvIG1heEhlaWdodFxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc291cmNlWCA9ICh3aWR0aCAtIHNvdXJjZVdpZHRoKSAvIDJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluIHx8IG9wdGlvbnMuY292ZXIpIHtcbiAgICAgICAgbWluV2lkdGggPSBtYXhXaWR0aCA9IG1heFdpZHRoIHx8IG1pbldpZHRoXG4gICAgICAgIG1pbkhlaWdodCA9IG1heEhlaWdodCA9IG1heEhlaWdodCB8fCBtaW5IZWlnaHRcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICAgIHNjYWxlVXAoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVVcCgpXG4gICAgICAgIHNjYWxlRG93bigpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VDYW52YXMpIHtcbiAgICAgIHBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW9cbiAgICAgIGlmIChcbiAgICAgICAgcGl4ZWxSYXRpbyA+IDEgJiZcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGhhcyBub3QgeWV0IGhhZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIGFwcGxpZWQ6XG4gICAgICAgICEoXG4gICAgICAgICAgaW1nLnN0eWxlLndpZHRoICYmXG4gICAgICAgICAgTWF0aC5mbG9vcihwYXJzZUZsb2F0KGltZy5zdHlsZS53aWR0aCwgMTApKSA9PT1cbiAgICAgICAgICAgIE1hdGguZmxvb3Iod2lkdGggLyBwaXhlbFJhdGlvKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgZGVzdFdpZHRoICo9IHBpeGVsUmF0aW9cbiAgICAgICAgZGVzdEhlaWdodCAqPSBwaXhlbFJhdGlvXG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB3b3JrYXJvdW5kIGZvciBDaHJvbWl1bSBvcmllbnRhdGlvbiBjcm9wIGJ1ZyBpcyByZXF1aXJlZDpcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNzQzNTRcbiAgICAgIGlmIChcbiAgICAgICAgbG9hZEltYWdlLm9yaWVudGF0aW9uQ3JvcEJ1ZyAmJlxuICAgICAgICAhaW1nLmdldENvbnRleHQgJiZcbiAgICAgICAgKHNvdXJjZVggfHwgc291cmNlWSB8fCBzb3VyY2VXaWR0aCAhPT0gd2lkdGggfHwgc291cmNlSGVpZ2h0ICE9PSBoZWlnaHQpXG4gICAgICApIHtcbiAgICAgICAgLy8gV3JpdGUgdGhlIGNvbXBsZXRlIHNvdXJjZSBpbWFnZSB0byBhbiBpbnRlcm1lZGlhdGUgY2FudmFzIGZpcnN0OlxuICAgICAgICB0bXAgPSBpbWdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGltZyA9IGxvYWRJbWFnZS5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCwgdHJ1ZSlcbiAgICAgICAgbG9hZEltYWdlLmRyYXdJbWFnZShcbiAgICAgICAgICB0bXAsXG4gICAgICAgICAgaW1nLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZG93bnNhbXBsaW5nUmF0aW8gPSBvcHRpb25zLmRvd25zYW1wbGluZ1JhdGlvXG4gICAgICBpZiAoXG4gICAgICAgIGRvd25zYW1wbGluZ1JhdGlvID4gMCAmJlxuICAgICAgICBkb3duc2FtcGxpbmdSYXRpbyA8IDEgJiZcbiAgICAgICAgZGVzdFdpZHRoIDwgc291cmNlV2lkdGggJiZcbiAgICAgICAgZGVzdEhlaWdodCA8IHNvdXJjZUhlaWdodFxuICAgICAgKSB7XG4gICAgICAgIHdoaWxlIChzb3VyY2VXaWR0aCAqIGRvd25zYW1wbGluZ1JhdGlvID4gZGVzdFdpZHRoKSB7XG4gICAgICAgICAgY2FudmFzID0gbG9hZEltYWdlLmNyZWF0ZUNhbnZhcyhcbiAgICAgICAgICAgIHNvdXJjZVdpZHRoICogZG93bnNhbXBsaW5nUmF0aW8sXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQgKiBkb3duc2FtcGxpbmdSYXRpbyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApXG4gICAgICAgICAgbG9hZEltYWdlLmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgICBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIClcbiAgICAgICAgICBzb3VyY2VYID0gMFxuICAgICAgICAgIHNvdXJjZVkgPSAwXG4gICAgICAgICAgc291cmNlV2lkdGggPSBjYW52YXMud2lkdGhcbiAgICAgICAgICBzb3VyY2VIZWlnaHQgPSBjYW52YXMuaGVpZ2h0XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgaW1nID0gY2FudmFzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGxvYWRJbWFnZS5jcmVhdGVDYW52YXMoZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KVxuICAgICAgbG9hZEltYWdlLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGNhbnZhcywgb3B0aW9ucywgZGF0YSlcbiAgICAgIGlmIChwaXhlbFJhdGlvID4gMSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjYW52YXMud2lkdGggLyBwaXhlbFJhdGlvICsgJ3B4J1xuICAgICAgfVxuICAgICAgbG9hZEltYWdlXG4gICAgICAgIC5kcmF3SW1hZ2UoXG4gICAgICAgICAgaW1nLFxuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgICAgIGRlc3RXaWR0aCxcbiAgICAgICAgICBkZXN0SGVpZ2h0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgICAuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApIC8vIHJlc2V0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAgICAgIHJldHVybiBjYW52YXNcbiAgICB9XG4gICAgaW1nLndpZHRoID0gZGVzdFdpZHRoXG4gICAgaW1nLmhlaWdodCA9IGRlc3RIZWlnaHRcbiAgICByZXR1cm4gaW1nXG4gIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image-scale.js\n");

/***/ }),

/***/ "./node_modules/blueimp-load-image/js/load-image.js":
/*!**********************************************************!*\
  !*** ./node_modules/blueimp-load-image/js/load-image.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, Promise */\n\n;(function ($) {\n  'use strict'\n\n  var urlAPI = $.URL || $.webkitURL\n\n  /**\n   * Creates an object URL for a given File object.\n   *\n   * @param {Blob} blob Blob object\n   * @returns {string|boolean} Returns object URL if API exists, else false.\n   */\n  function createObjectURL(blob) {\n    return urlAPI ? urlAPI.createObjectURL(blob) : false\n  }\n\n  /**\n   * Revokes a given object URL.\n   *\n   * @param {string} url Blob object URL\n   * @returns {undefined|boolean} Returns undefined if API exists, else false.\n   */\n  function revokeObjectURL(url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n  }\n\n  /**\n   * Helper function to revoke an object URL\n   *\n   * @param {string} url Blob Object URL\n   * @param {object} [options] Options object\n   */\n  function revokeHelper(url, options) {\n    if (url && url.slice(0, 5) === 'blob:' && !(options && options.noRevoke)) {\n      revokeObjectURL(url)\n    }\n  }\n\n  /**\n   * Loads a given File object via FileReader interface.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} onload Load event callback\n   * @param {Function} [onerror] Error/Abort event callback\n   * @param {string} [method=readAsDataURL] FileReader method\n   * @returns {FileReader|boolean} Returns FileReader if API exists, else false.\n   */\n  function readFile(file, onload, onerror, method) {\n    if (!$.FileReader) return false\n    var reader = new FileReader()\n    reader.onload = function () {\n      onload.call(reader, this.result)\n    }\n    if (onerror) {\n      reader.onabort = reader.onerror = function () {\n        onerror.call(reader, this.error)\n      }\n    }\n    var readerMethod = reader[method || 'readAsDataURL']\n    if (readerMethod) {\n      readerMethod.call(reader, file)\n      return reader\n    }\n  }\n\n  /**\n   * Cross-frame instanceof check.\n   *\n   * @param {string} type Instance type\n   * @param {object} obj Object instance\n   * @returns {boolean} Returns true if the object is of the given instance.\n   */\n  function isInstanceOf(type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n  }\n\n  /**\n   * @typedef { HTMLImageElement|HTMLCanvasElement } Result\n   */\n\n  /**\n   * Loads an image for a given File object.\n   *\n   * @param {Blob|string} file Blob object or image URL\n   * @param {Function|object} [callback] Image load event callback or options\n   * @param {object} [options] Options object\n   * @returns {HTMLImageElement|FileReader|Promise<Result>} Object\n   */\n  function loadImage(file, callback, options) {\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {HTMLImageElement|FileReader} Object\n     */\n    function executor(resolve, reject) {\n      var img = document.createElement('img')\n      var url\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {HTMLImageElement|HTMLCanvasElement} img Error object\n       * @param {object} data Data object\n       * @returns {undefined} Undefined\n       */\n      function resolveWrapper(img, data) {\n        if (resolve === reject) {\n          // Not using Promises\n          if (resolve) resolve(img, data)\n          return\n        } else if (img instanceof Error) {\n          reject(img)\n          return\n        }\n        data = data || {} // eslint-disable-line no-param-reassign\n        data.image = img\n        resolve(data)\n      }\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {Blob} blob Blob object\n       * @param {Error} err Error object\n       */\n      function fetchBlobCallback(blob, err) {\n        if (err && $.console) console.log(err) // eslint-disable-line no-console\n        if (blob && isInstanceOf('Blob', blob)) {\n          file = blob // eslint-disable-line no-param-reassign\n          url = createObjectURL(file)\n        } else {\n          url = file\n          if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin\n          }\n        }\n        img.src = url\n      }\n      img.onerror = function (event) {\n        revokeHelper(url, options)\n        if (reject) reject.call(img, event)\n      }\n      img.onload = function () {\n        revokeHelper(url, options)\n        var data = {\n          originalWidth: img.naturalWidth || img.width,\n          originalHeight: img.naturalHeight || img.height\n        }\n        try {\n          loadImage.transform(img, options, resolveWrapper, file, data)\n        } catch (error) {\n          if (reject) reject(error)\n        }\n      }\n      if (typeof file === 'string') {\n        if (loadImage.requiresMetaData(options)) {\n          loadImage.fetchBlob(file, fetchBlobCallback, options)\n        } else {\n          fetchBlobCallback()\n        }\n        return img\n      } else if (isInstanceOf('Blob', file) || isInstanceOf('File', file)) {\n        url = createObjectURL(file)\n        if (url) {\n          img.src = url\n          return img\n        }\n        return readFile(\n          file,\n          function (url) {\n            img.src = url\n          },\n          reject\n        )\n      }\n    }\n    if ($.Promise && typeof callback !== 'function') {\n      options = callback // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    return executor(callback, callback)\n  }\n\n  // Determines if metadata should be loaded automatically.\n  // Requires the load image meta extension to load metadata.\n  loadImage.requiresMetaData = function (options) {\n    return options && options.meta\n  }\n\n  // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n  loadImage.fetchBlob = function (url, callback) {\n    callback()\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data)\n  }\n\n  loadImage.global = $\n  loadImage.readFile = readFile\n  loadImage.isInstanceOf = isInstanceOf\n  loadImage.createObjectURL = createObjectURL\n  loadImage.revokeObjectURL = revokeObjectURL\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return loadImage\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})((typeof window !== 'undefined' && window) || this)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1sb2FkLWltYWdlL2pzL2xvYWQtaW1hZ2UuanM/MDliNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsT0FBTztBQUNwQixlQUFlLDRDQUE0QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRCxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQTBDO0FBQ2hELElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOLEdBQUcsTUFBTSxFQUlOO0FBQ0gsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibHVlaW1wLWxvYWQtaW1hZ2UvanMvbG9hZC1pbWFnZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKYXZhU2NyaXB0IExvYWQgSW1hZ2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTG9hZC1JbWFnZVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIFByb21pc2UgKi9cblxuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgdXJsQVBJID0gJC5VUkwgfHwgJC53ZWJraXRVUkxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgVVJMIGZvciBhIGdpdmVuIEZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICogQHJldHVybnMge3N0cmluZ3xib29sZWFufSBSZXR1cm5zIG9iamVjdCBVUkwgaWYgQVBJIGV4aXN0cywgZWxzZSBmYWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChibG9iKSB7XG4gICAgcmV0dXJuIHVybEFQSSA/IHVybEFQSS5jcmVhdGVPYmplY3RVUkwoYmxvYikgOiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldm9rZXMgYSBnaXZlbiBvYmplY3QgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIEJsb2Igb2JqZWN0IFVSTFxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IFJldHVybnMgdW5kZWZpbmVkIGlmIEFQSSBleGlzdHMsIGVsc2UgZmFsc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybEFQSSA/IHVybEFQSS5yZXZva2VPYmplY3RVUkwodXJsKSA6IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHJldm9rZSBhbiBvYmplY3QgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgQmxvYiBPYmplY3QgVVJMXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIHJldm9rZUhlbHBlcih1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAodXJsICYmIHVybC5zbGljZSgwLCA1KSA9PT0gJ2Jsb2I6JyAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Jldm9rZSkpIHtcbiAgICAgIHJldm9rZU9iamVjdFVSTCh1cmwpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgZ2l2ZW4gRmlsZSBvYmplY3QgdmlhIEZpbGVSZWFkZXIgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGZpbGUgQmxvYiBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIExvYWQgZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uZXJyb3JdIEVycm9yL0Fib3J0IGV2ZW50IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPXJlYWRBc0RhdGFVUkxdIEZpbGVSZWFkZXIgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtGaWxlUmVhZGVyfGJvb2xlYW59IFJldHVybnMgRmlsZVJlYWRlciBpZiBBUEkgZXhpc3RzLCBlbHNlIGZhbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZSwgb25sb2FkLCBvbmVycm9yLCBtZXRob2QpIHtcbiAgICBpZiAoISQuRmlsZVJlYWRlcikgcmV0dXJuIGZhbHNlXG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgb25sb2FkLmNhbGwocmVhZGVyLCB0aGlzLnJlc3VsdClcbiAgICB9XG4gICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgIHJlYWRlci5vbmFib3J0ID0gcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uZXJyb3IuY2FsbChyZWFkZXIsIHRoaXMuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZWFkZXJNZXRob2QgPSByZWFkZXJbbWV0aG9kIHx8ICdyZWFkQXNEYXRhVVJMJ11cbiAgICBpZiAocmVhZGVyTWV0aG9kKSB7XG4gICAgICByZWFkZXJNZXRob2QuY2FsbChyZWFkZXIsIGZpbGUpXG4gICAgICByZXR1cm4gcmVhZGVyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyb3NzLWZyYW1lIGluc3RhbmNlb2YgY2hlY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEluc3RhbmNlIHR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgaW5zdGFuY2VcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbiBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzSW5zdGFuY2VPZih0eXBlLCBvYmopIHtcbiAgICAvLyBDcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGNoZWNrXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJ1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudCB9IFJlc3VsdFxuICAgKi9cblxuICAvKipcbiAgICogTG9hZHMgYW4gaW1hZ2UgZm9yIGEgZ2l2ZW4gRmlsZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYnxzdHJpbmd9IGZpbGUgQmxvYiBvYmplY3Qgb3IgaW1hZ2UgVVJMXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258b2JqZWN0fSBbY2FsbGJhY2tdIEltYWdlIGxvYWQgZXZlbnQgY2FsbGJhY2sgb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fEZpbGVSZWFkZXJ8UHJvbWlzZTxSZXN1bHQ+fSBPYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRJbWFnZShmaWxlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIFByb21pc2UgZXhlY3V0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgUmVzb2x1dGlvbiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBSZWplY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudHxGaWxlUmVhZGVyfSBPYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgdmFyIHVybFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayBmb3IgdGhlIGZldGNoQmxvYiBjYWxsLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gaW1nIEVycm9yIG9iamVjdFxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFVuZGVmaW5lZFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlV3JhcHBlcihpbWcsIGRhdGEpIHtcbiAgICAgICAgaWYgKHJlc29sdmUgPT09IHJlamVjdCkge1xuICAgICAgICAgIC8vIE5vdCB1c2luZyBQcm9taXNlc1xuICAgICAgICAgIGlmIChyZXNvbHZlKSByZXNvbHZlKGltZywgZGF0YSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmIChpbWcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJlamVjdChpbWcpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBkYXRhLmltYWdlID0gaW1nXG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgZm9yIHRoZSBmZXRjaEJsb2IgY2FsbC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgQmxvYiBvYmplY3RcbiAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBFcnJvciBvYmplY3RcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmV0Y2hCbG9iQ2FsbGJhY2soYmxvYiwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgJC5jb25zb2xlKSBjb25zb2xlLmxvZyhlcnIpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBpZiAoYmxvYiAmJiBpc0luc3RhbmNlT2YoJ0Jsb2InLCBibG9iKSkge1xuICAgICAgICAgIGZpbGUgPSBibG9iIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwgPSBmaWxlXG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbWcuc3JjID0gdXJsXG4gICAgICB9XG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXZva2VIZWxwZXIodXJsLCBvcHRpb25zKVxuICAgICAgICBpZiAocmVqZWN0KSByZWplY3QuY2FsbChpbWcsIGV2ZW50KVxuICAgICAgfVxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV2b2tlSGVscGVyKHVybCwgb3B0aW9ucylcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgb3JpZ2luYWxXaWR0aDogaW1nLm5hdHVyYWxXaWR0aCB8fCBpbWcud2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IGltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRJbWFnZS50cmFuc2Zvcm0oaW1nLCBvcHRpb25zLCByZXNvbHZlV3JhcHBlciwgZmlsZSwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVqZWN0KSByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGxvYWRJbWFnZS5yZXF1aXJlc01ldGFEYXRhKG9wdGlvbnMpKSB7XG4gICAgICAgICAgbG9hZEltYWdlLmZldGNoQmxvYihmaWxlLCBmZXRjaEJsb2JDYWxsYmFjaywgb3B0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaEJsb2JDYWxsYmFjaygpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltZ1xuICAgICAgfSBlbHNlIGlmIChpc0luc3RhbmNlT2YoJ0Jsb2InLCBmaWxlKSB8fCBpc0luc3RhbmNlT2YoJ0ZpbGUnLCBmaWxlKSkge1xuICAgICAgICB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZmlsZSlcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIGltZy5zcmMgPSB1cmxcbiAgICAgICAgICByZXR1cm4gaW1nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlKFxuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCQuUHJvbWlzZSAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBjYWxsYmFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuICAgIHJldHVybiBleGVjdXRvcihjYWxsYmFjaywgY2FsbGJhY2spXG4gIH1cblxuICAvLyBEZXRlcm1pbmVzIGlmIG1ldGFkYXRhIHNob3VsZCBiZSBsb2FkZWQgYXV0b21hdGljYWxseS5cbiAgLy8gUmVxdWlyZXMgdGhlIGxvYWQgaW1hZ2UgbWV0YSBleHRlbnNpb24gdG8gbG9hZCBtZXRhZGF0YS5cbiAgbG9hZEltYWdlLnJlcXVpcmVzTWV0YURhdGEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubWV0YVxuICB9XG5cbiAgLy8gSWYgdGhlIGNhbGxiYWNrIGdpdmVuIHRvIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGJsb2IsIGl0IGlzIHVzZWQgYXMgaW1hZ2VcbiAgLy8gc291cmNlIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHVybCBhbmQgb3ZlcnJpZGVzIHRoZSBmaWxlIGFyZ3VtZW50IHVzZWQgaW5cbiAgLy8gdGhlIG9ubG9hZCBhbmQgb25lcnJvciBldmVudCBjYWxsYmFja3M6XG4gIGxvYWRJbWFnZS5mZXRjaEJsb2IgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGxvYWRJbWFnZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW1nLCBvcHRpb25zLCBjYWxsYmFjaywgZmlsZSwgZGF0YSkge1xuICAgIGNhbGxiYWNrKGltZywgZGF0YSlcbiAgfVxuXG4gIGxvYWRJbWFnZS5nbG9iYWwgPSAkXG4gIGxvYWRJbWFnZS5yZWFkRmlsZSA9IHJlYWRGaWxlXG4gIGxvYWRJbWFnZS5pc0luc3RhbmNlT2YgPSBpc0luc3RhbmNlT2ZcbiAgbG9hZEltYWdlLmNyZWF0ZU9iamVjdFVSTCA9IGNyZWF0ZU9iamVjdFVSTFxuICBsb2FkSW1hZ2UucmV2b2tlT2JqZWN0VVJMID0gcmV2b2tlT2JqZWN0VVJMXG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9hZEltYWdlXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbG9hZEltYWdlXG4gIH0gZWxzZSB7XG4gICAgJC5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2VcbiAgfVxufSkoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdykgfHwgdGhpcylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blueimp-load-image/js/load-image.js\n");

/***/ }),

/***/ "./node_modules/croppr/dist/croppr.js":
/*!********************************************!*\
  !*** ./node_modules/croppr/dist/croppr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Croppr.js\n * https://github.com/jamesssooi/Croppr.js\n * \n * A JavaScript image cropper that's lightweight, awesome, and has\n * zero dependencies.\n * \n * (C) 2017 James Ooi. Released under the MIT License.\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n(function () {\n  if (typeof window.CustomEvent === \"function\") return false;\n  function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n})();\n(function (window) {\n  try {\n    new CustomEvent('test');\n    return false;\n  } catch (e) {}\n  function MouseEvent(eventType, params) {\n    params = params || { bubbles: false, cancelable: false };\n    var mouseEvent = document.createEvent('MouseEvent');\n    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    return mouseEvent;\n  }\n  MouseEvent.prototype = Event.prototype;\n  window.MouseEvent = MouseEvent;\n})(window);\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar Handle =\n/**\n * Creates a new Handle instance.\n * @constructor\n * @param {Array} position The x and y ratio position of the handle\n *      within the crop region. Accepts a value between 0 to 1 in the order\n *      of [X, Y].\n * @param {Array} constraints Define the side of the crop region that\n *      is to be affected by this handle. Accepts a value of 0 or 1 in the\n *      order of [TOP, RIGHT, BOTTOM, LEFT].\n * @param {String} cursor The CSS cursor of this handle.\n * @param {Element} eventBus The element to dispatch events to.\n */\nfunction Handle(position, constraints, cursor, eventBus) {\n  classCallCheck(this, Handle);\n  var self = this;\n  this.position = position;\n  this.constraints = constraints;\n  this.cursor = cursor;\n  this.eventBus = eventBus;\n  this.el = document.createElement('div');\n  this.el.className = 'croppr-handle';\n  this.el.style.cursor = cursor;\n  this.el.addEventListener('mousedown', onMouseDown);\n  function onMouseDown(e) {\n    e.stopPropagation();\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseUp(e) {\n    e.stopPropagation();\n    document.removeEventListener('mouseup', onMouseUp);\n    document.removeEventListener('mousemove', onMouseMove);\n    self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n      detail: { handle: self }\n    }));\n  }\n  function onMouseMove(e) {\n    e.stopPropagation();\n    self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n      detail: { mouseX: e.clientX, mouseY: e.clientY }\n    }));\n  }\n};\n\nvar Box = function () {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  function Box(x1, y1, x2, y2) {\n    classCallCheck(this, Box);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  /**\n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  createClass(Box, [{\n    key: 'set',\n    value: function set$$1() {\n      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      this.x1 = x1 == null ? this.x1 : x1;\n      this.y1 = y1 == null ? this.y1 : y1;\n      this.x2 = x2 == null ? this.x2 : x2;\n      this.y2 = y2 == null ? this.y2 : y2;\n      return this;\n    }\n    /**\n     * Calculates the width of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'width',\n    value: function width() {\n      return Math.abs(this.x2 - this.x1);\n    }\n    /**\n     * Calculates the height of the box.\n     * @returns {Number}\n     */\n  }, {\n    key: 'height',\n    value: function height() {\n      return Math.abs(this.y2 - this.y1);\n    }\n    /**\n     * Resizes the box to a new size.\n     * @param {Number} newWidth\n     * @param {Number} newHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'resize',\n    value: function resize(newWidth, newHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var fromX = this.x1 + this.width() * origin[0];\n      var fromY = this.y1 + this.height() * origin[1];\n      this.x1 = fromX - newWidth * origin[0];\n      this.y1 = fromY - newHeight * origin[1];\n      this.x2 = this.x1 + newWidth;\n      this.y2 = this.y1 + newHeight;\n      return this;\n    }\n    /**\n     * Scale the box by a factor.\n     * @param {Number} factor\n     * @param {Array} [origin] The origin point to resize from.\n     *      Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'scale',\n    value: function scale(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var newWidth = this.width() * factor;\n      var newHeight = this.height() * factor;\n      this.resize(newWidth, newHeight, origin);\n      return this;\n    }\n  }, {\n    key: 'move',\n    value: function move() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var width = this.width();\n      var height = this.height();\n      x = x === null ? this.x1 : x;\n      y = y === null ? this.y1 : y;\n      this.x1 = x;\n      this.y1 = y;\n      this.x2 = x + width;\n      this.y2 = y + height;\n      return this;\n    }\n    /**\n     * Get relative x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getRelativePoint',\n    value: function getRelativePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.width() * point[0];\n      var y = this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Get absolute x and y coordinates of a given point within the box.\n     * @param {Array} point The x and y ratio position within the box.\n     * @returns {Array} The x and y coordinates [x, y].\n     */\n  }, {\n    key: 'getAbsolutePoint',\n    value: function getAbsolutePoint() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var x = this.x1 + this.width() * point[0];\n      var y = this.y1 + this.height() * point[1];\n      return [x, y];\n    }\n    /**\n     * Constrain the box to a fixed ratio.\n     * @param {Number} ratio\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {String} [grow] The axis to grow to maintain the ratio.\n     *     Defaults to 'height'.\n     */\n  }, {\n    key: 'constrainToRatio',\n    value: function constrainToRatio(ratio) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n      var grow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'height';\n      if (ratio === null) {\n        return;\n      }\n      var width = this.width();\n      var height = this.height();\n      switch (grow) {\n        case 'height':\n          this.resize(this.width(), this.width() * ratio, origin);\n          break;\n        case 'width':\n          this.resize(this.height() * 1 / ratio, this.height(), origin);\n          break;\n        default:\n          this.resize(this.width(), this.width() * ratio, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box within a boundary.\n     * @param {Number} boundaryWidth\n     * @param {Number} boundaryHeight\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     */\n  }, {\n    key: 'constrainToBoundary',\n    value: function constrainToBoundary(boundaryWidth, boundaryHeight) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var _getAbsolutePoint = this.getAbsolutePoint(origin),\n          _getAbsolutePoint2 = slicedToArray(_getAbsolutePoint, 2),\n          originX = _getAbsolutePoint2[0],\n          originY = _getAbsolutePoint2[1];\n      var maxIfLeft = originX;\n      var maxIfTop = originY;\n      var maxIfRight = boundaryWidth - originX;\n      var maxIfBottom = boundaryHeight - originY;\n      var directionX = -2 * origin[0] + 1;\n      var directionY = -2 * origin[1] + 1;\n      var maxWidth = null,\n          maxHeight = null;\n      switch (directionX) {\n        case -1:\n          maxWidth = maxIfLeft;break;\n        case 0:\n          maxWidth = Math.min(maxIfLeft, maxIfRight) * 2;break;\n        case +1:\n          maxWidth = maxIfRight;break;\n      }\n      switch (directionY) {\n        case -1:\n          maxHeight = maxIfTop;break;\n        case 0:\n          maxHeight = Math.min(maxIfTop, maxIfBottom) * 2;break;\n        case +1:\n          maxHeight = maxIfBottom;break;\n      }\n      if (this.width() > maxWidth) {\n        var factor = maxWidth / this.width();\n        this.scale(factor, origin);\n      }\n      if (this.height() > maxHeight) {\n        var _factor = maxHeight / this.height();\n        this.scale(_factor, origin);\n      }\n      return this;\n    }\n    /**\n     * Constrain the box to a maximum/minimum size.\n     * @param {Number} [maxWidth]\n     * @param {Number} [maxHeight]\n     * @param {Number} [minWidth]\n     * @param {Number} [minHeight]\n     * @param {Array} [origin] The origin point to resize from.\n     *     Defaults to [0, 0] (top left).\n     * @param {Number} [ratio] Ratio to maintain.\n     */\n  }, {\n    key: 'constrainToSize',\n    value: function constrainToSize() {\n      var maxWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var maxHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var minWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var minHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];\n      var ratio = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      if (ratio) {\n        if (ratio > 1) {\n          maxWidth = maxHeight * 1 / ratio;\n          minHeight = minHeight * ratio;\n        } else if (ratio < 1) {\n          maxHeight = maxWidth * ratio;\n          minWidth = minHeight * 1 / ratio;\n        }\n      }\n      if (maxWidth && this.width() > maxWidth) {\n        var newWidth = maxWidth,\n            newHeight = ratio === null ? this.height() : maxHeight;\n        this.resize(newWidth, newHeight, origin);\n      }\n      if (maxHeight && this.height() > maxHeight) {\n        var _newWidth = ratio === null ? this.width() : maxWidth,\n            _newHeight = maxHeight;\n        this.resize(_newWidth, _newHeight, origin);\n      }\n      if (minWidth && this.width() < minWidth) {\n        var _newWidth2 = minWidth,\n            _newHeight2 = ratio === null ? this.height() : minHeight;\n        this.resize(_newWidth2, _newHeight2, origin);\n      }\n      if (minHeight && this.height() < minHeight) {\n        var _newWidth3 = ratio === null ? this.width() : minWidth,\n            _newHeight3 = minHeight;\n        this.resize(_newWidth3, _newHeight3, origin);\n      }\n      return this;\n    }\n  }]);\n  return Box;\n}();\n\n/**\n * Binds an element's touch events to be simulated as mouse events.\n * @param {Element} element\n */\nfunction enableTouch(element) {\n  element.addEventListener('touchstart', simulateMouseEvent);\n  element.addEventListener('touchend', simulateMouseEvent);\n  element.addEventListener('touchmove', simulateMouseEvent);\n}\n/**\n * Translates a touch event to a mouse event.\n * @param {Event} e\n */\nfunction simulateMouseEvent(e) {\n  e.preventDefault();\n  var touch = e.changedTouches[0];\n  var eventMap = {\n    'touchstart': 'mousedown',\n    'touchmove': 'mousemove',\n    'touchend': 'mouseup'\n  };\n  touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {\n    bubbles: true,\n    cancelable: true,\n    view: window,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    screenX: touch.screenX,\n    screenY: touch.screenY\n  }));\n}\n\n/**\n * Define a list of handles to create.\n *\n * @property {Array} position - The x and y ratio position of the handle within\n *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].\n * @property {Array} constraints - Define the side of the crop region that is to\n *      be affected by this handle. Accepts a value of 0 or 1 in the order of\n *      [TOP, RIGHT, BOTTOM, LEFT].\n * @property {String} cursor - The CSS cursor of this handle.\n */\nvar HANDLES = [{ position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: 'nw-resize' }, { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: 'n-resize' }, { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: 'ne-resize' }, { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: 'e-resize' }, { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: 'se-resize' }, { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: 's-resize' }, { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: 'sw-resize' }, { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: 'w-resize' }];\nvar CropprCore = function () {\n  function CropprCore(element, options) {\n    var _this = this;\n    var deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, CropprCore);\n    this.options = CropprCore.parseOptions(options || {});\n    if (!element.nodeName) {\n      element = document.querySelector(element);\n      if (element == null) {\n        throw 'Unable to find element.';\n      }\n    }\n    if (!element.getAttribute('src')) {\n      throw 'Image src not provided.';\n    }\n    this._initialized = false;\n    this._restore = {\n      parent: element.parentNode,\n      element: element\n    };\n    if (!deferred) {\n      if (element.width === 0 || element.height === 0) {\n        element.onload = function () {\n          _this.initialize(element);\n        };\n      } else {\n        this.initialize(element);\n      }\n    }\n  }\n  createClass(CropprCore, [{\n    key: 'initialize',\n    value: function initialize(element) {\n      this.createDOM(element);\n      this.options.convertToPixels(this.cropperEl);\n      this.attachHandlerEvents();\n      this.attachRegionEvents();\n      this.attachOverlayEvents();\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      this._initialized = true;\n      if (this.options.onInitialize !== null) {\n        this.options.onInitialize(this);\n      }\n    }\n  }, {\n    key: 'createDOM',\n    value: function createDOM(targetEl) {\n      this.containerEl = document.createElement('div');\n      this.containerEl.className = 'croppr-container';\n      this.eventBus = this.containerEl;\n      enableTouch(this.containerEl);\n      this.cropperEl = document.createElement('div');\n      this.cropperEl.className = 'croppr';\n      this.imageEl = document.createElement('img');\n      this.imageEl.setAttribute('src', targetEl.getAttribute('src'));\n      this.imageEl.setAttribute('alt', targetEl.getAttribute('alt'));\n      this.imageEl.className = 'croppr-image';\n      this.imageClippedEl = this.imageEl.cloneNode();\n      this.imageClippedEl.className = 'croppr-imageClipped';\n      this.regionEl = document.createElement('div');\n      this.regionEl.className = 'croppr-region';\n      this.overlayEl = document.createElement('div');\n      this.overlayEl.className = 'croppr-overlay';\n      var handleContainerEl = document.createElement('div');\n      handleContainerEl.className = 'croppr-handleContainer';\n      this.handles = [];\n      for (var i = 0; i < HANDLES.length; i++) {\n        var handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);\n        this.handles.push(handle);\n        handleContainerEl.appendChild(handle.el);\n      }\n      this.cropperEl.appendChild(this.imageEl);\n      this.cropperEl.appendChild(this.imageClippedEl);\n      this.cropperEl.appendChild(this.regionEl);\n      this.cropperEl.appendChild(this.overlayEl);\n      this.cropperEl.appendChild(handleContainerEl);\n      this.containerEl.appendChild(this.cropperEl);\n      targetEl.parentElement.replaceChild(this.containerEl, targetEl);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      var _this2 = this;\n      this.imageEl.onload = function () {\n        _this2.box = _this2.initializeBox(_this2.options);\n        _this2.redraw();\n      };\n      this.imageEl.src = src;\n      this.imageClippedEl.src = src;\n      return this;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._restore.parent.replaceChild(this._restore.element, this.containerEl);\n    }\n    /**\n     * Create a new box region with a set of options.\n     * @param {Object} opts The options.\n     * @returns {Box}\n     */\n  }, {\n    key: 'initializeBox',\n    value: function initializeBox(opts) {\n      var width = opts.startSize.width;\n      var height = opts.startSize.height;\n      var box = new Box(0, 0, width, height);\n      box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);\n      var min = opts.minSize;\n      var max = opts.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);\n      var x = this.cropperEl.offsetWidth / 2 - box.width() / 2;\n      var y = this.cropperEl.offsetHeight / 2 - box.height() / 2;\n      box.move(x, y);\n      return box;\n    }\n  }, {\n    key: 'redraw',\n    value: function redraw() {\n      var _this3 = this;\n      var width = Math.round(this.box.width()),\n          height = Math.round(this.box.height()),\n          x1 = Math.round(this.box.x1),\n          y1 = Math.round(this.box.y1),\n          x2 = Math.round(this.box.x2),\n          y2 = Math.round(this.box.y2);\n      window.requestAnimationFrame(function () {\n        _this3.regionEl.style.transform = 'translate(' + x1 + 'px, ' + y1 + 'px)';\n        _this3.regionEl.style.width = width + 'px';\n        _this3.regionEl.style.height = height + 'px';\n        _this3.imageClippedEl.style.clip = 'rect(' + y1 + 'px, ' + x2 + 'px, ' + y2 + 'px, ' + x1 + 'px)';\n        var center = _this3.box.getAbsolutePoint([.5, .5]);\n        var xSign = center[0] - _this3.cropperEl.offsetWidth / 2 >> 31;\n        var ySign = center[1] - _this3.cropperEl.offsetHeight / 2 >> 31;\n        var quadrant = (xSign ^ ySign) + ySign + ySign + 4;\n        var foregroundHandleIndex = -2 * quadrant + 8;\n        for (var i = 0; i < _this3.handles.length; i++) {\n          var handle = _this3.handles[i];\n          var handleWidth = handle.el.offsetWidth;\n          var handleHeight = handle.el.offsetHeight;\n          var left = x1 + width * handle.position[0] - handleWidth / 2;\n          var top = y1 + height * handle.position[1] - handleHeight / 2;\n          handle.el.style.transform = 'translate(' + Math.round(left) + 'px, ' + Math.round(top) + 'px)';\n          handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;\n        }\n      });\n    }\n  }, {\n    key: 'attachHandlerEvents',\n    value: function attachHandlerEvents() {\n      var eventBus = this.eventBus;\n      eventBus.addEventListener('handlestart', this.onHandleMoveStart.bind(this));\n      eventBus.addEventListener('handlemove', this.onHandleMoveMoving.bind(this));\n      eventBus.addEventListener('handleend', this.onHandleMoveEnd.bind(this));\n    }\n  }, {\n    key: 'attachRegionEvents',\n    value: function attachRegionEvents() {\n      var eventBus = this.eventBus;\n      var self = this;\n      this.regionEl.addEventListener('mousedown', onMouseDown);\n      eventBus.addEventListener('regionstart', this.onRegionMoveStart.bind(this));\n      eventBus.addEventListener('regionmove', this.onRegionMoveMoving.bind(this));\n      eventBus.addEventListener('regionend', this.onRegionMoveEnd.bind(this));\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionstart', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        eventBus.dispatchEvent(new CustomEvent('regionmove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        eventBus.dispatchEvent(new CustomEvent('regionend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'attachOverlayEvents',\n    value: function attachOverlayEvents() {\n      var SOUTHEAST_HANDLE_IDX = 4;\n      var self = this;\n      var tmpBox = null;\n      this.overlayEl.addEventListener('mousedown', onMouseDown);\n      function onMouseDown(e) {\n        e.stopPropagation();\n        document.addEventListener('mouseup', onMouseUp);\n        document.addEventListener('mousemove', onMouseMove);\n        var container = self.cropperEl.getBoundingClientRect();\n        var mouseX = e.clientX - container.left;\n        var mouseY = e.clientY - container.top;\n        tmpBox = self.box;\n        self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);\n        self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\n          detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] }\n        }));\n      }\n      function onMouseMove(e) {\n        e.stopPropagation();\n        self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n      function onMouseUp(e) {\n        e.stopPropagation();\n        document.removeEventListener('mouseup', onMouseUp);\n        document.removeEventListener('mousemove', onMouseMove);\n        if (self.box.width() === 1 && self.box.height() === 1) {\n          self.box = tmpBox;\n          return;\n        }\n        self.eventBus.dispatchEvent(new CustomEvent('handleend', {\n          detail: { mouseX: e.clientX, mouseY: e.clientY }\n        }));\n      }\n    }\n  }, {\n    key: 'onHandleMoveStart',\n    value: function onHandleMoveStart(e) {\n      var handle = e.detail.handle;\n      var originPoint = [1 - handle.position[0], 1 - handle.position[1]];\n      var _box$getAbsolutePoint = this.box.getAbsolutePoint(originPoint),\n          _box$getAbsolutePoint2 = slicedToArray(_box$getAbsolutePoint, 2),\n          originX = _box$getAbsolutePoint2[0],\n          originY = _box$getAbsolutePoint2[1];\n      this.activeHandle = { handle: handle, originPoint: originPoint, originX: originX, originY: originY };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveMoving',\n    value: function onHandleMoveMoving(e) {\n      var _e$detail = e.detail,\n          mouseX = _e$detail.mouseX,\n          mouseY = _e$detail.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      if (mouseX < 0) {\n        mouseX = 0;\n      } else if (mouseX > container.width) {\n        mouseX = container.width;\n      }\n      if (mouseY < 0) {\n        mouseY = 0;\n      } else if (mouseY > container.height) {\n        mouseY = container.height;\n      }\n      var origin = this.activeHandle.originPoint.slice();\n      var originX = this.activeHandle.originX;\n      var originY = this.activeHandle.originY;\n      var handle = this.activeHandle.handle;\n      var TOP_MOVABLE = handle.constraints[0] === 1;\n      var RIGHT_MOVABLE = handle.constraints[1] === 1;\n      var BOTTOM_MOVABLE = handle.constraints[2] === 1;\n      var LEFT_MOVABLE = handle.constraints[3] === 1;\n      var MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);\n      var x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;\n      var x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;\n      var y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;\n      var y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;\n      x1 = LEFT_MOVABLE ? mouseX : x1;\n      x2 = RIGHT_MOVABLE ? mouseX : x2;\n      y1 = TOP_MOVABLE ? mouseY : y1;\n      y2 = BOTTOM_MOVABLE ? mouseY : y2;\n      var isFlippedX = false,\n          isFlippedY = false;\n      if (LEFT_MOVABLE || RIGHT_MOVABLE) {\n        isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;\n      }\n      if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n        isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;\n      }\n      if (isFlippedX) {\n        var tmp = x1;x1 = x2;x2 = tmp;\n        origin[0] = 1 - origin[0];\n      }\n      if (isFlippedY) {\n        var _tmp = y1;y1 = y2;y2 = _tmp;\n        origin[1] = 1 - origin[1];\n      }\n      var box = new Box(x1, y1, x2, y2);\n      if (this.options.aspectRatio) {\n        var ratio = this.options.aspectRatio;\n        var isVerticalMovement = false;\n        if (MULTI_AXIS) {\n          isVerticalMovement = mouseY > box.y1 + ratio * box.width() || mouseY < box.y2 - ratio * box.width();\n        } else if (TOP_MOVABLE || BOTTOM_MOVABLE) {\n          isVerticalMovement = true;\n        }\n        var ratioMode = isVerticalMovement ? 'width' : 'height';\n        box.constrainToRatio(ratio, origin, ratioMode);\n      }\n      var min = this.options.minSize;\n      var max = this.options.maxSize;\n      box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);\n      var parentWidth = this.cropperEl.offsetWidth;\n      var parentHeight = this.cropperEl.offsetHeight;\n      box.constrainToBoundary(parentWidth, parentHeight, origin);\n      this.box = box;\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onHandleMoveEnd',\n    value: function onHandleMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveStart',\n    value: function onRegionMoveStart(e) {\n      var _e$detail2 = e.detail,\n          mouseX = _e$detail2.mouseX,\n          mouseY = _e$detail2.mouseY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.currentMove = {\n        offsetX: mouseX - this.box.x1,\n        offsetY: mouseY - this.box.y1\n      };\n      if (this.options.onCropStart !== null) {\n        this.options.onCropStart(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveMoving',\n    value: function onRegionMoveMoving(e) {\n      var _e$detail3 = e.detail,\n          mouseX = _e$detail3.mouseX,\n          mouseY = _e$detail3.mouseY;\n      var _currentMove = this.currentMove,\n          offsetX = _currentMove.offsetX,\n          offsetY = _currentMove.offsetY;\n      var container = this.cropperEl.getBoundingClientRect();\n      mouseX = mouseX - container.left;\n      mouseY = mouseY - container.top;\n      this.box.move(mouseX - offsetX, mouseY - offsetY);\n      if (this.box.x1 < 0) {\n        this.box.move(0, null);\n      }\n      if (this.box.x2 > container.width) {\n        this.box.move(container.width - this.box.width(), null);\n      }\n      if (this.box.y1 < 0) {\n        this.box.move(null, 0);\n      }\n      if (this.box.y2 > container.height) {\n        this.box.move(null, container.height - this.box.height());\n      }\n      this.redraw();\n      if (this.options.onCropMove !== null) {\n        this.options.onCropMove(this.getValue());\n      }\n    }\n  }, {\n    key: 'onRegionMoveEnd',\n    value: function onRegionMoveEnd(e) {\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (mode === null) {\n        mode = this.options.returnMode;\n      }\n      if (mode == 'real') {\n        var actualWidth = this.imageEl.naturalWidth;\n        var actualHeight = this.imageEl.naturalHeight;\n        var _imageEl$getBoundingC = this.imageEl.getBoundingClientRect(),\n            elementWidth = _imageEl$getBoundingC.width,\n            elementHeight = _imageEl$getBoundingC.height;\n        var factorX = actualWidth / elementWidth;\n        var factorY = actualHeight / elementHeight;\n        return {\n          x: Math.round(this.box.x1 * factorX),\n          y: Math.round(this.box.y1 * factorY),\n          width: Math.round(this.box.width() * factorX),\n          height: Math.round(this.box.height() * factorY)\n        };\n      } else if (mode == 'ratio') {\n        var _imageEl$getBoundingC2 = this.imageEl.getBoundingClientRect(),\n            _elementWidth = _imageEl$getBoundingC2.width,\n            _elementHeight = _imageEl$getBoundingC2.height;\n        return {\n          x: round(this.box.x1 / _elementWidth, 3),\n          y: round(this.box.y1 / _elementHeight, 3),\n          width: round(this.box.width() / _elementWidth, 3),\n          height: round(this.box.height() / _elementHeight, 3)\n        };\n      } else if (mode == 'raw') {\n        return {\n          x: Math.round(this.box.x1),\n          y: Math.round(this.box.y1),\n          width: Math.round(this.box.width()),\n          height: Math.round(this.box.height())\n        };\n      }\n    }\n  }], [{\n    key: 'parseOptions',\n    value: function parseOptions(opts) {\n      var defaults$$1 = {\n        aspectRatio: null,\n        maxSize: { width: null, height: null },\n        minSize: { width: null, height: null },\n        startSize: { width: 100, height: 100, unit: '%' },\n        returnMode: 'real',\n        onInitialize: null,\n        onCropStart: null,\n        onCropMove: null,\n        onCropEnd: null\n      };\n      var aspectRatio = null;\n      if (opts.aspectRatio !== undefined) {\n        if (typeof opts.aspectRatio === 'number') {\n          aspectRatio = opts.aspectRatio;\n        } else if (opts.aspectRatio instanceof Array) {\n          aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];\n        }\n      }\n      var maxSize = null;\n      if (opts.maxSize !== undefined && opts.maxSize !== null) {\n        maxSize = {\n          width: opts.maxSize[0] || null,\n          height: opts.maxSize[1] || null,\n          unit: opts.maxSize[2] || 'px'\n        };\n      }\n      var minSize = null;\n      if (opts.minSize !== undefined && opts.minSize !== null) {\n        minSize = {\n          width: opts.minSize[0] || null,\n          height: opts.minSize[1] || null,\n          unit: opts.minSize[2] || 'px'\n        };\n      }\n      var startSize = null;\n      if (opts.startSize !== undefined && opts.startSize !== null) {\n        startSize = {\n          width: opts.startSize[0] || null,\n          height: opts.startSize[1] || null,\n          unit: opts.startSize[2] || '%'\n        };\n      }\n      var onInitialize = null;\n      if (typeof opts.onInitialize === 'function') {\n        onInitialize = opts.onInitialize;\n      }\n      var onCropStart = null;\n      if (typeof opts.onCropStart === 'function') {\n        onCropStart = opts.onCropStart;\n      }\n      var onCropEnd = null;\n      if (typeof opts.onCropEnd === 'function') {\n        onCropEnd = opts.onCropEnd;\n      }\n      var onCropMove = null;\n      if (typeof opts.onUpdate === 'function') {\n        console.warn('Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.');\n        onCropMove = opts.onUpdate;\n      }\n      if (typeof opts.onCropMove === 'function') {\n        onCropMove = opts.onCropMove;\n      }\n      var returnMode = null;\n      if (opts.returnMode !== undefined) {\n        var s = opts.returnMode.toLowerCase();\n        if (['real', 'ratio', 'raw'].indexOf(s) === -1) {\n          throw \"Invalid return mode.\";\n        }\n        returnMode = s;\n      }\n      var convertToPixels = function convertToPixels(container) {\n        var width = container.offsetWidth;\n        var height = container.offsetHeight;\n        var sizeKeys = ['maxSize', 'minSize', 'startSize'];\n        for (var i = 0; i < sizeKeys.length; i++) {\n          var key = sizeKeys[i];\n          if (this[key] !== null) {\n            if (this[key].unit == '%') {\n              if (this[key].width !== null) {\n                this[key].width = this[key].width / 100 * width;\n              }\n              if (this[key].height !== null) {\n                this[key].height = this[key].height / 100 * height;\n              }\n            }\n            delete this[key].unit;\n          }\n        }\n      };\n      var defaultValue = function defaultValue(v, d) {\n        return v !== null ? v : d;\n      };\n      return {\n        aspectRatio: defaultValue(aspectRatio, defaults$$1.aspectRatio),\n        maxSize: defaultValue(maxSize, defaults$$1.maxSize),\n        minSize: defaultValue(minSize, defaults$$1.minSize),\n        startSize: defaultValue(startSize, defaults$$1.startSize),\n        returnMode: defaultValue(returnMode, defaults$$1.returnMode),\n        onInitialize: defaultValue(onInitialize, defaults$$1.onInitialize),\n        onCropStart: defaultValue(onCropStart, defaults$$1.onCropStart),\n        onCropMove: defaultValue(onCropMove, defaults$$1.onCropMove),\n        onCropEnd: defaultValue(onCropEnd, defaults$$1.onCropEnd),\n        convertToPixels: convertToPixels\n      };\n    }\n  }]);\n  return CropprCore;\n}();\nfunction round(value, decimals) {\n  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);\n}\n\nvar Croppr$1 = function (_CropprCore) {\n  inherits(Croppr, _CropprCore);\n  /**\n   * @constructor\n   * Calls the CropprCore's constructor.\n   */\n  function Croppr(element, options) {\n    var _deferred = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Croppr);\n    return possibleConstructorReturn(this, (Croppr.__proto__ || Object.getPrototypeOf(Croppr)).call(this, element, options, _deferred));\n  }\n  /**\n   * Gets the value of the crop region.\n   * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or\n   *      'raw'.\n   */\n  createClass(Croppr, [{\n    key: 'getValue',\n    value: function getValue(mode) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'getValue', this).call(this, mode);\n    }\n    /**\n     * Changes the image src.\n     * @param {String} src\n     */\n  }, {\n    key: 'setImage',\n    value: function setImage(src) {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'setImage', this).call(this, src);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return get(Croppr.prototype.__proto__ || Object.getPrototypeOf(Croppr.prototype), 'destroy', this).call(this);\n    }\n    /**\n     * Moves the crop region to a specified coordinate.\n     * @param {Number} x\n     * @param {Number} y\n     */\n  }, {\n    key: 'moveTo',\n    value: function moveTo(x, y) {\n      this.box.move(x, y);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Resizes the crop region to a specified width and height.\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'resizeTo',\n    value: function resizeTo(width, height) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [.5, .5];\n      this.box.resize(width, height, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n    /**\n     * Scale the crop region by a factor.\n     * @param {Number} factor\n     * @param {Array} origin The origin point to resize from.\n     *      Defaults to [0.5, 0.5] (center).\n     */\n  }, {\n    key: 'scaleBy',\n    value: function scaleBy(factor) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [.5, .5];\n      this.box.scale(factor, origin);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.box = this.initializeBox(this.options);\n      this.redraw();\n      if (this.options.onCropEnd !== null) {\n        this.options.onCropEnd(this.getValue());\n      }\n      return this;\n    }\n  }]);\n  return Croppr;\n}(CropprCore);\n\nreturn Croppr$1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL2Rpc3QvY3JvcHByLmpzPzc1ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQzJCO0FBQzVCLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQXFEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsZ0JBQWdCLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRSxHQUFHLHVFQUF1RSxHQUFHLHNFQUFzRTtBQUN6bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QyxrQkFBa0IsNEJBQTRCO0FBQzlDLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nyb3Bwci9kaXN0L2Nyb3Bwci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JvcHByLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFtZXNzc29vaS9Dcm9wcHIuanNcbiAqIFxuICogQSBKYXZhU2NyaXB0IGltYWdlIGNyb3BwZXIgdGhhdCdzIGxpZ2h0d2VpZ2h0LCBhd2Vzb21lLCBhbmQgaGFzXG4gKiB6ZXJvIGRlcGVuZGVuY2llcy5cbiAqIFxuICogKEMpIDIwMTcgSmFtZXMgT29pLiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkNyb3BwciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RUaW1lID0gMDtcbiAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG59KSgpO1xuKGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICBuZXcgQ3VzdG9tRXZlbnQoJ3Rlc3QnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGZ1bmN0aW9uIE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfTtcbiAgICB2YXIgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgbW91c2VFdmVudC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gIH1cbiAgTW91c2VFdmVudC5wcm90b3R5cGUgPSBFdmVudC5wcm90b3R5cGU7XG4gIHdpbmRvdy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcbn0pKHdpbmRvdyk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgSGFuZGxlID1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBIYW5kbGUgaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9uIFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGVcbiAqICAgICAgd2l0aGluIHRoZSBjcm9wIHJlZ2lvbi4gQWNjZXB0cyBhIHZhbHVlIGJldHdlZW4gMCB0byAxIGluIHRoZSBvcmRlclxuICogICAgICBvZiBbWCwgWV0uXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50cyBEZWZpbmUgdGhlIHNpZGUgb2YgdGhlIGNyb3AgcmVnaW9uIHRoYXRcbiAqICAgICAgaXMgdG8gYmUgYWZmZWN0ZWQgYnkgdGhpcyBoYW5kbGUuIEFjY2VwdHMgYSB2YWx1ZSBvZiAwIG9yIDEgaW4gdGhlXG4gKiAgICAgIG9yZGVyIG9mIFtUT1AsIFJJR0hULCBCT1RUT00sIExFRlRdLlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnNvciBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZXZlbnRCdXMgVGhlIGVsZW1lbnQgdG8gZGlzcGF0Y2ggZXZlbnRzIHRvLlxuICovXG5mdW5jdGlvbiBIYW5kbGUocG9zaXRpb24sIGNvbnN0cmFpbnRzLCBjdXJzb3IsIGV2ZW50QnVzKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhhbmRsZSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSAnY3JvcHByLWhhbmRsZSc7XG4gIHRoaXMuZWwuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZXN0YXJ0Jywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZiB9XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNlbGYuZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hhbmRsZW1vdmUnLCB7XG4gICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICB9KSk7XG4gIH1cbn07XG5cbnZhciBCb3ggPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEJveCBpbnN0YW5jZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgZnVuY3Rpb24gQm94KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5ldyBkaW1lbnNpb25zIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKi9cbiAgY3JlYXRlQ2xhc3MoQm94LCBbe1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCQkMSgpIHtcbiAgICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRoaXMueDEgPSB4MSA9PSBudWxsID8gdGhpcy54MSA6IHgxO1xuICAgICAgdGhpcy55MSA9IHkxID09IG51bGwgPyB0aGlzLnkxIDogeTE7XG4gICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gdGhpcy55MiA6IHkyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHdpZHRoIG9mIHRoZSBib3guXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3dpZHRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGVpZ2h0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgYm94IHRvIGEgbmV3IHNpemUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbMCwgMF07XG4gICAgICB2YXIgZnJvbVggPSB0aGlzLngxICsgdGhpcy53aWR0aCgpICogb3JpZ2luWzBdO1xuICAgICAgdmFyIGZyb21ZID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBvcmlnaW5bMV07XG4gICAgICB0aGlzLngxID0gZnJvbVggLSBuZXdXaWR0aCAqIG9yaWdpblswXTtcbiAgICAgIHRoaXMueTEgPSBmcm9tWSAtIG5ld0hlaWdodCAqIG9yaWdpblsxXTtcbiAgICAgIHRoaXMueDIgPSB0aGlzLngxICsgbmV3V2lkdGg7XG4gICAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgYm94IGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlKGZhY3Rvcikge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzAsIDBdO1xuICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy53aWR0aCgpICogZmFjdG9yO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0KCkgKiBmYWN0b3I7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICB4ID0geCA9PT0gbnVsbCA/IHRoaXMueDEgOiB4O1xuICAgICAgeSA9IHkgPT09IG51bGwgPyB0aGlzLnkxIDogeTtcbiAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgdGhpcy55MSA9IHk7XG4gICAgICB0aGlzLngyID0geCArIHdpZHRoO1xuICAgICAgdGhpcy55MiA9IHkgKyBoZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlbGF0aXZlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgYSBnaXZlbiBwb2ludCB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIFt4LCB5XS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldFJlbGF0aXZlUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvaW50KCkge1xuICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbMCwgMF07XG4gICAgICB2YXIgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50IFRoZSB4IGFuZCB5IHJhdGlvIHBvc2l0aW9uIHdpdGhpbiB0aGUgYm94LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgW3gsIHldLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0QWJzb2x1dGVQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFic29sdXRlUG9pbnQoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFswLCAwXTtcbiAgICAgIHZhciB4ID0gdGhpcy54MSArIHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLnkxICsgdGhpcy5oZWlnaHQoKSAqIHBvaW50WzFdO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBmaXhlZCByYXRpby5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3ddIFRoZSBheGlzIHRvIGdyb3cgdG8gbWFpbnRhaW4gdGhlIHJhdGlvLlxuICAgICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbnN0cmFpblRvUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1JhdGlvKHJhdGlvKSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMCwgMF07XG4gICAgICB2YXIgZ3JvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2hlaWdodCc7XG4gICAgICBpZiAocmF0aW8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICBzd2l0Y2ggKGdyb3cpIHtcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMud2lkdGgoKSAqIHJhdGlvLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbiB0aGUgYm94IHdpdGhpbiBhIGJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJvdW5kYXJ5SGVpZ2h0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub0JvdW5kYXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3RyYWluVG9Cb3VuZGFyeShib3VuZGFyeVdpZHRoLCBib3VuZGFyeUhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWzAsIDBdO1xuICAgICAgdmFyIF9nZXRBYnNvbHV0ZVBvaW50ID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbiksXG4gICAgICAgICAgX2dldEFic29sdXRlUG9pbnQyID0gc2xpY2VkVG9BcnJheShfZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9nZXRBYnNvbHV0ZVBvaW50MlswXSxcbiAgICAgICAgICBvcmlnaW5ZID0gX2dldEFic29sdXRlUG9pbnQyWzFdO1xuICAgICAgdmFyIG1heElmTGVmdCA9IG9yaWdpblg7XG4gICAgICB2YXIgbWF4SWZUb3AgPSBvcmlnaW5ZO1xuICAgICAgdmFyIG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWDtcbiAgICAgIHZhciBtYXhJZkJvdHRvbSA9IGJvdW5kYXJ5SGVpZ2h0IC0gb3JpZ2luWTtcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gLTIgKiBvcmlnaW5bMF0gKyAxO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSAtMiAqIG9yaWdpblsxXSArIDE7XG4gICAgICB2YXIgbWF4V2lkdGggPSBudWxsLFxuICAgICAgICAgIG1heEhlaWdodCA9IG51bGw7XG4gICAgICBzd2l0Y2ggKGRpcmVjdGlvblgpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBtYXhXaWR0aCA9IG1heElmTGVmdDticmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4SWZMZWZ0LCBtYXhJZlJpZ2h0KSAqIDI7YnJlYWs7XG4gICAgICAgIGNhc2UgKzE6XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhJZlJpZ2h0O2JyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkaXJlY3Rpb25ZKSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4SWZUb3A7YnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjticmVhaztcbiAgICAgICAgY2FzZSArMTpcbiAgICAgICAgICBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTticmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgICB2YXIgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICAgIHRoaXMuc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgdmFyIF9mYWN0b3IgPSBtYXhIZWlnaHQgLyB0aGlzLmhlaWdodCgpO1xuICAgICAgICB0aGlzLnNjYWxlKF9mYWN0b3IsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RyYWluIHRoZSBib3ggdG8gYSBtYXhpbXVtL21pbmltdW0gc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4SGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluV2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjb25zdHJhaW5Ub1NpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJhaW5Ub1NpemUoKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIG1pbldpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbkhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFswLCAwXTtcbiAgICAgIHZhciByYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAgIGlmIChyYXRpbykge1xuICAgICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBtYXhIZWlnaHQgKiAxIC8gcmF0aW87XG4gICAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAocmF0aW8gPCAxKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gbWF4V2lkdGggKiByYXRpbztcbiAgICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFdpZHRoICYmIHRoaXMud2lkdGgoKSA+IG1heFdpZHRoKSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IG1heFdpZHRoLFxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcmF0aW8gPT09IG51bGwgPyB0aGlzLmhlaWdodCgpIDogbWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1heFdpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoLCBfbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICAgIHZhciBfbmV3V2lkdGgyID0gbWluV2lkdGgsXG4gICAgICAgICAgICBfbmV3SGVpZ2h0MiA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1pbkhlaWdodDtcbiAgICAgICAgdGhpcy5yZXNpemUoX25ld1dpZHRoMiwgX25ld0hlaWdodDIsIG9yaWdpbik7XG4gICAgICB9XG4gICAgICBpZiAobWluSGVpZ2h0ICYmIHRoaXMuaGVpZ2h0KCkgPCBtaW5IZWlnaHQpIHtcbiAgICAgICAgdmFyIF9uZXdXaWR0aDMgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICAgICAgX25ld0hlaWdodDMgPSBtaW5IZWlnaHQ7XG4gICAgICAgIHRoaXMucmVzaXplKF9uZXdXaWR0aDMsIF9uZXdIZWlnaHQzLCBvcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbi8qKlxuICogQmluZHMgYW4gZWxlbWVudCdzIHRvdWNoIGV2ZW50cyB0byBiZSBzaW11bGF0ZWQgYXMgbW91c2UgZXZlbnRzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZVRvdWNoKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHNpbXVsYXRlTW91c2VFdmVudCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2ltdWxhdGVNb3VzZUV2ZW50KTtcbn1cbi8qKlxuICogVHJhbnNsYXRlcyBhIHRvdWNoIGV2ZW50IHRvIGEgbW91c2UgZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBlXG4gKi9cbmZ1bmN0aW9uIHNpbXVsYXRlTW91c2VFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgdmFyIGV2ZW50TWFwID0ge1xuICAgICd0b3VjaHN0YXJ0JzogJ21vdXNlZG93bicsXG4gICAgJ3RvdWNobW92ZSc6ICdtb3VzZW1vdmUnLFxuICAgICd0b3VjaGVuZCc6ICdtb3VzZXVwJ1xuICB9O1xuICB0b3VjaC50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldmVudE1hcFtlLnR5cGVdLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIHZpZXc6IHdpbmRvdyxcbiAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgc2NyZWVuWDogdG91Y2guc2NyZWVuWCxcbiAgICBzY3JlZW5ZOiB0b3VjaC5zY3JlZW5ZXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBsaXN0IG9mIGhhbmRsZXMgdG8gY3JlYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBvc2l0aW9uIC0gVGhlIHggYW5kIHkgcmF0aW8gcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW5cbiAqICAgICAgdGhlIGNyb3AgcmVnaW9uLiBBY2NlcHRzIGEgdmFsdWUgYmV0d2VlbiAwIHRvIDEgaW4gdGhlIG9yZGVyIG9mIFtYLCBZXS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnN0cmFpbnRzIC0gRGVmaW5lIHRoZSBzaWRlIG9mIHRoZSBjcm9wIHJlZ2lvbiB0aGF0IGlzIHRvXG4gKiAgICAgIGJlIGFmZmVjdGVkIGJ5IHRoaXMgaGFuZGxlLiBBY2NlcHRzIGEgdmFsdWUgb2YgMCBvciAxIGluIHRoZSBvcmRlciBvZlxuICogICAgICBbVE9QLCBSSUdIVCwgQk9UVE9NLCBMRUZUXS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjdXJzb3IgLSBUaGUgQ1NTIGN1cnNvciBvZiB0aGlzIGhhbmRsZS5cbiAqL1xudmFyIEhBTkRMRVMgPSBbeyBwb3NpdGlvbjogWzAuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAwLCAwLCAxXSwgY3Vyc29yOiAnbnctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAwLjBdLCBjb25zdHJhaW50czogWzEsIDAsIDAsIDBdLCBjdXJzb3I6ICduLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMC4wXSwgY29uc3RyYWludHM6IFsxLCAxLCAwLCAwXSwgY3Vyc29yOiAnbmUtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMS4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDEsIDAsIDBdLCBjdXJzb3I6ICdlLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzEuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAxLCAxLCAwXSwgY3Vyc29yOiAnc2UtcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC41LCAxLjBdLCBjb25zdHJhaW50czogWzAsIDAsIDEsIDBdLCBjdXJzb3I6ICdzLXJlc2l6ZScgfSwgeyBwb3NpdGlvbjogWzAuMCwgMS4wXSwgY29uc3RyYWludHM6IFswLCAwLCAxLCAxXSwgY3Vyc29yOiAnc3ctcmVzaXplJyB9LCB7IHBvc2l0aW9uOiBbMC4wLCAwLjVdLCBjb25zdHJhaW50czogWzAsIDAsIDAsIDFdLCBjdXJzb3I6ICd3LXJlc2l6ZScgfV07XG52YXIgQ3JvcHByQ29yZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3JvcHByQ29yZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwckNvcmUpO1xuICAgIHRoaXMub3B0aW9ucyA9IENyb3BwckNvcmUucGFyc2VPcHRpb25zKG9wdGlvbnMgfHwge30pO1xuICAgIGlmICghZWxlbWVudC5ub2RlTmFtZSkge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICdVbmFibGUgdG8gZmluZCBlbGVtZW50Lic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICB0aHJvdyAnSW1hZ2Ugc3JjIG5vdCBwcm92aWRlZC4nO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc3RvcmUgPSB7XG4gICAgICBwYXJlbnQ6IGVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICB9O1xuICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgIGlmIChlbGVtZW50LndpZHRoID09PSAwIHx8IGVsZW1lbnQuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNsYXNzKENyb3BwckNvcmUsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jcmVhdGVET00oZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMuY29udmVydFRvUGl4ZWxzKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRoaXMuYXR0YWNoSGFuZGxlckV2ZW50cygpO1xuICAgICAgdGhpcy5hdHRhY2hSZWdpb25FdmVudHMoKTtcbiAgICAgIHRoaXMuYXR0YWNoT3ZlcmxheUV2ZW50cygpO1xuICAgICAgdGhpcy5ib3ggPSB0aGlzLmluaXRpYWxpemVCb3godGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5pdGlhbGl6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Jbml0aWFsaXplKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZURPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURPTSh0YXJnZXRFbCkge1xuICAgICAgdGhpcy5jb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc05hbWUgPSAnY3JvcHByLWNvbnRhaW5lcic7XG4gICAgICB0aGlzLmV2ZW50QnVzID0gdGhpcy5jb250YWluZXJFbDtcbiAgICAgIGVuYWJsZVRvdWNoKHRoaXMuY29udGFpbmVyRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmNsYXNzTmFtZSA9ICdjcm9wcHInO1xuICAgICAgdGhpcy5pbWFnZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB0aGlzLmltYWdlRWwuc2V0QXR0cmlidXRlKCdzcmMnLCB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ3NyYycpKTtcbiAgICAgIHRoaXMuaW1hZ2VFbC5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRhcmdldEVsLmdldEF0dHJpYnV0ZSgnYWx0JykpO1xuICAgICAgdGhpcy5pbWFnZUVsLmNsYXNzTmFtZSA9ICdjcm9wcHItaW1hZ2UnO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbCA9IHRoaXMuaW1hZ2VFbC5jbG9uZU5vZGUoKTtcbiAgICAgIHRoaXMuaW1hZ2VDbGlwcGVkRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1pbWFnZUNsaXBwZWQnO1xuICAgICAgdGhpcy5yZWdpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5yZWdpb25FbC5jbGFzc05hbWUgPSAnY3JvcHByLXJlZ2lvbic7XG4gICAgICB0aGlzLm92ZXJsYXlFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vdmVybGF5RWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1vdmVybGF5JztcbiAgICAgIHZhciBoYW5kbGVDb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaGFuZGxlQ29udGFpbmVyRWwuY2xhc3NOYW1lID0gJ2Nyb3Bwci1oYW5kbGVDb250YWluZXInO1xuICAgICAgdGhpcy5oYW5kbGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhBTkRMRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyBIYW5kbGUoSEFORExFU1tpXS5wb3NpdGlvbiwgSEFORExFU1tpXS5jb25zdHJhaW50cywgSEFORExFU1tpXS5jdXJzb3IsIHRoaXMuZXZlbnRCdXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgICAgICBoYW5kbGVDb250YWluZXJFbC5hcHBlbmRDaGlsZChoYW5kbGUuZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsKTtcbiAgICAgIHRoaXMuY3JvcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VDbGlwcGVkRWwpO1xuICAgICAgdGhpcy5jcm9wcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5yZWdpb25FbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlFbCk7XG4gICAgICB0aGlzLmNyb3BwZXJFbC5hcHBlbmRDaGlsZChoYW5kbGVDb250YWluZXJFbCk7XG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHRoaXMuY3JvcHBlckVsKTtcbiAgICAgIHRhcmdldEVsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHRoaXMuY29udGFpbmVyRWwsIHRhcmdldEVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuaW1hZ2VFbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5ib3ggPSBfdGhpczIuaW5pdGlhbGl6ZUJveChfdGhpczIub3B0aW9ucyk7XG4gICAgICAgIF90aGlzMi5yZWRyYXcoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmltYWdlRWwuc3JjID0gc3JjO1xuICAgICAgdGhpcy5pbWFnZUNsaXBwZWRFbC5zcmMgPSBzcmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmUucGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLl9yZXN0b3JlLmVsZW1lbnQsIHRoaXMuY29udGFpbmVyRWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYm94IHJlZ2lvbiB3aXRoIGEgc2V0IG9mIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge0JveH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVCb3gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQm94KG9wdHMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdHMuc3RhcnRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IG9wdHMuc3RhcnRTaXplLmhlaWdodDtcbiAgICAgIHZhciBib3ggPSBuZXcgQm94KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYm94LmNvbnN0cmFpblRvUmF0aW8ob3B0cy5hc3BlY3RSYXRpbywgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgbWluID0gb3B0cy5taW5TaXplO1xuICAgICAgdmFyIG1heCA9IG9wdHMubWF4U2l6ZTtcbiAgICAgIGJveC5jb25zdHJhaW5Ub1NpemUobWF4LndpZHRoLCBtYXguaGVpZ2h0LCBtaW4ud2lkdGgsIG1pbi5oZWlnaHQsIFswLjUsIDAuNV0sIG9wdHMuYXNwZWN0UmF0aW8pO1xuICAgICAgdmFyIHBhcmVudFdpZHRoID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgcGFyZW50SGVpZ2h0ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgYm94LmNvbnN0cmFpblRvQm91bmRhcnkocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgWzAuNSwgMC41XSk7XG4gICAgICB2YXIgeCA9IHRoaXMuY3JvcHBlckVsLm9mZnNldFdpZHRoIC8gMiAtIGJveC53aWR0aCgpIC8gMjtcbiAgICAgIHZhciB5ID0gdGhpcy5jcm9wcGVyRWwub2Zmc2V0SGVpZ2h0IC8gMiAtIGJveC5oZWlnaHQoKSAvIDI7XG4gICAgICBib3gubW92ZSh4LCB5KTtcbiAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuYm94LndpZHRoKCkpLFxuICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpLFxuICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh0aGlzLmJveC54MSksXG4gICAgICAgICAgeTEgPSBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB4MiA9IE1hdGgucm91bmQodGhpcy5ib3gueDIpLFxuICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh0aGlzLmJveC55Mik7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHgxICsgJ3B4LCAnICsgeTEgKyAncHgpJztcbiAgICAgICAgX3RoaXMzLnJlZ2lvbkVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBfdGhpczMucmVnaW9uRWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgX3RoaXMzLmltYWdlQ2xpcHBlZEVsLnN0eWxlLmNsaXAgPSAncmVjdCgnICsgeTEgKyAncHgsICcgKyB4MiArICdweCwgJyArIHkyICsgJ3B4LCAnICsgeDEgKyAncHgpJztcbiAgICAgICAgdmFyIGNlbnRlciA9IF90aGlzMy5ib3guZ2V0QWJzb2x1dGVQb2ludChbLjUsIC41XSk7XG4gICAgICAgIHZhciB4U2lnbiA9IGNlbnRlclswXSAtIF90aGlzMy5jcm9wcGVyRWwub2Zmc2V0V2lkdGggLyAyID4+IDMxO1xuICAgICAgICB2YXIgeVNpZ24gPSBjZW50ZXJbMV0gLSBfdGhpczMuY3JvcHBlckVsLm9mZnNldEhlaWdodCAvIDIgPj4gMzE7XG4gICAgICAgIHZhciBxdWFkcmFudCA9ICh4U2lnbiBeIHlTaWduKSArIHlTaWduICsgeVNpZ24gKyA0O1xuICAgICAgICB2YXIgZm9yZWdyb3VuZEhhbmRsZUluZGV4ID0gLTIgKiBxdWFkcmFudCArIDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaGFuZGxlID0gX3RoaXMzLmhhbmRsZXNbaV07XG4gICAgICAgICAgdmFyIGhhbmRsZVdpZHRoID0gaGFuZGxlLmVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIHZhciBoYW5kbGVIZWlnaHQgPSBoYW5kbGUuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHZhciBsZWZ0ID0geDEgKyB3aWR0aCAqIGhhbmRsZS5wb3NpdGlvblswXSAtIGhhbmRsZVdpZHRoIC8gMjtcbiAgICAgICAgICB2YXIgdG9wID0geTEgKyBoZWlnaHQgKiBoYW5kbGUucG9zaXRpb25bMV0gLSBoYW5kbGVIZWlnaHQgLyAyO1xuICAgICAgICAgIGhhbmRsZS5lbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBNYXRoLnJvdW5kKGxlZnQpICsgJ3B4LCAnICsgTWF0aC5yb3VuZCh0b3ApICsgJ3B4KSc7XG4gICAgICAgICAgaGFuZGxlLmVsLnN0eWxlLnpJbmRleCA9IGZvcmVncm91bmRIYW5kbGVJbmRleCA9PSBpID8gNSA6IDQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaEhhbmRsZXJFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hIYW5kbGVyRXZlbnRzKCkge1xuICAgICAgdmFyIGV2ZW50QnVzID0gdGhpcy5ldmVudEJ1cztcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZXN0YXJ0JywgdGhpcy5vbkhhbmRsZU1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZW1vdmUnLCB0aGlzLm9uSGFuZGxlTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ2hhbmRsZWVuZCcsIHRoaXMub25IYW5kbGVNb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaFJlZ2lvbkV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaFJlZ2lvbkV2ZW50cygpIHtcbiAgICAgIHZhciBldmVudEJ1cyA9IHRoaXMuZXZlbnRCdXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnJlZ2lvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbnN0YXJ0JywgdGhpcy5vblJlZ2lvbk1vdmVTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbm1vdmUnLCB0aGlzLm9uUmVnaW9uTW92ZU1vdmluZy5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlZ2lvbmVuZCcsIHRoaXMub25SZWdpb25Nb3ZlRW5kLmJpbmQodGhpcykpO1xuICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgICBldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmVnaW9uc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnRCdXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZ2lvbm1vdmUnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIGV2ZW50QnVzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyZWdpb25lbmQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IG1vdXNlWDogZS5jbGllbnRYLCBtb3VzZVk6IGUuY2xpZW50WSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2hPdmVybGF5RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoT3ZlcmxheUV2ZW50cygpIHtcbiAgICAgIHZhciBTT1VUSEVBU1RfSEFORExFX0lEWCA9IDQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG1wQm94ID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuY3JvcHBlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgbW91c2VYID0gZS5jbGllbnRYIC0gY29udGFpbmVyLmxlZnQ7XG4gICAgICAgIHZhciBtb3VzZVkgPSBlLmNsaWVudFkgLSBjb250YWluZXIudG9wO1xuICAgICAgICB0bXBCb3ggPSBzZWxmLmJveDtcbiAgICAgICAgc2VsZi5ib3ggPSBuZXcgQm94KG1vdXNlWCwgbW91c2VZLCBtb3VzZVggKyAxLCBtb3VzZVkgKyAxKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlc3RhcnQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IGhhbmRsZTogc2VsZi5oYW5kbGVzW1NPVVRIRUFTVF9IQU5ETEVfSURYXSB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlbW92ZScsIHtcbiAgICAgICAgICBkZXRhaWw6IHsgbW91c2VYOiBlLmNsaWVudFgsIG1vdXNlWTogZS5jbGllbnRZIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgaWYgKHNlbGYuYm94LndpZHRoKCkgPT09IDEgJiYgc2VsZi5ib3guaGVpZ2h0KCkgPT09IDEpIHtcbiAgICAgICAgICBzZWxmLmJveCA9IHRtcEJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ldmVudEJ1cy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFuZGxlZW5kJywge1xuICAgICAgICAgIGRldGFpbDogeyBtb3VzZVg6IGUuY2xpZW50WCwgbW91c2VZOiBlLmNsaWVudFkgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVTdGFydChlKSB7XG4gICAgICB2YXIgaGFuZGxlID0gZS5kZXRhaWwuaGFuZGxlO1xuICAgICAgdmFyIG9yaWdpblBvaW50ID0gWzEgLSBoYW5kbGUucG9zaXRpb25bMF0sIDEgLSBoYW5kbGUucG9zaXRpb25bMV1dO1xuICAgICAgdmFyIF9ib3gkZ2V0QWJzb2x1dGVQb2ludCA9IHRoaXMuYm94LmdldEFic29sdXRlUG9pbnQob3JpZ2luUG9pbnQpLFxuICAgICAgICAgIF9ib3gkZ2V0QWJzb2x1dGVQb2ludDIgPSBzbGljZWRUb0FycmF5KF9ib3gkZ2V0QWJzb2x1dGVQb2ludCwgMiksXG4gICAgICAgICAgb3JpZ2luWCA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMF0sXG4gICAgICAgICAgb3JpZ2luWSA9IF9ib3gkZ2V0QWJzb2x1dGVQb2ludDJbMV07XG4gICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IHsgaGFuZGxlOiBoYW5kbGUsIG9yaWdpblBvaW50OiBvcmlnaW5Qb2ludCwgb3JpZ2luWDogb3JpZ2luWCwgb3JpZ2luWTogb3JpZ2luWSB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wU3RhcnQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkhhbmRsZU1vdmVNb3ZpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhhbmRsZU1vdmVNb3ZpbmcoZSkge1xuICAgICAgdmFyIF9lJGRldGFpbCA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbC5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsLm1vdXNlWTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIGlmIChtb3VzZVggPCAwKSB7XG4gICAgICAgIG1vdXNlWCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1vdXNlWCA+IGNvbnRhaW5lci53aWR0aCkge1xuICAgICAgICBtb3VzZVggPSBjb250YWluZXIud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VZIDwgMCkge1xuICAgICAgICBtb3VzZVkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZVkgPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgIG1vdXNlWSA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luUG9pbnQuc2xpY2UoKTtcbiAgICAgIHZhciBvcmlnaW5YID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWDtcbiAgICAgIHZhciBvcmlnaW5ZID0gdGhpcy5hY3RpdmVIYW5kbGUub3JpZ2luWTtcbiAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmFjdGl2ZUhhbmRsZS5oYW5kbGU7XG4gICAgICB2YXIgVE9QX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbMF0gPT09IDE7XG4gICAgICB2YXIgUklHSFRfTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1sxXSA9PT0gMTtcbiAgICAgIHZhciBCT1RUT01fTU9WQUJMRSA9IGhhbmRsZS5jb25zdHJhaW50c1syXSA9PT0gMTtcbiAgICAgIHZhciBMRUZUX01PVkFCTEUgPSBoYW5kbGUuY29uc3RyYWludHNbM10gPT09IDE7XG4gICAgICB2YXIgTVVMVElfQVhJUyA9IChMRUZUX01PVkFCTEUgfHwgUklHSFRfTU9WQUJMRSkgJiYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKTtcbiAgICAgIHZhciB4MSA9IExFRlRfTU9WQUJMRSB8fCBSSUdIVF9NT1ZBQkxFID8gb3JpZ2luWCA6IHRoaXMuYm94LngxO1xuICAgICAgdmFyIHgyID0gTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUgPyBvcmlnaW5YIDogdGhpcy5ib3gueDI7XG4gICAgICB2YXIgeTEgPSBUT1BfTU9WQUJMRSB8fCBCT1RUT01fTU9WQUJMRSA/IG9yaWdpblkgOiB0aGlzLmJveC55MTtcbiAgICAgIHZhciB5MiA9IFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFID8gb3JpZ2luWSA6IHRoaXMuYm94LnkyO1xuICAgICAgeDEgPSBMRUZUX01PVkFCTEUgPyBtb3VzZVggOiB4MTtcbiAgICAgIHgyID0gUklHSFRfTU9WQUJMRSA/IG1vdXNlWCA6IHgyO1xuICAgICAgeTEgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA6IHkxO1xuICAgICAgeTIgPSBCT1RUT01fTU9WQUJMRSA/IG1vdXNlWSA6IHkyO1xuICAgICAgdmFyIGlzRmxpcHBlZFggPSBmYWxzZSxcbiAgICAgICAgICBpc0ZsaXBwZWRZID0gZmFsc2U7XG4gICAgICBpZiAoTEVGVF9NT1ZBQkxFIHx8IFJJR0hUX01PVkFCTEUpIHtcbiAgICAgICAgaXNGbGlwcGVkWCA9IExFRlRfTU9WQUJMRSA/IG1vdXNlWCA+IG9yaWdpblggOiBtb3VzZVggPCBvcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKFRPUF9NT1ZBQkxFIHx8IEJPVFRPTV9NT1ZBQkxFKSB7XG4gICAgICAgIGlzRmxpcHBlZFkgPSBUT1BfTU9WQUJMRSA/IG1vdXNlWSA+IG9yaWdpblkgOiBtb3VzZVkgPCBvcmlnaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmxpcHBlZFgpIHtcbiAgICAgICAgdmFyIHRtcCA9IHgxO3gxID0geDI7eDIgPSB0bXA7XG4gICAgICAgIG9yaWdpblswXSA9IDEgLSBvcmlnaW5bMF07XG4gICAgICB9XG4gICAgICBpZiAoaXNGbGlwcGVkWSkge1xuICAgICAgICB2YXIgX3RtcCA9IHkxO3kxID0geTI7eTIgPSBfdG1wO1xuICAgICAgICBvcmlnaW5bMV0gPSAxIC0gb3JpZ2luWzFdO1xuICAgICAgfVxuICAgICAgdmFyIGJveCA9IG5ldyBCb3goeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbykge1xuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKE1VTFRJX0FYSVMpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSBtb3VzZVkgPiBib3gueTEgKyByYXRpbyAqIGJveC53aWR0aCgpIHx8IG1vdXNlWSA8IGJveC55MiAtIHJhdGlvICogYm94LndpZHRoKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoVE9QX01PVkFCTEUgfHwgQk9UVE9NX01PVkFCTEUpIHtcbiAgICAgICAgICBpc1ZlcnRpY2FsTW92ZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXRpb01vZGUgPSBpc1ZlcnRpY2FsTW92ZW1lbnQgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGJveC5jb25zdHJhaW5Ub1JhdGlvKHJhdGlvLCBvcmlnaW4sIHJhdGlvTW9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWluID0gdGhpcy5vcHRpb25zLm1pblNpemU7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5vcHRpb25zLm1heFNpemU7XG4gICAgICBib3guY29uc3RyYWluVG9TaXplKG1heC53aWR0aCwgbWF4LmhlaWdodCwgbWluLndpZHRoLCBtaW4uaGVpZ2h0LCBvcmlnaW4sIHRoaXMub3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBwYXJlbnRIZWlnaHQgPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBib3guY29uc3RyYWluVG9Cb3VuZGFyeShwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBvcmlnaW4pO1xuICAgICAgdGhpcy5ib3ggPSBib3g7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BNb3ZlKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25IYW5kbGVNb3ZlRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IYW5kbGVNb3ZlRW5kKGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblJlZ2lvbk1vdmVTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZVN0YXJ0KGUpIHtcbiAgICAgIHZhciBfZSRkZXRhaWwyID0gZS5kZXRhaWwsXG4gICAgICAgICAgbW91c2VYID0gX2UkZGV0YWlsMi5tb3VzZVgsXG4gICAgICAgICAgbW91c2VZID0gX2UkZGV0YWlsMi5tb3VzZVk7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jcm9wcGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBtb3VzZVggPSBtb3VzZVggLSBjb250YWluZXIubGVmdDtcbiAgICAgIG1vdXNlWSA9IG1vdXNlWSAtIGNvbnRhaW5lci50b3A7XG4gICAgICB0aGlzLmN1cnJlbnRNb3ZlID0ge1xuICAgICAgICBvZmZzZXRYOiBtb3VzZVggLSB0aGlzLmJveC54MSxcbiAgICAgICAgb2Zmc2V0WTogbW91c2VZIC0gdGhpcy5ib3gueTFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcFN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BTdGFydCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZU1vdmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZU1vdmluZyhlKSB7XG4gICAgICB2YXIgX2UkZGV0YWlsMyA9IGUuZGV0YWlsLFxuICAgICAgICAgIG1vdXNlWCA9IF9lJGRldGFpbDMubW91c2VYLFxuICAgICAgICAgIG1vdXNlWSA9IF9lJGRldGFpbDMubW91c2VZO1xuICAgICAgdmFyIF9jdXJyZW50TW92ZSA9IHRoaXMuY3VycmVudE1vdmUsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9jdXJyZW50TW92ZS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfY3VycmVudE1vdmUub2Zmc2V0WTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNyb3BwZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG1vdXNlWCA9IG1vdXNlWCAtIGNvbnRhaW5lci5sZWZ0O1xuICAgICAgbW91c2VZID0gbW91c2VZIC0gY29udGFpbmVyLnRvcDtcbiAgICAgIHRoaXMuYm94Lm1vdmUobW91c2VYIC0gb2Zmc2V0WCwgbW91c2VZIC0gb2Zmc2V0WSk7XG4gICAgICBpZiAodGhpcy5ib3gueDEgPCAwKSB7XG4gICAgICAgIHRoaXMuYm94Lm1vdmUoMCwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib3gueDIgPiBjb250YWluZXIud2lkdGgpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShjb250YWluZXIud2lkdGggLSB0aGlzLmJveC53aWR0aCgpLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MSA8IDApIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJveC55MiA+IGNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5ib3gubW92ZShudWxsLCBjb250YWluZXIuaGVpZ2h0IC0gdGhpcy5ib3guaGVpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wTW92ZSh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUmVnaW9uTW92ZUVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVnaW9uTW92ZUVuZChlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgaWYgKG1vZGUgPT09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IHRoaXMub3B0aW9ucy5yZXR1cm5Nb2RlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGUgPT0gJ3JlYWwnKSB7XG4gICAgICAgIHZhciBhY3R1YWxXaWR0aCA9IHRoaXMuaW1hZ2VFbC5uYXR1cmFsV2lkdGg7XG4gICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSB0aGlzLmltYWdlRWwubmF0dXJhbEhlaWdodDtcbiAgICAgICAgdmFyIF9pbWFnZUVsJGdldEJvdW5kaW5nQyA9IHRoaXMuaW1hZ2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQy53aWR0aCxcbiAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQgPSBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MuaGVpZ2h0O1xuICAgICAgICB2YXIgZmFjdG9yWCA9IGFjdHVhbFdpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICB2YXIgZmFjdG9yWSA9IGFjdHVhbEhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJveC54MSAqIGZhY3RvclgpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib3gueTEgKiBmYWN0b3JZKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpICogZmFjdG9yWCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuYm94LmhlaWdodCgpICogZmFjdG9yWSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAncmF0aW8nKSB7XG4gICAgICAgIHZhciBfaW1hZ2VFbCRnZXRCb3VuZGluZ0MyID0gdGhpcy5pbWFnZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgX2VsZW1lbnRXaWR0aCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIud2lkdGgsXG4gICAgICAgICAgICBfZWxlbWVudEhlaWdodCA9IF9pbWFnZUVsJGdldEJvdW5kaW5nQzIuaGVpZ2h0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJvdW5kKHRoaXMuYm94LngxIC8gX2VsZW1lbnRXaWR0aCwgMyksXG4gICAgICAgICAgeTogcm91bmQodGhpcy5ib3gueTEgLyBfZWxlbWVudEhlaWdodCwgMyksXG4gICAgICAgICAgd2lkdGg6IHJvdW5kKHRoaXMuYm94LndpZHRoKCkgLyBfZWxlbWVudFdpZHRoLCAzKSxcbiAgICAgICAgICBoZWlnaHQ6IHJvdW5kKHRoaXMuYm94LmhlaWdodCgpIC8gX2VsZW1lbnRIZWlnaHQsIDMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ3JhdycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKHRoaXMuYm94LngxKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHRoaXMuYm94LnkxKSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmJveC53aWR0aCgpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5ib3guaGVpZ2h0KCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdwYXJzZU9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0cykge1xuICAgICAgdmFyIGRlZmF1bHRzJCQxID0ge1xuICAgICAgICBhc3BlY3RSYXRpbzogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsIH0sXG4gICAgICAgIG1pblNpemU6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9LFxuICAgICAgICBzdGFydFNpemU6IHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAsIHVuaXQ6ICclJyB9LFxuICAgICAgICByZXR1cm5Nb2RlOiAncmVhbCcsXG4gICAgICAgIG9uSW5pdGlhbGl6ZTogbnVsbCxcbiAgICAgICAgb25Dcm9wU3RhcnQ6IG51bGwsXG4gICAgICAgIG9uQ3JvcE1vdmU6IG51bGwsXG4gICAgICAgIG9uQ3JvcEVuZDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgICBpZiAob3B0cy5hc3BlY3RSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5hc3BlY3RSYXRpbyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbyA9IG9wdHMuYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5hc3BlY3RSYXRpbyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBvcHRzLmFzcGVjdFJhdGlvWzFdIC8gb3B0cy5hc3BlY3RSYXRpb1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1heFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMubWF4U2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9wdHMubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICBtYXhTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLm1heFNpemVbMF0gfHwgbnVsbCxcbiAgICAgICAgICBoZWlnaHQ6IG9wdHMubWF4U2l6ZVsxXSB8fCBudWxsLFxuICAgICAgICAgIHVuaXQ6IG9wdHMubWF4U2l6ZVsyXSB8fCAncHgnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbWluU2l6ZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5taW5TaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgIG1pblNpemUgPSB7XG4gICAgICAgICAgd2lkdGg6IG9wdHMubWluU2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5taW5TaXplWzFdIHx8IG51bGwsXG4gICAgICAgICAgdW5pdDogb3B0cy5taW5TaXplWzJdIHx8ICdweCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydFNpemUgPSBudWxsO1xuICAgICAgaWYgKG9wdHMuc3RhcnRTaXplICE9PSB1bmRlZmluZWQgJiYgb3B0cy5zdGFydFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRTaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBvcHRzLnN0YXJ0U2l6ZVswXSB8fCBudWxsLFxuICAgICAgICAgIGhlaWdodDogb3B0cy5zdGFydFNpemVbMV0gfHwgbnVsbCxcbiAgICAgICAgICB1bml0OiBvcHRzLnN0YXJ0U2l6ZVsyXSB8fCAnJSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkluaXRpYWxpemUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uSW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkluaXRpYWxpemUgPSBvcHRzLm9uSW5pdGlhbGl6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvbkNyb3BTdGFydCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25Dcm9wU3RhcnQgPSBvcHRzLm9uQ3JvcFN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcEVuZCA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25Dcm9wRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcEVuZCA9IG9wdHMub25Dcm9wRW5kO1xuICAgICAgfVxuICAgICAgdmFyIG9uQ3JvcE1vdmUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ3JvcHByLmpzOiBgb25VcGRhdGVgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIGBvbkNyb3BNb3ZlYCBvciBgb25Dcm9wRW5kYCBpbnN0ZWFkLicpO1xuICAgICAgICBvbkNyb3BNb3ZlID0gb3B0cy5vblVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkNyb3BNb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQ3JvcE1vdmUgPSBvcHRzLm9uQ3JvcE1vdmU7XG4gICAgICB9XG4gICAgICB2YXIgcmV0dXJuTW9kZSA9IG51bGw7XG4gICAgICBpZiAob3B0cy5yZXR1cm5Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBvcHRzLnJldHVybk1vZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFsncmVhbCcsICdyYXRpbycsICdyYXcnXS5pbmRleE9mKHMpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCByZXR1cm4gbW9kZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5Nb2RlID0gcztcbiAgICAgIH1cbiAgICAgIHZhciBjb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbiBjb252ZXJ0VG9QaXhlbHMoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBzaXplS2V5cyA9IFsnbWF4U2l6ZScsICdtaW5TaXplJywgJ3N0YXJ0U2l6ZSddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHNpemVLZXlzW2ldO1xuICAgICAgICAgIGlmICh0aGlzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0udW5pdCA9PSAnJScpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XS53aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XS53aWR0aCA9IHRoaXNba2V5XS53aWR0aCAvIDEwMCAqIHdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzW2tleV0uaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldLmhlaWdodCA9IHRoaXNba2V5XS5oZWlnaHQgLyAxMDAgKiBoZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV0udW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYgIT09IG51bGwgPyB2IDogZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3BlY3RSYXRpbzogZGVmYXVsdFZhbHVlKGFzcGVjdFJhdGlvLCBkZWZhdWx0cyQkMS5hc3BlY3RSYXRpbyksXG4gICAgICAgIG1heFNpemU6IGRlZmF1bHRWYWx1ZShtYXhTaXplLCBkZWZhdWx0cyQkMS5tYXhTaXplKSxcbiAgICAgICAgbWluU2l6ZTogZGVmYXVsdFZhbHVlKG1pblNpemUsIGRlZmF1bHRzJCQxLm1pblNpemUpLFxuICAgICAgICBzdGFydFNpemU6IGRlZmF1bHRWYWx1ZShzdGFydFNpemUsIGRlZmF1bHRzJCQxLnN0YXJ0U2l6ZSksXG4gICAgICAgIHJldHVybk1vZGU6IGRlZmF1bHRWYWx1ZShyZXR1cm5Nb2RlLCBkZWZhdWx0cyQkMS5yZXR1cm5Nb2RlKSxcbiAgICAgICAgb25Jbml0aWFsaXplOiBkZWZhdWx0VmFsdWUob25Jbml0aWFsaXplLCBkZWZhdWx0cyQkMS5vbkluaXRpYWxpemUpLFxuICAgICAgICBvbkNyb3BTdGFydDogZGVmYXVsdFZhbHVlKG9uQ3JvcFN0YXJ0LCBkZWZhdWx0cyQkMS5vbkNyb3BTdGFydCksXG4gICAgICAgIG9uQ3JvcE1vdmU6IGRlZmF1bHRWYWx1ZShvbkNyb3BNb3ZlLCBkZWZhdWx0cyQkMS5vbkNyb3BNb3ZlKSxcbiAgICAgICAgb25Dcm9wRW5kOiBkZWZhdWx0VmFsdWUob25Dcm9wRW5kLCBkZWZhdWx0cyQkMS5vbkNyb3BFbmQpLFxuICAgICAgICBjb252ZXJ0VG9QaXhlbHM6IGNvbnZlcnRUb1BpeGVsc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3BwckNvcmU7XG59KCk7XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbn1cblxudmFyIENyb3BwciQxID0gZnVuY3Rpb24gKF9Dcm9wcHJDb3JlKSB7XG4gIGluaGVyaXRzKENyb3BwciwgX0Nyb3BwckNvcmUpO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIENhbGxzIHRoZSBDcm9wcHJDb3JlJ3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBmdW5jdGlvbiBDcm9wcHIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfZGVmZXJyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3Bwcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENyb3Bwci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENyb3BwcikpLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucywgX2RlZmVycmVkKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlXSBXaGljaCBtb2RlIG9mIGNhbGN1bGF0aW9uIHRvIHVzZTogJ3JlYWwnLCAncmF0aW8nIG9yXG4gICAqICAgICAgJ3JhdycuXG4gICAqL1xuICBjcmVhdGVDbGFzcyhDcm9wcHIsIFt7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShtb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ2dldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgaW1hZ2Ugc3JjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoc3JjKSB7XG4gICAgICByZXR1cm4gZ2V0KENyb3Bwci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wcHIucHJvdG90eXBlKSwgJ3NldEltYWdlJywgdGhpcykuY2FsbCh0aGlzLCBzcmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmV0dXJuIGdldChDcm9wcHIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3JvcHByLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbW92ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICAgIHRoaXMuYm94Lm1vdmUoeCwgeSk7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BFbmQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ3JvcEVuZCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgICAqICAgICAgRGVmYXVsdHMgdG8gWzAuNSwgMC41XSAoY2VudGVyKS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2l6ZVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplVG8od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWy41LCAuNV07XG4gICAgICB0aGlzLmJveC5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luKTtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ3JvcEVuZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGNyb3AgcmVnaW9uIGJ5IGEgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvcmlnaW4gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICAgKiAgICAgIERlZmF1bHRzIHRvIFswLjUsIDAuNV0gKGNlbnRlcikuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzY2FsZUJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IpIHtcbiAgICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsuNSwgLjVdO1xuICAgICAgdGhpcy5ib3guc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmJveCA9IHRoaXMuaW5pdGlhbGl6ZUJveCh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3JvcHByO1xufShDcm9wcHJDb3JlKTtcblxucmV0dXJuIENyb3BwciQxO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/croppr/dist/croppr.js\n");

/***/ }),

/***/ "./node_modules/croppr/src/box.js":
/*!****************************************!*\
  !*** ./node_modules/croppr/src/box.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Box; });\n/**\n * Box component\n */\nclass Box {\n  /**\n   * Creates a new Box instance.\n   * @constructor\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  constructor(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /** \n   * Sets the new dimensions of the box.\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} x2\n   * @param {Number} y2\n   */\n  set(x1 = null, y1 = null, x2 = null, y2 = null) {\n    this.x1 = x1 == null ? this.x1 : x1;\n    this.y1 = y1 == null ? this.y1 : y1;\n    this.x2 = x2 == null ? this.x2 : x2;\n    this.y2 = y2 == null ? this.y2 : y2;\n    return this;\n  }\n\n  /**\n   * Calculates the width of the box.\n   * @returns {Number}\n   */\n  width() {\n    return Math.abs(this.x2 - this.x1);\n  }\n\n  /**\n   * Calculates the height of the box.\n   * @returns {Number}\n   */\n  height() {\n    return Math.abs(this.y2 - this.y1);\n  }\n\n  /**\n   * Resizes the box to a new size.\n   * @param {Number} newWidth\n   * @param {Number} newHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  resize(newWidth, newHeight, origin = [0, 0]) {\n    const fromX = this.x1 + (this.width() * origin[0]);\n    const fromY = this.y1 + (this.height() * origin[1]);\n\n    this.x1 = fromX - (newWidth * origin[0]);\n    this.y1 = fromY - (newHeight * origin[1]);\n    this.x2 = this.x1 + newWidth;\n    this.y2 = this.y1 + newHeight;\n\n    return this;\n  }\n\n  /**\n   * Scale the box by a factor.\n   * @param {Number} factor\n   * @param {Array} [origin] The origin point to resize from.\n   *      Defaults to [0, 0] (top left).\n   */\n  scale(factor, origin = [0, 0]) {\n    const newWidth = this.width() * factor;\n    const newHeight = this.height() * factor;\n    this.resize(newWidth, newHeight, origin);\n    return this;\n  }\n\n  /**\n   * Move the box to the specified coordinates.\n   */\n  move(x = null, y = null) {\n    let width = this.width();\n    let height = this.height();\n    x = x === null ? this.x1 : x;\n    y = y === null ? this.y1 : y;\n\n    this.x1 = x;\n    this.y1 = y;\n    this.x2 = x + width;\n    this.y2 = y + height;\n    return this;\n  }\n\n  /**\n   * Get relative x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getRelativePoint(point = [0, 0]) {\n    const x = this.width() * point[0];\n    const y = this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Get absolute x and y coordinates of a given point within the box.\n   * @param {Array} point The x and y ratio position within the box.\n   * @returns {Array} The x and y coordinates [x, y].\n   */\n  getAbsolutePoint(point = [0, 0]) {\n    const x = this.x1 + this.width() * point[0];\n    const y = this.y1 + this.height() * point[1];\n    return [x, y];\n  }\n\n  /**\n   * Constrain the box to a fixed ratio.\n   * @param {Number} ratio\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {String} [grow] The axis to grow to maintain the ratio.\n   *     Defaults to 'height'.\n   */\n  constrainToRatio(ratio, origin = [0, 0], grow = 'height') {\n    if (ratio === null) { return; }\n    const width = this.width();\n    const height = this.height();\n    switch (grow) {\n      case 'height': // Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n        break;\n      case 'width': // Grow width only\n        this.resize(this.height() * 1 / ratio, this.height(), origin);\n        break;\n      default: // Default: Grow height only\n        this.resize(this.width(), this.width() * ratio, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box within a boundary.\n   * @param {Number} boundaryWidth\n   * @param {Number} boundaryHeight\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   */\n  constrainToBoundary(boundaryWidth, boundaryHeight, origin = [0, 0]) {\n\n    // Calculate the maximum sizes for each direction of growth\n    const [originX, originY] = this.getAbsolutePoint(origin);\n    const maxIfLeft = originX\n    const maxIfTop = originY\n    const maxIfRight = boundaryWidth - originX\n    const maxIfBottom = boundaryHeight - originY\n\n    // Express the direction of growth in terms of left, both,\n    // and right as -1, 0, and 1 respectively. Ditto for top/both/down.\n    const directionX = -2 * origin[0] + 1;\n    const directionY = -2 * origin[1] + 1;\n\n    // Determine the max size to use according to the direction of growth.\n    let [maxWidth, maxHeight] = [null, null];\n    switch (directionX) {\n      case -1: maxWidth = maxIfLeft; break;\n      case 0: maxWidth = Math.min(maxIfLeft, maxIfRight) * 2; break;\n      case +1: maxWidth = maxIfRight; break;\n    }\n    switch (directionY) {\n      case -1: maxHeight = maxIfTop; break;\n      case 0: maxHeight = Math.min(maxIfTop, maxIfBottom) * 2; break;\n      case +1: maxHeight = maxIfBottom; break;\n    }\n\n    // Resize if the box exceeds the calculated max width/height.\n    if (this.width() > maxWidth) {\n      const factor = maxWidth / this.width();\n      this.scale(factor, origin);\n    }\n    if (this.height() > maxHeight) {\n      const factor = maxHeight / this.height();\n      this.scale(factor, origin);\n    }\n\n    return this;\n  }\n\n  /**\n   * Constrain the box to a maximum/minimum size.\n   * @param {Number} [maxWidth]\n   * @param {Number} [maxHeight]\n   * @param {Number} [minWidth]\n   * @param {Number} [minHeight]\n   * @param {Array} [origin] The origin point to resize from.\n   *     Defaults to [0, 0] (top left).\n   * @param {Number} [ratio] Ratio to maintain.\n   */\n  constrainToSize(maxWidth = null, maxHeight = null,\n    minWidth = null, minHeight = null,\n    origin = [0, 0], ratio = null) {\n\n    // Calculate new max/min widths & heights that constrains to the ratio\n    if (ratio) {\n      if (ratio > 1) {\n        maxWidth = maxHeight * 1 / ratio;\n        minHeight = minHeight * ratio;\n      } else if (ratio < 1) {\n        maxHeight = maxWidth * ratio;\n        minWidth = minHeight * 1 / ratio;\n      }\n    }\n\n    if (maxWidth && this.width() > maxWidth) {\n      const newWidth = maxWidth,\n        newHeight = ratio === null ? this.height() : maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (maxHeight && this.height() > maxHeight) {\n      const newWidth = ratio === null ? this.width() : maxWidth,\n        newHeight = maxHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minWidth && this.width() < minWidth) {\n      const newWidth = minWidth,\n        newHeight = ratio === null ? this.height() : minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    if (minHeight && this.height() < minHeight) {\n      const newWidth = ratio === null ? this.width() : minWidth,\n        newHeight = minHeight;\n      this.resize(newWidth, newHeight, origin);\n    }\n\n    return this;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JvcHByL3NyYy9ib3guanM/NGY5NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsNkRBQTZEO0FBQzdELHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDhEQUE4RDtBQUM5RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcm9wcHIvc3JjL2JveC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQm94IGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3gge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCb3ggaW5zdGFuY2UuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICB9XG5cbiAgLyoqIFxuICAgKiBTZXRzIHRoZSBuZXcgZGltZW5zaW9ucyBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICovXG4gIHNldCh4MSA9IG51bGwsIHkxID0gbnVsbCwgeDIgPSBudWxsLCB5MiA9IG51bGwpIHtcbiAgICB0aGlzLngxID0geDEgPT0gbnVsbCA/IHRoaXMueDEgOiB4MTtcbiAgICB0aGlzLnkxID0geTEgPT0gbnVsbCA/IHRoaXMueTEgOiB5MTtcbiAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IHRoaXMueDIgOiB4MjtcbiAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IHRoaXMueTIgOiB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCBvZiB0aGUgYm94LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGJveC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGJveCB0byBhIG5ldyBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV3V2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld0hlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgIERlZmF1bHRzIHRvIFswLCAwXSAodG9wIGxlZnQpLlxuICAgKi9cbiAgcmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGZyb21YID0gdGhpcy54MSArICh0aGlzLndpZHRoKCkgKiBvcmlnaW5bMF0pO1xuICAgIGNvbnN0IGZyb21ZID0gdGhpcy55MSArICh0aGlzLmhlaWdodCgpICogb3JpZ2luWzFdKTtcblxuICAgIHRoaXMueDEgPSBmcm9tWCAtIChuZXdXaWR0aCAqIG9yaWdpblswXSk7XG4gICAgdGhpcy55MSA9IGZyb21ZIC0gKG5ld0hlaWdodCAqIG9yaWdpblsxXSk7XG4gICAgdGhpcy54MiA9IHRoaXMueDEgKyBuZXdXaWR0aDtcbiAgICB0aGlzLnkyID0gdGhpcy55MSArIG5ld0hlaWdodDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBib3ggYnkgYSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmYWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW29yaWdpbl0gVGhlIG9yaWdpbiBwb2ludCB0byByZXNpemUgZnJvbS5cbiAgICogICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICovXG4gIHNjYWxlKGZhY3Rvciwgb3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoKCkgKiBmYWN0b3I7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQoKSAqIGZhY3RvcjtcbiAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGJveCB0byB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgbW92ZSh4ID0gbnVsbCwgeSA9IG51bGwpIHtcbiAgICBsZXQgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgbGV0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgeCA9IHggPT09IG51bGwgPyB0aGlzLngxIDogeDtcbiAgICB5ID0geSA9PT0gbnVsbCA/IHRoaXMueTEgOiB5O1xuXG4gICAgdGhpcy54MSA9IHg7XG4gICAgdGhpcy55MSA9IHk7XG4gICAgdGhpcy54MiA9IHggKyB3aWR0aDtcbiAgICB0aGlzLnkyID0geSArIGhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmVsYXRpdmUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRSZWxhdGl2ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMud2lkdGgoKSAqIHBvaW50WzBdO1xuICAgIGNvbnN0IHkgPSB0aGlzLmhlaWdodCgpICogcG9pbnRbMV07XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWJzb2x1dGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludCBUaGUgeCBhbmQgeSByYXRpbyBwb3NpdGlvbiB3aXRoaW4gdGhlIGJveC5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgeCBhbmQgeSBjb29yZGluYXRlcyBbeCwgeV0uXG4gICAqL1xuICBnZXRBYnNvbHV0ZVBvaW50KHBvaW50ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgeCA9IHRoaXMueDEgKyB0aGlzLndpZHRoKCkgKiBwb2ludFswXTtcbiAgICBjb25zdCB5ID0gdGhpcy55MSArIHRoaXMuaGVpZ2h0KCkgKiBwb2ludFsxXTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbiB0aGUgYm94IHRvIGEgZml4ZWQgcmF0aW8uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3Jvd10gVGhlIGF4aXMgdG8gZ3JvdyB0byBtYWludGFpbiB0aGUgcmF0aW8uXG4gICAqICAgICBEZWZhdWx0cyB0byAnaGVpZ2h0Jy5cbiAgICovXG4gIGNvbnN0cmFpblRvUmF0aW8ocmF0aW8sIG9yaWdpbiA9IFswLCAwXSwgZ3JvdyA9ICdoZWlnaHQnKSB7XG4gICAgaWYgKHJhdGlvID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgc3dpdGNoIChncm93KSB7XG4gICAgICBjYXNlICdoZWlnaHQnOiAvLyBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOiAvLyBHcm93IHdpZHRoIG9ubHlcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5oZWlnaHQoKSAqIDEgLyByYXRpbywgdGhpcy5oZWlnaHQoKSwgb3JpZ2luKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBEZWZhdWx0OiBHcm93IGhlaWdodCBvbmx5XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgoKSwgdGhpcy53aWR0aCgpICogcmF0aW8sIG9yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RyYWluIHRoZSBib3ggd2l0aGluIGEgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeVdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBib3VuZGFyeUhlaWdodFxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3JpZ2luXSBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gWzAsIDBdICh0b3AgbGVmdCkuXG4gICAqL1xuICBjb25zdHJhaW5Ub0JvdW5kYXJ5KGJvdW5kYXJ5V2lkdGgsIGJvdW5kYXJ5SGVpZ2h0LCBvcmlnaW4gPSBbMCwgMF0pIHtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBzaXplcyBmb3IgZWFjaCBkaXJlY3Rpb24gb2YgZ3Jvd3RoXG4gICAgY29uc3QgW29yaWdpblgsIG9yaWdpblldID0gdGhpcy5nZXRBYnNvbHV0ZVBvaW50KG9yaWdpbik7XG4gICAgY29uc3QgbWF4SWZMZWZ0ID0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmVG9wID0gb3JpZ2luWVxuICAgIGNvbnN0IG1heElmUmlnaHQgPSBib3VuZGFyeVdpZHRoIC0gb3JpZ2luWFxuICAgIGNvbnN0IG1heElmQm90dG9tID0gYm91bmRhcnlIZWlnaHQgLSBvcmlnaW5ZXG5cbiAgICAvLyBFeHByZXNzIHRoZSBkaXJlY3Rpb24gb2YgZ3Jvd3RoIGluIHRlcm1zIG9mIGxlZnQsIGJvdGgsXG4gICAgLy8gYW5kIHJpZ2h0IGFzIC0xLCAwLCBhbmQgMSByZXNwZWN0aXZlbHkuIERpdHRvIGZvciB0b3AvYm90aC9kb3duLlxuICAgIGNvbnN0IGRpcmVjdGlvblggPSAtMiAqIG9yaWdpblswXSArIDE7XG4gICAgY29uc3QgZGlyZWN0aW9uWSA9IC0yICogb3JpZ2luWzFdICsgMTtcblxuICAgIC8vIERldGVybWluZSB0aGUgbWF4IHNpemUgdG8gdXNlIGFjY29yZGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIGdyb3d0aC5cbiAgICBsZXQgW21heFdpZHRoLCBtYXhIZWlnaHRdID0gW251bGwsIG51bGxdO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uWCkge1xuICAgICAgY2FzZSAtMTogbWF4V2lkdGggPSBtYXhJZkxlZnQ7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhXaWR0aCA9IE1hdGgubWluKG1heElmTGVmdCwgbWF4SWZSaWdodCkgKiAyOyBicmVhaztcbiAgICAgIGNhc2UgKzE6IG1heFdpZHRoID0gbWF4SWZSaWdodDsgYnJlYWs7XG4gICAgfVxuICAgIHN3aXRjaCAoZGlyZWN0aW9uWSkge1xuICAgICAgY2FzZSAtMTogbWF4SGVpZ2h0ID0gbWF4SWZUb3A7IGJyZWFrO1xuICAgICAgY2FzZSAwOiBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhJZlRvcCwgbWF4SWZCb3R0b20pICogMjsgYnJlYWs7XG4gICAgICBjYXNlICsxOiBtYXhIZWlnaHQgPSBtYXhJZkJvdHRvbTsgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplIGlmIHRoZSBib3ggZXhjZWVkcyB0aGUgY2FsY3VsYXRlZCBtYXggd2lkdGgvaGVpZ2h0LlxuICAgIGlmICh0aGlzLndpZHRoKCkgPiBtYXhXaWR0aCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gbWF4V2lkdGggLyB0aGlzLndpZHRoKCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IG1heEhlaWdodCAvIHRoaXMuaGVpZ2h0KCk7XG4gICAgICB0aGlzLnNjYWxlKGZhY3Rvciwgb3JpZ2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW4gdGhlIGJveCB0byBhIG1heGltdW0vbWluaW11bSBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFdpZHRoXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heEhlaWdodF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5XaWR0aF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHRdXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcmlnaW5dIFRoZSBvcmlnaW4gcG9pbnQgdG8gcmVzaXplIGZyb20uXG4gICAqICAgICBEZWZhdWx0cyB0byBbMCwgMF0gKHRvcCBsZWZ0KS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gUmF0aW8gdG8gbWFpbnRhaW4uXG4gICAqL1xuICBjb25zdHJhaW5Ub1NpemUobWF4V2lkdGggPSBudWxsLCBtYXhIZWlnaHQgPSBudWxsLFxuICAgIG1pbldpZHRoID0gbnVsbCwgbWluSGVpZ2h0ID0gbnVsbCxcbiAgICBvcmlnaW4gPSBbMCwgMF0sIHJhdGlvID0gbnVsbCkge1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyBtYXgvbWluIHdpZHRocyAmIGhlaWdodHMgdGhhdCBjb25zdHJhaW5zIHRvIHRoZSByYXRpb1xuICAgIGlmIChyYXRpbykge1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICBtYXhXaWR0aCA9IG1heEhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgICAgbWluSGVpZ2h0ID0gbWluSGVpZ2h0ICogcmF0aW87XG4gICAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMSkge1xuICAgICAgICBtYXhIZWlnaHQgPSBtYXhXaWR0aCAqIHJhdGlvO1xuICAgICAgICBtaW5XaWR0aCA9IG1pbkhlaWdodCAqIDEgLyByYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggJiYgdGhpcy53aWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHJhdGlvID09PSBudWxsID8gdGhpcy5oZWlnaHQoKSA6IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1heEhlaWdodCAmJiB0aGlzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHJhdGlvID09PSBudWxsID8gdGhpcy53aWR0aCgpIDogbWF4V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgIHRoaXMucmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgaWYgKG1pbldpZHRoICYmIHRoaXMud2lkdGgoKSA8IG1pbldpZHRoKSB7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMuaGVpZ2h0KCkgOiBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIGlmIChtaW5IZWlnaHQgJiYgdGhpcy5oZWlnaHQoKSA8IG1pbkhlaWdodCkge1xuICAgICAgY29uc3QgbmV3V2lkdGggPSByYXRpbyA9PT0gbnVsbCA/IHRoaXMud2lkdGgoKSA6IG1pbldpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICB0aGlzLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0LCBvcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/croppr/src/box.js\n");

/***/ })

}]);